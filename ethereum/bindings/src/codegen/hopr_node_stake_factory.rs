/**

Generated by the following Solidity interface...
```solidity
interface HoprNodeStakeFactory {
    struct HoprNetwork {
        address tokenAddress;
        uint256 defaultTokenAllowance;
        bytes32 defaultAnnouncementTarget;
    }
    struct SafeLibAddress {
        address safeAddress;
        address safeProxyFactoryAddress;
        address fallbackHandlerAddress;
        address multiSendAddress;
    }

    error Create2EmptyBytecode();
    error FailedDeployment();
    error InsufficientBalance(uint256 balance, uint256 needed);
    error InvalidFunctionSelector();
    error InvalidOwner();
    error NotTokenRecipient();
    error OwnableInvalidOwner(address owner);
    error OwnableUnauthorizedAccount(address account);
    error SafeERC20FailedOperation(address token);
    error TooFewOwners();
    error UnauthorizedToken();

    event HoprNodeStakeHoprNetworkUpdated(HoprNetwork hoprNetwork);
    event HoprNodeStakeModuleUpdated(address moduleImplementation);
    event HoprNodeStakeSafeLibUpdated(SafeLibAddress safeLibAddresses);
    event NewHoprNodeStakeModule(address instance);
    event NewHoprNodeStakeModuleForSafe(address module, address safe);
    event NewHoprNodeStakeSafe(address instance);
    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor(address _moduleSingletonAddress, address _announcementAddress, address initialOwner);

    function DEPLOYSAFEANDMODULEANDINCLUDENODES_IDENTIFIER() external view returns (bytes32);
    function DEPLOYSAFEMODULE_FUNCTION_IDENTIFIER() external view returns (bytes32);
    function TOKENS_RECIPIENT_INTERFACE_HASH() external view returns (bytes32);
    function acceptOwnership() external;
    function clone(uint256 nonce, bytes32 defaultTarget, address[] memory admins) external returns (address, address payable);
    function defaultHoprNetwork() external view returns (address tokenAddress, uint256 defaultTokenAllowance, bytes32 defaultAnnouncementTarget);
    function deployModule(address safeProxyAddr, bytes32 defaultTarget, uint256 nonce) external returns (address moduleProxy);
    function moduleSingletonAddress() external view returns (address);
    function owner() external view returns (address);
    function pendingOwner() external view returns (address);
    function predictModuleAddress(bytes32 salt, address safe, bytes32 defaultTarget) external view returns (address predicted);
    function predictModuleAddress(address caller, uint256 nonce, address safe, bytes32 defaultTarget) external view returns (address predicted);
    function predictSafeAddress(address[] memory admins, uint256 nonce) external view returns (address predicted);
    function reclaimErc20(address token) external;
    function renounceOwnership() external;
    function safeLibAddresses() external view returns (address safeAddress, address safeProxyFactoryAddress, address fallbackHandlerAddress, address multiSendAddress);
    function safeVersion() external pure returns (string memory);
    function tokensReceived(address, address from, address to, uint256 amount, bytes memory userData, bytes memory) external;
    function transferOwnership(address newOwner) external;
    function updateErc1820Implementer(address _newImplementer) external;
    function updateHoprNetwork(HoprNetwork memory _newHoprNetwork) external;
    function updateModuleSingletonAddress(address _newModuleSingletonAddress) external;
    function updateSafeLibAddress(SafeLibAddress memory _newSafeLibAddresses) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "_moduleSingletonAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_announcementAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "initialOwner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "DEPLOYSAFEANDMODULEANDINCLUDENODES_IDENTIFIER",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "DEPLOYSAFEMODULE_FUNCTION_IDENTIFIER",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "TOKENS_RECIPIENT_INTERFACE_HASH",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "acceptOwnership",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "clone",
    "inputs": [
      {
        "name": "nonce",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "defaultTarget",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "admins",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "address",
        "internalType": "address payable"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "defaultHoprNetwork",
    "inputs": [],
    "outputs": [
      {
        "name": "tokenAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "defaultTokenAllowance",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "defaultAnnouncementTarget",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "deployModule",
    "inputs": [
      {
        "name": "safeProxyAddr",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "defaultTarget",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "nonce",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "moduleProxy",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "moduleSingletonAddress",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "owner",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "pendingOwner",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "predictModuleAddress",
    "inputs": [
      {
        "name": "salt",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "safe",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "defaultTarget",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "predicted",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "predictModuleAddress",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "nonce",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "safe",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "defaultTarget",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "predicted",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "predictSafeAddress",
    "inputs": [
      {
        "name": "admins",
        "type": "address[]",
        "internalType": "address[]"
      },
      {
        "name": "nonce",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "predicted",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "reclaimErc20",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "renounceOwnership",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "safeLibAddresses",
    "inputs": [],
    "outputs": [
      {
        "name": "safeAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "safeProxyFactoryAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "fallbackHandlerAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "multiSendAddress",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "safeVersion",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "tokensReceived",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "from",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "userData",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "transferOwnership",
    "inputs": [
      {
        "name": "newOwner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "updateErc1820Implementer",
    "inputs": [
      {
        "name": "_newImplementer",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "updateHoprNetwork",
    "inputs": [
      {
        "name": "_newHoprNetwork",
        "type": "tuple",
        "internalType": "struct HoprNodeStakeFactory.HoprNetwork",
        "components": [
          {
            "name": "tokenAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "defaultTokenAllowance",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "defaultAnnouncementTarget",
            "type": "bytes32",
            "internalType": "bytes32"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "updateModuleSingletonAddress",
    "inputs": [
      {
        "name": "_newModuleSingletonAddress",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "updateSafeLibAddress",
    "inputs": [
      {
        "name": "_newSafeLibAddresses",
        "type": "tuple",
        "internalType": "struct HoprNodeStakeFactory.SafeLibAddress",
        "components": [
          {
            "name": "safeAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "safeProxyFactoryAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "fallbackHandlerAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "multiSendAddress",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "HoprNodeStakeHoprNetworkUpdated",
    "inputs": [
      {
        "name": "hoprNetwork",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct HoprNodeStakeFactory.HoprNetwork",
        "components": [
          {
            "name": "tokenAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "defaultTokenAllowance",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "defaultAnnouncementTarget",
            "type": "bytes32",
            "internalType": "bytes32"
          }
        ]
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "HoprNodeStakeModuleUpdated",
    "inputs": [
      {
        "name": "moduleImplementation",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "HoprNodeStakeSafeLibUpdated",
    "inputs": [
      {
        "name": "safeLibAddresses",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct HoprNodeStakeFactory.SafeLibAddress",
        "components": [
          {
            "name": "safeAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "safeProxyFactoryAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "fallbackHandlerAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "multiSendAddress",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "NewHoprNodeStakeModule",
    "inputs": [
      {
        "name": "instance",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "NewHoprNodeStakeModuleForSafe",
    "inputs": [
      {
        "name": "module",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "safe",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "NewHoprNodeStakeSafe",
    "inputs": [
      {
        "name": "instance",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OwnershipTransferStarted",
    "inputs": [
      {
        "name": "previousOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OwnershipTransferred",
    "inputs": [
      {
        "name": "previousOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "Create2EmptyBytecode",
    "inputs": []
  },
  {
    "type": "error",
    "name": "FailedDeployment",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InsufficientBalance",
    "inputs": [
      {
        "name": "balance",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "needed",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidFunctionSelector",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidOwner",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotTokenRecipient",
    "inputs": []
  },
  {
    "type": "error",
    "name": "OwnableInvalidOwner",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "OwnableUnauthorizedAccount",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "SafeERC20FailedOperation",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "TooFewOwners",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UnauthorizedToken",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod HoprNodeStakeFactory {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x7329fcb43b46531bca003ddc8fcb67ffe91900c76260a0819052734e1dcf7ad4e460cfd30791ccc4f9c8a4f820ec6760c0819052733efcbb83a4a7afcb4f68d501e2c2203a38be77f460e08190527338869bf66a61cf6bdb996a6ae40d5853fd43b526610100819052600480546001600160a01b031990811690951790556005805485169093179092556006805484169091179055600780548316909117905561018060405273d4fdec44db9d44b8f2b6d529620f9c0c7066a2c1610120819052683635c9adc5dea000006101408190525f61016081905260088054909416909217909255600991909155600a553480156100f8575f5ffd5b506040516129af3803806129af833981016040819052610117916103ee565b806001600160a01b03811661014557604051631e4fbdf760e01b81525f600482015260240160405180910390fd5b61014e81610314565b503060808190526040805160208101929092525f9082015260600160408051601f198184030181529082905261018c91600160f81b9060200161042e565b604051602081830303815290604052600390816101a99190610505565b506101b383610330565b6040516329965a1d60e01b815230600482018190527fb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b60248301526044820152731820a4b7618bde71dce8cdc73aab6c95905fad24906329965a1d906064015f604051808303815f87803b158015610229575f5ffd5b505af115801561023b573d5f5f3e3d5ffd5b505050506001600160601b0319606083811b919091166b01000300000000000000000017600a55604080516004546001600160a01b039081168252600554811660208301526006548116828401526007541692810192909252517f87eb507b2b42eb659807d7a1f63c89b8e22c674689603eac07a3713f06fec9c39181900360800190a1604080516008546001600160a01b031681526009546020820152600a548183015290517f54cfcf4bdb6f20632ba544cd684130fc9db4dc2fe6360926d6b7866297f0315e9181900360600190a15050506105bf565b600180546001600160a01b031916905561032d81610384565b50565b600280546001600160a01b0319166001600160a01b0383169081179091556040519081527fdd60725a88508fe2dcb769bd824280a2a01356198c795515d175abc4bc40b74e9060200160405180910390a150565b5f80546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b80516001600160a01b03811681146103e9575f5ffd5b919050565b5f5f5f60608486031215610400575f5ffd5b610409846103d3565b9250610417602085016103d3565b9150610425604085016103d3565b90509250925092565b5f83518060208601845e7fff00000000000000000000000000000000000000000000000000000000000000939093169190920190815260010192915050565b634e487b7160e01b5f52604160045260245ffd5b600181811c9082168061049557607f821691505b6020821081036104b357634e487b7160e01b5f52602260045260245ffd5b50919050565b601f82111561050057805f5260205f20601f840160051c810160208510156104de5750805b601f840160051c820191505b818110156104fd575f81556001016104ea565b50505b505050565b81516001600160401b0381111561051e5761051e61046d565b6105328161052c8454610481565b846104b9565b6020601f821160018114610564575f831561054d5750848201515b5f19600385901b1c1916600184901b1784556104fd565b5f84815260208120601f198516915b828110156105935787850151825560209485019460019092019101610573565b50848210156105b057868401515f19600387901b60f8161c191681555b50505050600190811b01905550565b6080516123db6105d45f395f50506123db5ff3fe608060405234801561000f575f5ffd5b5060043610610147575f3560e01c80638afc3bf5116100bf578063c248a4e711610079578063c248a4e71461035e578063d48a66bd14610371578063e30c397814610384578063f2fde38b14610395578063f8ffe3c0146103a8578063fa2aeab4146103cf575f5ffd5b80638afc3bf5146102a25780638da5cb5b146102b55780639a94addf146102c55780639aef1ed9146102f8578063a7a6e4b81461030b578063abed205b1461034b575f5ffd5b8063715018a611610110578063715018a6146101eb57806372581cc0146101f357806379ba50971461020757806379d101fa1461020f5780637ef2721f146102225780638947890a14610249575f5ffd5b806223de291461014b5780630233296b1461016057806332838f6b1461017357806363f17ff914610186578063696ab635146101c0575b5f5ffd5b61015e6101593660046117a9565b6103e2565b005b61015e61016e366004611858565b610539565b61015e6101813660046118b8565b61054d565b6101ad7fdd24c144db91d1bc600aac99393baf8f8c664ba461188f057e37f2c37b962b4581565b6040519081526020015b60405180910390f35b6101d36101ce36600461191a565b61055e565b6040516001600160a01b0390911681526020016101b7565b61015e6105b8565b6101ad5f5160206123865f395f51905f5281565b61015e6105cb565b61015e61021d366004611858565b610611565b6040805180820182526005815264312e342e3160d81b602082015290516101b7919061197a565b60045460055460065460075461026f936001600160a01b03908116938116928116911684565b604080516001600160a01b03958616815293851660208501529184169183019190915290911660608201526080016101b7565b6101d36102b036600461198c565b6106a4565b5f546001600160a01b03166101d3565b6102d86102d3366004611a40565b61079c565b604080516001600160a01b039384168152929091166020830152016101b7565b6002546101d3906001600160a01b031681565b600854600954600a54610326926001600160a01b0316919083565b604080516001600160a01b0390941684526020840192909252908201526060016101b7565b61015e610359366004611858565b6107ce565b6101d361036c366004611a8c565b61085a565b6101d361037f366004611ace565b610a09565b6001546001600160a01b03166101d3565b61015e6103a3366004611858565b610a5b565b6101ad7f0105b97dcdf19d454ebe36f91ed516c2b90ee79f4a46af96a0138c1f5403c1cc81565b61015e6103dd366004611b13565b610acb565b6001600160a01b038616301461040b57604051633903b9f960e11b815260040160405180910390fd5b6008546001600160a01b0316331461043657604051637e5f934960e01b815260040160405180910390fd5b5f80808061044687890189611b98565b93509350935093505f7fdd24c144db91d1bc600aac99393baf8f8c664ba461188f057e37f2c37b962b455f1b85036104aa576104a184848e60085f015f9054906101000a90046001600160a01b031660086001015487610adc565b91506105139050565b7ffefa4682320e62bab141c906e12ae93d46f11860b5b950695fec73e0abfc3e3485016104fa576104a184848e60085f015f9054906101000a90046001600160a01b031660086001015487610d4e565b6040516342868c9b60e01b815260040160405180910390fd5b60085461052a906001600160a01b0316828c611012565b50505050505050505050505050565b610541611069565b61054a81611095565b50565b610555611069565b61054a816110ea565b5f61056b84848685611159565b604080516001600160a01b038084168252871660208201529192507f83a5c31bfee49d254d95e3946d8e8434e5975382fa8b849182db9e251aaaaa26910160405180910390a19392505050565b6105c0611069565b6105c95f6112dc565b565b60015433906001600160a01b031681146106085760405163118cdaa760e01b81526001600160a01b03821660048201526024015b60405180910390fd5b61054a816112dc565b610619611069565b61054a61062d5f546001600160a01b031690565b6040516370a0823160e01b81523060048201526001600160a01b038416906370a0823190602401602060405180830381865afa15801561066f573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906106939190611bee565b6001600160a01b0384169190611012565b5f5f604051806020016106b690611743565b601f1982820381018352601f909101166040818152600254600754600a546001600160a01b038a8116602087015291821684860152606085015260808085018990528351808603909101815260a085019093521691610718919060c40161197a565b60408051601f19818403018152918152602080830180516001600160e01b031663439fab9160e01b179052905161075193929101611c05565b60408051601f198184030181529082905261076f9291602001611c47565b60405160208183030381529060405280519060200120905061079185826112f5565b9150505b9392505050565b6008546009545f9182916107c2918791879133916001600160a01b039091169088610adc565b91509150935093915050565b6107d6611069565b6040516329965a1d60e01b81523060048201525f5160206123865f395f51905f5260248201526001600160a01b0382166044820152731820a4b7618bde71dce8cdc73aab6c95905fad24906329965a1d906064015f604051808303815f87803b158015610841575f5ffd5b505af1158015610853573d5f5f3e3d5ffd5b5050505050565b815160019081018084523060209091028401526006546040515f92839261089a9287929185916001600160a01b0390911690829081908190602401611c9e565b60408051601f19818403018152918152602080830180516001600160e01b031663b63e800d60e01b178152835190208251918201529081018590529091505f9060600160408051601f1981840301815282825280516020909101206005546353e5d93560e01b845291519093505f926001600160f81b0319926001600160a01b031691859183916353e5d9359160048082019289929091908290030181865afa158015610949573d5f5f3e3d5ffd5b505050506040513d5f823e601f3d908101601f191682016040526109709190810190611d15565b60045460405161098d92916001600160a01b031690602001611da9565b604051602081830303815290604052805190602001206040516020016109e594939291906001600160f81b031994909416845260609290921b6001600160601b03191660018401526015830152603582015260550190565b60408051601f19818403018152919052805160209091012093505050505b92915050565b6040516001600160601b0319606086901b166020820152603481018490525f908190605401604051602081830303815290604052805190602001209050610a518185856106a4565b9695505050505050565b610a63611069565b600180546001600160a01b0383166001600160a01b03199091168117909155610a935f546001600160a01b031690565b6001600160a01b03167f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e2270060405160405180910390a350565b610ad3611069565b61054a81611301565b5f5f8280515f03610b00576040516306bfe8d560e11b815260040160405180910390fd5b5f5b8151811015610b5e57306001600160a01b0316828281518110610b2757610b27611dc1565b60200260200101516001600160a01b031603610b56576040516349e27cff60e01b815260040160405180910390fd5b600101610b02565b5083516001018085523060209091028501525f610b7b858b6113a0565b90505f610b8a828b8b8e611159565b6040516001600160a01b038416602482018190525f5160206123865f395f51905f52604483015260648201529091505f9060840160408051601f198184030181529190526020810180516001600160e01b03166329965a1d60e01b1790529050610c0983731820a4b7618bde71dce8cdc73aab6c95905fad24836114be565b6040516001600160a01b03831660248201525f9060440160408051601f198184030181529190526020810180516001600160e01b031663610b592560e01b1790529050610c568482611543565b5f610c618d60601c90565b6040516001600160a01b039091166024820152604481018b905260640160408051601f198184030181529190526020810180516001600160e01b031663095ea7b360e01b1790529050610cb5858c836114be565b5f8960028b51610cc59190611dd5565b81518110610cd557610cd5611dc1565b60209081029190910101516040516001600160a01b0390911660248201523060448201526001606482015260840160408051601f198184030181529190526020810180516001600160e01b031663f8dc5dd960e01b1790529050610d398682611543565b50929d939c50929a5050505050505050505050565b5f5f8280515f03610d72576040516306bfe8d560e11b815260040160405180910390fd5b5f5b8151811015610dd057306001600160a01b0316828281518110610d9957610d99611dc1565b60200260200101516001600160a01b031603610dc8576040516349e27cff60e01b815260040160405180910390fd5b600101610d74565b5083516001018085523060209091028501525f610ded858b6113a0565b90505f610dfc828b8b8e611159565b6040516001600160a01b038416602482018190525f5160206123865f395f51905f52604483015260648201529091505f9060840160408051601f198184030181529190526020810180516001600160e01b03166329965a1d60e01b1790529050610e7b83731820a4b7618bde71dce8cdc73aab6c95905fad24836114be565b6040516001600160a01b03831660248201525f9060440160408051601f198184030181529190526020810180516001600160e01b031663610b592560e01b1790529050610ec88482611543565b5f610ed38d60601c90565b6040516001600160a01b039091166024820152604481018b905260640160408051601f198184030181529190526020810180516001600160e01b031663095ea7b360e01b1790529050610f27858c836114be565b88515f190189526040515f90610f41908b90602401611df4565b60408051601f198184030181529190526020810180516001600160e01b031663110dcee760e01b1790529050610f788686836114be565b5f8a60018c51610f889190611dd5565b81518110610f9857610f98611dc1565b60209081029190910101516040516001600160a01b0390911660248201523060448201526001606482015260840160408051601f198184030181529190526020810180516001600160e01b031663f8dc5dd960e01b1790529050610ffc8782611543565b50939e949d50939b505050505050505050505050565b604080516001600160a01b038416602482015260448082018490528251808303909101815260649091019091526020810180516001600160e01b031663a9059cbb60e01b1790526110649084906115c2565b505050565b5f546001600160a01b031633146105c95760405163118cdaa760e01b81523360048201526024016105ff565b600280546001600160a01b0319166001600160a01b0383169081179091556040519081527fdd60725a88508fe2dcb769bd824280a2a01356198c795515d175abc4bc40b74e906020015b60405180910390a150565b8051600880546001600160a01b0319166001600160a01b0390921691821790556020808301516009819055604080850151600a8190558151948552928401919091528201527f54cfcf4bdb6f20632ba544cd684130fc9db4dc2fe6360926d6b7866297f0315e906060016110df565b600754600a54604080516001600160a01b038089166020830152909316908301526060820152608081018490525f90819060a00160408051601f19818403018152908290526111aa9160240161197a565b60408051601f19818403018152918152602080830180516001600160e01b031663439fab9160e01b17905290519192505f9161120291879187910160609290921b6001600160601b0319168252601482015260340190565b6040516020818303038152906040528051906020012090506112935f826040518060200161122f90611743565b601f1982820381018352601f909101166040819052600254611261916001600160a01b03909116908890602001611c05565b60408051601f198184030181529082905261127f9291602001611c47565b60405160208183030381529060405261162e565b6040516001600160a01b03821681529093507ff966ce717349a940e403b8faae71fdaf573d8b9847deea16fca3d870cf6c292d9060200160405180910390a15050949350505050565b600180546001600160a01b031916905561054a816116c2565b5f610795838330611711565b8051600480546001600160a01b03199081166001600160a01b03938416908117909255602080850151600580548416918616918217905560408087015160068054861691881691821790556060808901516007805490971698169788179095558151958652928501919091528301528101919091527f87eb507b2b42eb659807d7a1f63c89b8e22c674689603eac07a3713f06fec9c3906080016110df565b6006546040515f9182916113cf91869160019185916001600160a01b0390911690829081908190602401611c9e565b60408051601f198184030181529181526020820180516001600160e01b031663b63e800d60e01b179052600554600480549251631688f0b960e01b81529394505f936001600160a01b0392831693631688f0b9936114349391169187918a9101611e06565b6020604051808303815f875af1158015611450573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906114749190611e39565b6040516001600160a01b03821681529093508391507f8231d169f416b666ae7fa43faa24a18899738075a53f32c97617d173b189e3869060200160405180910390a1505092915050565b60405163353b090160e11b81526001600160a01b03841690636a761202906114fd9085905f908690829081908190819081903390600390600401611ef2565b6020604051808303815f875af1158015611519573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061153d9190611f97565b50505050565b60405163353b090160e11b81526001600160a01b03831690636a761202906115829085905f908690829081908190819081903390600390600401611ef2565b6020604051808303815f875af115801561159e573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906110649190611f97565b5f5f60205f8451602086015f885af1806115e1576040513d5f823e3d81fd5b50505f513d915081156115f8578060011415611605565b6001600160a01b0384163b155b1561153d57604051635274afe760e01b81526001600160a01b03851660048201526024016105ff565b5f834710156116595760405163cf47918160e01b8152476004820152602481018590526044016105ff565b81515f0361167a57604051631328927760e21b815260040160405180910390fd5b8282516020840186f590503d15198115161561169b576040513d5f823e3d81fd5b6001600160a01b0381166107955760405163b06ebf3d60e01b815260040160405180910390fd5b5f80546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b5f604051836040820152846020820152828152600b8101905060ff8153605590206001600160a01b0316949350505050565b6103cf80611fb783390190565b6001600160a01b038116811461054a575f5ffd5b5f5f83601f840112611774575f5ffd5b50813567ffffffffffffffff81111561178b575f5ffd5b6020830191508360208285010111156117a2575f5ffd5b9250929050565b5f5f5f5f5f5f5f5f60c0898b0312156117c0575f5ffd5b88356117cb81611750565b975060208901356117db81611750565b965060408901356117eb81611750565b955060608901359450608089013567ffffffffffffffff81111561180d575f5ffd5b6118198b828c01611764565b90955093505060a089013567ffffffffffffffff811115611838575f5ffd5b6118448b828c01611764565b999c989b5096995094979396929594505050565b5f60208284031215611868575f5ffd5b813561079581611750565b634e487b7160e01b5f52604160045260245ffd5b604051601f8201601f1916810167ffffffffffffffff811182821017156118b0576118b0611873565b604052919050565b5f60608284031280156118c9575f5ffd5b506040516060810167ffffffffffffffff811182821017156118ed576118ed611873565b60405282356118fb81611750565b8152602083810135908201526040928301359281019290925250919050565b5f5f5f6060848603121561192c575f5ffd5b833561193781611750565b95602085013595506040909401359392505050565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b602081525f610795602083018461194c565b5f5f5f6060848603121561199e575f5ffd5b8335925060208401356119b081611750565b929592945050506040919091013590565b5f82601f8301126119d0575f5ffd5b813567ffffffffffffffff8111156119ea576119ea611873565b8060051b6119fa60208201611887565b91825260208185018101929081019086841115611a15575f5ffd5b6020860192505b83831015610a51578235611a2f81611750565b825260209283019290910190611a1c565b5f5f5f60608486031215611a52575f5ffd5b8335925060208401359150604084013567ffffffffffffffff811115611a76575f5ffd5b611a82868287016119c1565b9150509250925092565b5f5f60408385031215611a9d575f5ffd5b823567ffffffffffffffff811115611ab3575f5ffd5b611abf858286016119c1565b95602094909401359450505050565b5f5f5f5f60808587031215611ae1575f5ffd5b8435611aec81611750565b9350602085013592506040850135611b0381611750565b9396929550929360600135925050565b5f6080828403128015611b24575f5ffd5b506040516080810167ffffffffffffffff81118282101715611b4857611b48611873565b6040528235611b5681611750565b81526020830135611b6681611750565b60208201526040830135611b7981611750565b60408201526060830135611b8c81611750565b60608201529392505050565b5f5f5f5f60808587031215611bab575f5ffd5b843593506020850135925060408501359150606085013567ffffffffffffffff811115611bd6575f5ffd5b611be2878288016119c1565b91505092959194509250565b5f60208284031215611bfe575f5ffd5b5051919050565b6001600160a01b03831681526040602082018190525f90611c289083018461194c565b949350505050565b5f81518060208401855e5f93019283525090919050565b5f611c28611c558386611c30565b84611c30565b5f8151808452602084019350602083015f5b82811015611c945781516001600160a01b0316865260209586019590910190600101611c6d565b5093949350505050565b61010081525f611cb261010083018a611c5b565b60ff9889166020848101919091526001600160a01b039889166040808601919091528483036060860152600183525f91830191909152968816608084015294871660a0830152509190951660c08201529390921660e09093019290925201919050565b5f60208284031215611d25575f5ffd5b815167ffffffffffffffff811115611d3b575f5ffd5b8201601f81018413611d4b575f5ffd5b805167ffffffffffffffff811115611d6557611d65611873565b611d78601f8201601f1916602001611887565b818152856020838501011115611d8c575f5ffd5b8160208401602083015e5f91810160200191909152949350505050565b5f611db48285611c30565b9283525050602001919050565b634e487b7160e01b5f52603260045260245ffd5b81810381811115610a0357634e487b7160e01b5f52601160045260245ffd5b602081525f6107956020830184611c5b565b6001600160a01b03841681526060602082018190525f90611e299083018561194c565b9050826040830152949350505050565b5f60208284031215611e49575f5ffd5b815161079581611750565b80545f90600181811c90821680611e6c57607f821691505b602082108103611e8a57634e487b7160e01b5f52602260045260245ffd5b81865260208601818015611ea55760018114611ebb57611ee7565b60ff198516825283151560051b82019550611ee7565b5f878152602090205f5b85811015611ee157815484820152600190910190602001611ec5565b83019650505b505050505092915050565b60018060a01b038b16815289602082015261014060408201525f611f1a61014083018b61194c565b60028a10611f3657634e487b7160e01b5f52602160045260245ffd5b8960608401528860808401528760a08401528660c0840152611f6360e08401876001600160a01b03169052565b6001600160a01b038516610100840152828103610120840152611f868185611e54565b9d9c50505050505050505050505050565b5f60208284031215611fa7575f5ffd5b81518015158114610795575f5ffdfe60806040526040516103cf3803806103cf8339810160408190526100229161023b565b61002c8282610033565b5050610320565b61003c82610091565b6040516001600160a01b038316907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b905f90a280511561008557610080828261010c565b505050565b61008d61017f565b5050565b806001600160a01b03163b5f036100cb57604051634c9c8ce360e01b81526001600160a01b03821660048201526024015b60405180910390fd5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc80546001600160a01b0319166001600160a01b0392909216919091179055565b60605f5f846001600160a01b031684604051610128919061030a565b5f60405180830381855af49150503d805f8114610160576040519150601f19603f3d011682016040523d82523d5f602084013e610165565b606091505b5090925090506101768583836101a0565b95945050505050565b341561019e5760405163b398979f60e01b815260040160405180910390fd5b565b6060826101b5576101b0826101ff565b6101f8565b81511580156101cc57506001600160a01b0384163b155b156101f557604051639996b31560e01b81526001600160a01b03851660048201526024016100c2565b50805b9392505050565b80511561020e57805160208201fd5b60405163d6bda27560e01b815260040160405180910390fd5b634e487b7160e01b5f52604160045260245ffd5b5f5f6040838503121561024c575f5ffd5b82516001600160a01b0381168114610262575f5ffd5b60208401519092506001600160401b0381111561027d575f5ffd5b8301601f8101851361028d575f5ffd5b80516001600160401b038111156102a6576102a6610227565b604051601f8201601f19908116603f011681016001600160401b03811182821017156102d4576102d4610227565b6040528181528282016020018710156102eb575f5ffd5b8160208401602083015e5f602083830101528093505050509250929050565b5f82518060208501845e5f920191825250919050565b60a38061032c5f395ff3fe6080604052600a600c565b005b60186014601a565b6050565b565b5f604b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc546001600160a01b031690565b905090565b365f5f375f5f365f845af43d5f5f3e8080156069573d5ff35b3d5ffdfea2646970667358221220597735e32a6d7bea6c0b3f4adfb8a137d718bd2a0c4a1ee16155b30054d242b664736f6c634300081e0033b281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53ba2646970667358221220ce357d6fcfd096b7e84dfe1fe62173f265b1ed15069839dbab03dad5b9988bfd64736f6c634300081e0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"s)\xFC\xB4;FS\x1B\xCA\0=\xDC\x8F\xCBg\xFF\xE9\x19\0\xC7b`\xA0\x81\x90RsN\x1D\xCFz\xD4\xE4`\xCF\xD3\x07\x91\xCC\xC4\xF9\xC8\xA4\xF8 \xECg`\xC0\x81\x90Rs>\xFC\xBB\x83\xA4\xA7\xAF\xCBOh\xD5\x01\xE2\xC2 :8\xBEw\xF4`\xE0\x81\x90Rs8\x86\x9B\xF6ja\xCFk\xDB\x99jj\xE4\rXS\xFDC\xB5&a\x01\0\x81\x90R`\x04\x80T`\x01`\x01`\xA0\x1B\x03\x19\x90\x81\x16\x90\x95\x17\x90U`\x05\x80T\x85\x16\x90\x93\x17\x90\x92U`\x06\x80T\x84\x16\x90\x91\x17\x90U`\x07\x80T\x83\x16\x90\x91\x17\x90Ua\x01\x80`@Rs\xD4\xFD\xECD\xDB\x9DD\xB8\xF2\xB6\xD5)b\x0F\x9C\x0Cpf\xA2\xC1a\x01 \x81\x90Rh65\xC9\xAD\xC5\xDE\xA0\0\0a\x01@\x81\x90R_a\x01`\x81\x90R`\x08\x80T\x90\x94\x16\x90\x92\x17\x90\x92U`\t\x91\x90\x91U`\nU4\x80\x15a\0\xF8W__\xFD[P`@Qa)\xAF8\x03\x80a)\xAF\x839\x81\x01`@\x81\x90Ra\x01\x17\x91a\x03\xEEV[\x80`\x01`\x01`\xA0\x1B\x03\x81\x16a\x01EW`@Qc\x1EO\xBD\xF7`\xE0\x1B\x81R_`\x04\x82\x01R`$\x01`@Q\x80\x91\x03\x90\xFD[a\x01N\x81a\x03\x14V[P0`\x80\x81\x90R`@\x80Q` \x81\x01\x92\x90\x92R_\x90\x82\x01R``\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90Ra\x01\x8C\x91`\x01`\xF8\x1B\x90` \x01a\x04.V[`@Q` \x81\x83\x03\x03\x81R\x90`@R`\x03\x90\x81a\x01\xA9\x91\x90a\x05\x05V[Pa\x01\xB3\x83a\x030V[`@Qc)\x96Z\x1D`\xE0\x1B\x81R0`\x04\x82\x01\x81\x90R\x7F\xB2\x81\xFC\x8C\x12\x95M\"TM\xB4]\xE3\x15\x9A9'(\x95\xB1i\xA8R\xB3\x14\xF9\xCCv.D\xC5;`$\x83\x01R`D\x82\x01Rs\x18 \xA4\xB7a\x8B\xDEq\xDC\xE8\xCD\xC7:\xABl\x95\x90_\xAD$\x90c)\x96Z\x1D\x90`d\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x02)W__\xFD[PZ\xF1\x15\x80\x15a\x02;W=__>=_\xFD[PPPP`\x01`\x01``\x1B\x03\x19``\x83\x81\x1B\x91\x90\x91\x16k\x01\0\x03\0\0\0\0\0\0\0\0\0\x17`\nU`@\x80Q`\x04T`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x82R`\x05T\x81\x16` \x83\x01R`\x06T\x81\x16\x82\x84\x01R`\x07T\x16\x92\x81\x01\x92\x90\x92RQ\x7F\x87\xEBP{+B\xEBe\x98\x07\xD7\xA1\xF6<\x89\xB8\xE2,gF\x89`>\xAC\x07\xA3q?\x06\xFE\xC9\xC3\x91\x81\x90\x03`\x80\x01\x90\xA1`@\x80Q`\x08T`\x01`\x01`\xA0\x1B\x03\x16\x81R`\tT` \x82\x01R`\nT\x81\x83\x01R\x90Q\x7FT\xCF\xCFK\xDBo c+\xA5D\xCDhA0\xFC\x9D\xB4\xDC/\xE66\t&\xD6\xB7\x86b\x97\xF01^\x91\x81\x90\x03``\x01\x90\xA1PPPa\x05\xBFV[`\x01\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16\x90Ua\x03-\x81a\x03\x84V[PV[`\x02\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x83\x16\x90\x81\x17\x90\x91U`@Q\x90\x81R\x7F\xDD`rZ\x88P\x8F\xE2\xDC\xB7i\xBD\x82B\x80\xA2\xA0\x13V\x19\x8CyU\x15\xD1u\xAB\xC4\xBC@\xB7N\x90` \x01`@Q\x80\x91\x03\x90\xA1PV[_\x80T`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\x01`\x01`\xA0\x1B\x03\x19\x83\x16\x81\x17\x84U`@Q\x91\x90\x92\x16\x92\x83\x91\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0\x91\x90\xA3PPV[\x80Q`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x03\xE9W__\xFD[\x91\x90PV[___``\x84\x86\x03\x12\x15a\x04\0W__\xFD[a\x04\t\x84a\x03\xD3V[\x92Pa\x04\x17` \x85\x01a\x03\xD3V[\x91Pa\x04%`@\x85\x01a\x03\xD3V[\x90P\x92P\x92P\x92V[_\x83Q\x80` \x86\x01\x84^\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x93\x90\x93\x16\x91\x90\x92\x01\x90\x81R`\x01\x01\x92\x91PPV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`\x01\x81\x81\x1C\x90\x82\x16\x80a\x04\x95W`\x7F\x82\x16\x91P[` \x82\x10\x81\x03a\x04\xB3WcNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[P\x91\x90PV[`\x1F\x82\x11\x15a\x05\0W\x80_R` _ `\x1F\x84\x01`\x05\x1C\x81\x01` \x85\x10\x15a\x04\xDEWP\x80[`\x1F\x84\x01`\x05\x1C\x82\x01\x91P[\x81\x81\x10\x15a\x04\xFDW_\x81U`\x01\x01a\x04\xEAV[PP[PPPV[\x81Q`\x01`\x01`@\x1B\x03\x81\x11\x15a\x05\x1EWa\x05\x1Ea\x04mV[a\x052\x81a\x05,\x84Ta\x04\x81V[\x84a\x04\xB9V[` `\x1F\x82\x11`\x01\x81\x14a\x05dW_\x83\x15a\x05MWP\x84\x82\x01Q[_\x19`\x03\x85\x90\x1B\x1C\x19\x16`\x01\x84\x90\x1B\x17\x84Ua\x04\xFDV[_\x84\x81R` \x81 `\x1F\x19\x85\x16\x91[\x82\x81\x10\x15a\x05\x93W\x87\x85\x01Q\x82U` \x94\x85\x01\x94`\x01\x90\x92\x01\x91\x01a\x05sV[P\x84\x82\x10\x15a\x05\xB0W\x86\x84\x01Q_\x19`\x03\x87\x90\x1B`\xF8\x16\x1C\x19\x16\x81U[PPPP`\x01\x90\x81\x1B\x01\x90UPV[`\x80Qa#\xDBa\x05\xD4_9_PPa#\xDB_\xF3\xFE`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\x01GW_5`\xE0\x1C\x80c\x8A\xFC;\xF5\x11a\0\xBFW\x80c\xC2H\xA4\xE7\x11a\0yW\x80c\xC2H\xA4\xE7\x14a\x03^W\x80c\xD4\x8Af\xBD\x14a\x03qW\x80c\xE3\x0C9x\x14a\x03\x84W\x80c\xF2\xFD\xE3\x8B\x14a\x03\x95W\x80c\xF8\xFF\xE3\xC0\x14a\x03\xA8W\x80c\xFA*\xEA\xB4\x14a\x03\xCFW__\xFD[\x80c\x8A\xFC;\xF5\x14a\x02\xA2W\x80c\x8D\xA5\xCB[\x14a\x02\xB5W\x80c\x9A\x94\xAD\xDF\x14a\x02\xC5W\x80c\x9A\xEF\x1E\xD9\x14a\x02\xF8W\x80c\xA7\xA6\xE4\xB8\x14a\x03\x0BW\x80c\xAB\xED [\x14a\x03KW__\xFD[\x80cqP\x18\xA6\x11a\x01\x10W\x80cqP\x18\xA6\x14a\x01\xEBW\x80crX\x1C\xC0\x14a\x01\xF3W\x80cy\xBAP\x97\x14a\x02\x07W\x80cy\xD1\x01\xFA\x14a\x02\x0FW\x80c~\xF2r\x1F\x14a\x02\"W\x80c\x89G\x89\n\x14a\x02IW__\xFD[\x80b#\xDE)\x14a\x01KW\x80c\x023)k\x14a\x01`W\x80c2\x83\x8Fk\x14a\x01sW\x80cc\xF1\x7F\xF9\x14a\x01\x86W\x80cij\xB65\x14a\x01\xC0W[__\xFD[a\x01^a\x01Y6`\x04a\x17\xA9V[a\x03\xE2V[\0[a\x01^a\x01n6`\x04a\x18XV[a\x059V[a\x01^a\x01\x816`\x04a\x18\xB8V[a\x05MV[a\x01\xAD\x7F\xDD$\xC1D\xDB\x91\xD1\xBC`\n\xAC\x999;\xAF\x8F\x8CfK\xA4a\x18\x8F\x05~7\xF2\xC3{\x96+E\x81V[`@Q\x90\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\x01\xD3a\x01\xCE6`\x04a\x19\x1AV[a\x05^V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\x01\xB7V[a\x01^a\x05\xB8V[a\x01\xAD_Q` a#\x86_9_Q\x90_R\x81V[a\x01^a\x05\xCBV[a\x01^a\x02\x1D6`\x04a\x18XV[a\x06\x11V[`@\x80Q\x80\x82\x01\x82R`\x05\x81Rd1.4.1`\xD8\x1B` \x82\x01R\x90Qa\x01\xB7\x91\x90a\x19zV[`\x04T`\x05T`\x06T`\x07Ta\x02o\x93`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x93\x81\x16\x92\x81\x16\x91\x16\x84V[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x95\x86\x16\x81R\x93\x85\x16` \x85\x01R\x91\x84\x16\x91\x83\x01\x91\x90\x91R\x90\x91\x16``\x82\x01R`\x80\x01a\x01\xB7V[a\x01\xD3a\x02\xB06`\x04a\x19\x8CV[a\x06\xA4V[_T`\x01`\x01`\xA0\x1B\x03\x16a\x01\xD3V[a\x02\xD8a\x02\xD36`\x04a\x1A@V[a\x07\x9CV[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x93\x84\x16\x81R\x92\x90\x91\x16` \x83\x01R\x01a\x01\xB7V[`\x02Ta\x01\xD3\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[`\x08T`\tT`\nTa\x03&\x92`\x01`\x01`\xA0\x1B\x03\x16\x91\x90\x83V[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x90\x94\x16\x84R` \x84\x01\x92\x90\x92R\x90\x82\x01R``\x01a\x01\xB7V[a\x01^a\x03Y6`\x04a\x18XV[a\x07\xCEV[a\x01\xD3a\x03l6`\x04a\x1A\x8CV[a\x08ZV[a\x01\xD3a\x03\x7F6`\x04a\x1A\xCEV[a\n\tV[`\x01T`\x01`\x01`\xA0\x1B\x03\x16a\x01\xD3V[a\x01^a\x03\xA36`\x04a\x18XV[a\n[V[a\x01\xAD\x7F\x01\x05\xB9}\xCD\xF1\x9DEN\xBE6\xF9\x1E\xD5\x16\xC2\xB9\x0E\xE7\x9FJF\xAF\x96\xA0\x13\x8C\x1FT\x03\xC1\xCC\x81V[a\x01^a\x03\xDD6`\x04a\x1B\x13V[a\n\xCBV[`\x01`\x01`\xA0\x1B\x03\x86\x160\x14a\x04\x0BW`@Qc9\x03\xB9\xF9`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x08T`\x01`\x01`\xA0\x1B\x03\x163\x14a\x046W`@Qc~_\x93I`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80\x80\x80a\x04F\x87\x89\x01\x89a\x1B\x98V[\x93P\x93P\x93P\x93P_\x7F\xDD$\xC1D\xDB\x91\xD1\xBC`\n\xAC\x999;\xAF\x8F\x8CfK\xA4a\x18\x8F\x05~7\xF2\xC3{\x96+E_\x1B\x85\x03a\x04\xAAWa\x04\xA1\x84\x84\x8E`\x08_\x01_\x90T\x90a\x01\0\n\x90\x04`\x01`\x01`\xA0\x1B\x03\x16`\x08`\x01\x01T\x87a\n\xDCV[\x91Pa\x05\x13\x90PV[\x7F\xFE\xFAF\x822\x0Eb\xBA\xB1A\xC9\x06\xE1*\xE9=F\xF1\x18`\xB5\xB9Pi_\xECs\xE0\xAB\xFC>4\x85\x01a\x04\xFAWa\x04\xA1\x84\x84\x8E`\x08_\x01_\x90T\x90a\x01\0\n\x90\x04`\x01`\x01`\xA0\x1B\x03\x16`\x08`\x01\x01T\x87a\rNV[`@QcB\x86\x8C\x9B`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x08Ta\x05*\x90`\x01`\x01`\xA0\x1B\x03\x16\x82\x8Ca\x10\x12V[PPPPPPPPPPPPPV[a\x05Aa\x10iV[a\x05J\x81a\x10\x95V[PV[a\x05Ua\x10iV[a\x05J\x81a\x10\xEAV[_a\x05k\x84\x84\x86\x85a\x11YV[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x80\x84\x16\x82R\x87\x16` \x82\x01R\x91\x92P\x7F\x83\xA5\xC3\x1B\xFE\xE4\x9D%M\x95\xE3\x94m\x8E\x844\xE5\x97S\x82\xFA\x8B\x84\x91\x82\xDB\x9E%\x1A\xAA\xAA&\x91\x01`@Q\x80\x91\x03\x90\xA1\x93\x92PPPV[a\x05\xC0a\x10iV[a\x05\xC9_a\x12\xDCV[V[`\x01T3\x90`\x01`\x01`\xA0\x1B\x03\x16\x81\x14a\x06\x08W`@Qc\x11\x8C\xDA\xA7`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x82\x16`\x04\x82\x01R`$\x01[`@Q\x80\x91\x03\x90\xFD[a\x05J\x81a\x12\xDCV[a\x06\x19a\x10iV[a\x05Ja\x06-_T`\x01`\x01`\xA0\x1B\x03\x16\x90V[`@Qcp\xA0\x821`\xE0\x1B\x81R0`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x84\x16\x90cp\xA0\x821\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x06oW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x06\x93\x91\x90a\x1B\xEEV[`\x01`\x01`\xA0\x1B\x03\x84\x16\x91\x90a\x10\x12V[__`@Q\x80` \x01a\x06\xB6\x90a\x17CV[`\x1F\x19\x82\x82\x03\x81\x01\x83R`\x1F\x90\x91\x01\x16`@\x81\x81R`\x02T`\x07T`\nT`\x01`\x01`\xA0\x1B\x03\x8A\x81\x16` \x87\x01R\x91\x82\x16\x84\x86\x01R``\x85\x01R`\x80\x80\x85\x01\x89\x90R\x83Q\x80\x86\x03\x90\x91\x01\x81R`\xA0\x85\x01\x90\x93R\x16\x91a\x07\x18\x91\x90`\xC4\x01a\x19zV[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x81R` \x80\x83\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16cC\x9F\xAB\x91`\xE0\x1B\x17\x90R\x90Qa\x07Q\x93\x92\x91\x01a\x1C\x05V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90Ra\x07o\x92\x91` \x01a\x1CGV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90Pa\x07\x91\x85\x82a\x12\xF5V[\x91PP[\x93\x92PPPV[`\x08T`\tT_\x91\x82\x91a\x07\xC2\x91\x87\x91\x87\x913\x91`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90\x88a\n\xDCV[\x91P\x91P\x93P\x93\x91PPV[a\x07\xD6a\x10iV[`@Qc)\x96Z\x1D`\xE0\x1B\x81R0`\x04\x82\x01R_Q` a#\x86_9_Q\x90_R`$\x82\x01R`\x01`\x01`\xA0\x1B\x03\x82\x16`D\x82\x01Rs\x18 \xA4\xB7a\x8B\xDEq\xDC\xE8\xCD\xC7:\xABl\x95\x90_\xAD$\x90c)\x96Z\x1D\x90`d\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x08AW__\xFD[PZ\xF1\x15\x80\x15a\x08SW=__>=_\xFD[PPPPPV[\x81Q`\x01\x90\x81\x01\x80\x84R0` \x90\x91\x02\x84\x01R`\x06T`@Q_\x92\x83\x92a\x08\x9A\x92\x87\x92\x91\x85\x91`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90\x82\x90\x81\x90\x81\x90`$\x01a\x1C\x9EV[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x81R` \x80\x83\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16c\xB6>\x80\r`\xE0\x1B\x17\x81R\x83Q\x90 \x82Q\x91\x82\x01R\x90\x81\x01\x85\x90R\x90\x91P_\x90``\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x82\x82R\x80Q` \x90\x91\x01 `\x05TcS\xE5\xD95`\xE0\x1B\x84R\x91Q\x90\x93P_\x92`\x01`\x01`\xF8\x1B\x03\x19\x92`\x01`\x01`\xA0\x1B\x03\x16\x91\x85\x91\x83\x91cS\xE5\xD95\x91`\x04\x80\x82\x01\x92\x89\x92\x90\x91\x90\x82\x90\x03\x01\x81\x86Z\xFA\x15\x80\x15a\tIW=__>=_\xFD[PPPP`@Q=_\x82>`\x1F=\x90\x81\x01`\x1F\x19\x16\x82\x01`@Ra\tp\x91\x90\x81\x01\x90a\x1D\x15V[`\x04T`@Qa\t\x8D\x92\x91`\x01`\x01`\xA0\x1B\x03\x16\x90` \x01a\x1D\xA9V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 `@Q` \x01a\t\xE5\x94\x93\x92\x91\x90`\x01`\x01`\xF8\x1B\x03\x19\x94\x90\x94\x16\x84R``\x92\x90\x92\x1B`\x01`\x01``\x1B\x03\x19\x16`\x01\x84\x01R`\x15\x83\x01R`5\x82\x01R`U\x01\x90V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R\x80Q` \x90\x91\x01 \x93PPPP[\x92\x91PPV[`@Q`\x01`\x01``\x1B\x03\x19``\x86\x90\x1B\x16` \x82\x01R`4\x81\x01\x84\x90R_\x90\x81\x90`T\x01`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90Pa\nQ\x81\x85\x85a\x06\xA4V[\x96\x95PPPPPPV[a\nca\x10iV[`\x01\x80T`\x01`\x01`\xA0\x1B\x03\x83\x16`\x01`\x01`\xA0\x1B\x03\x19\x90\x91\x16\x81\x17\x90\x91Ua\n\x93_T`\x01`\x01`\xA0\x1B\x03\x16\x90V[`\x01`\x01`\xA0\x1B\x03\x16\x7F8\xD1k\x8C\xAC\"\xD9\x9F\xC7\xC1$\xB9\xCD\r\xE2\xD3\xFA\x1F\xAE\xF4 \xBF\xE7\x91\xD8\xC3b\xD7e\xE2'\0`@Q`@Q\x80\x91\x03\x90\xA3PV[a\n\xD3a\x10iV[a\x05J\x81a\x13\x01V[__\x82\x80Q_\x03a\x0B\0W`@Qc\x06\xBF\xE8\xD5`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_[\x81Q\x81\x10\x15a\x0B^W0`\x01`\x01`\xA0\x1B\x03\x16\x82\x82\x81Q\x81\x10a\x0B'Wa\x0B'a\x1D\xC1V[` \x02` \x01\x01Q`\x01`\x01`\xA0\x1B\x03\x16\x03a\x0BVW`@QcI\xE2|\xFF`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x01\x01a\x0B\x02V[P\x83Q`\x01\x01\x80\x85R0` \x90\x91\x02\x85\x01R_a\x0B{\x85\x8Ba\x13\xA0V[\x90P_a\x0B\x8A\x82\x8B\x8B\x8Ea\x11YV[`@Q`\x01`\x01`\xA0\x1B\x03\x84\x16`$\x82\x01\x81\x90R_Q` a#\x86_9_Q\x90_R`D\x83\x01R`d\x82\x01R\x90\x91P_\x90`\x84\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R` \x81\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16c)\x96Z\x1D`\xE0\x1B\x17\x90R\x90Pa\x0C\t\x83s\x18 \xA4\xB7a\x8B\xDEq\xDC\xE8\xCD\xC7:\xABl\x95\x90_\xAD$\x83a\x14\xBEV[`@Q`\x01`\x01`\xA0\x1B\x03\x83\x16`$\x82\x01R_\x90`D\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R` \x81\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16ca\x0BY%`\xE0\x1B\x17\x90R\x90Pa\x0CV\x84\x82a\x15CV[_a\x0Ca\x8D``\x1C\x90V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16`$\x82\x01R`D\x81\x01\x8B\x90R`d\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R` \x81\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16c\t^\xA7\xB3`\xE0\x1B\x17\x90R\x90Pa\x0C\xB5\x85\x8C\x83a\x14\xBEV[_\x89`\x02\x8BQa\x0C\xC5\x91\x90a\x1D\xD5V[\x81Q\x81\x10a\x0C\xD5Wa\x0C\xD5a\x1D\xC1V[` \x90\x81\x02\x91\x90\x91\x01\x01Q`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16`$\x82\x01R0`D\x82\x01R`\x01`d\x82\x01R`\x84\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R` \x81\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16c\xF8\xDC]\xD9`\xE0\x1B\x17\x90R\x90Pa\r9\x86\x82a\x15CV[P\x92\x9D\x93\x9CP\x92\x9APPPPPPPPPPPV[__\x82\x80Q_\x03a\rrW`@Qc\x06\xBF\xE8\xD5`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_[\x81Q\x81\x10\x15a\r\xD0W0`\x01`\x01`\xA0\x1B\x03\x16\x82\x82\x81Q\x81\x10a\r\x99Wa\r\x99a\x1D\xC1V[` \x02` \x01\x01Q`\x01`\x01`\xA0\x1B\x03\x16\x03a\r\xC8W`@QcI\xE2|\xFF`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x01\x01a\rtV[P\x83Q`\x01\x01\x80\x85R0` \x90\x91\x02\x85\x01R_a\r\xED\x85\x8Ba\x13\xA0V[\x90P_a\r\xFC\x82\x8B\x8B\x8Ea\x11YV[`@Q`\x01`\x01`\xA0\x1B\x03\x84\x16`$\x82\x01\x81\x90R_Q` a#\x86_9_Q\x90_R`D\x83\x01R`d\x82\x01R\x90\x91P_\x90`\x84\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R` \x81\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16c)\x96Z\x1D`\xE0\x1B\x17\x90R\x90Pa\x0E{\x83s\x18 \xA4\xB7a\x8B\xDEq\xDC\xE8\xCD\xC7:\xABl\x95\x90_\xAD$\x83a\x14\xBEV[`@Q`\x01`\x01`\xA0\x1B\x03\x83\x16`$\x82\x01R_\x90`D\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R` \x81\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16ca\x0BY%`\xE0\x1B\x17\x90R\x90Pa\x0E\xC8\x84\x82a\x15CV[_a\x0E\xD3\x8D``\x1C\x90V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16`$\x82\x01R`D\x81\x01\x8B\x90R`d\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R` \x81\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16c\t^\xA7\xB3`\xE0\x1B\x17\x90R\x90Pa\x0F'\x85\x8C\x83a\x14\xBEV[\x88Q_\x19\x01\x89R`@Q_\x90a\x0FA\x90\x8B\x90`$\x01a\x1D\xF4V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R` \x81\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16c\x11\r\xCE\xE7`\xE0\x1B\x17\x90R\x90Pa\x0Fx\x86\x86\x83a\x14\xBEV[_\x8A`\x01\x8CQa\x0F\x88\x91\x90a\x1D\xD5V[\x81Q\x81\x10a\x0F\x98Wa\x0F\x98a\x1D\xC1V[` \x90\x81\x02\x91\x90\x91\x01\x01Q`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16`$\x82\x01R0`D\x82\x01R`\x01`d\x82\x01R`\x84\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R` \x81\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16c\xF8\xDC]\xD9`\xE0\x1B\x17\x90R\x90Pa\x0F\xFC\x87\x82a\x15CV[P\x93\x9E\x94\x9DP\x93\x9BPPPPPPPPPPPPV[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x84\x16`$\x82\x01R`D\x80\x82\x01\x84\x90R\x82Q\x80\x83\x03\x90\x91\x01\x81R`d\x90\x91\x01\x90\x91R` \x81\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16c\xA9\x05\x9C\xBB`\xE0\x1B\x17\x90Ra\x10d\x90\x84\x90a\x15\xC2V[PPPV[_T`\x01`\x01`\xA0\x1B\x03\x163\x14a\x05\xC9W`@Qc\x11\x8C\xDA\xA7`\xE0\x1B\x81R3`\x04\x82\x01R`$\x01a\x05\xFFV[`\x02\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x83\x16\x90\x81\x17\x90\x91U`@Q\x90\x81R\x7F\xDD`rZ\x88P\x8F\xE2\xDC\xB7i\xBD\x82B\x80\xA2\xA0\x13V\x19\x8CyU\x15\xD1u\xAB\xC4\xBC@\xB7N\x90` \x01[`@Q\x80\x91\x03\x90\xA1PV[\x80Q`\x08\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x90\x92\x16\x91\x82\x17\x90U` \x80\x83\x01Q`\t\x81\x90U`@\x80\x85\x01Q`\n\x81\x90U\x81Q\x94\x85R\x92\x84\x01\x91\x90\x91R\x82\x01R\x7FT\xCF\xCFK\xDBo c+\xA5D\xCDhA0\xFC\x9D\xB4\xDC/\xE66\t&\xD6\xB7\x86b\x97\xF01^\x90``\x01a\x10\xDFV[`\x07T`\nT`@\x80Q`\x01`\x01`\xA0\x1B\x03\x80\x89\x16` \x83\x01R\x90\x93\x16\x90\x83\x01R``\x82\x01R`\x80\x81\x01\x84\x90R_\x90\x81\x90`\xA0\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90Ra\x11\xAA\x91`$\x01a\x19zV[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x81R` \x80\x83\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16cC\x9F\xAB\x91`\xE0\x1B\x17\x90R\x90Q\x91\x92P_\x91a\x12\x02\x91\x87\x91\x87\x91\x01``\x92\x90\x92\x1B`\x01`\x01``\x1B\x03\x19\x16\x82R`\x14\x82\x01R`4\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90Pa\x12\x93_\x82`@Q\x80` \x01a\x12/\x90a\x17CV[`\x1F\x19\x82\x82\x03\x81\x01\x83R`\x1F\x90\x91\x01\x16`@\x81\x90R`\x02Ta\x12a\x91`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90\x88\x90` \x01a\x1C\x05V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90Ra\x12\x7F\x92\x91` \x01a\x1CGV[`@Q` \x81\x83\x03\x03\x81R\x90`@Ra\x16.V[`@Q`\x01`\x01`\xA0\x1B\x03\x82\x16\x81R\x90\x93P\x7F\xF9f\xCEqsI\xA9@\xE4\x03\xB8\xFA\xAEq\xFD\xAFW=\x8B\x98G\xDE\xEA\x16\xFC\xA3\xD8p\xCFl)-\x90` \x01`@Q\x80\x91\x03\x90\xA1PP\x94\x93PPPPV[`\x01\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16\x90Ua\x05J\x81a\x16\xC2V[_a\x07\x95\x83\x830a\x17\x11V[\x80Q`\x04\x80T`\x01`\x01`\xA0\x1B\x03\x19\x90\x81\x16`\x01`\x01`\xA0\x1B\x03\x93\x84\x16\x90\x81\x17\x90\x92U` \x80\x85\x01Q`\x05\x80T\x84\x16\x91\x86\x16\x91\x82\x17\x90U`@\x80\x87\x01Q`\x06\x80T\x86\x16\x91\x88\x16\x91\x82\x17\x90U``\x80\x89\x01Q`\x07\x80T\x90\x97\x16\x98\x16\x97\x88\x17\x90\x95U\x81Q\x95\x86R\x92\x85\x01\x91\x90\x91R\x83\x01R\x81\x01\x91\x90\x91R\x7F\x87\xEBP{+B\xEBe\x98\x07\xD7\xA1\xF6<\x89\xB8\xE2,gF\x89`>\xAC\x07\xA3q?\x06\xFE\xC9\xC3\x90`\x80\x01a\x10\xDFV[`\x06T`@Q_\x91\x82\x91a\x13\xCF\x91\x86\x91`\x01\x91\x85\x91`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90\x82\x90\x81\x90\x81\x90`$\x01a\x1C\x9EV[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x81R` \x82\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16c\xB6>\x80\r`\xE0\x1B\x17\x90R`\x05T`\x04\x80T\x92Qc\x16\x88\xF0\xB9`\xE0\x1B\x81R\x93\x94P_\x93`\x01`\x01`\xA0\x1B\x03\x92\x83\x16\x93c\x16\x88\xF0\xB9\x93a\x144\x93\x91\x16\x91\x87\x91\x8A\x91\x01a\x1E\x06V[` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\x14PW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x14t\x91\x90a\x1E9V[`@Q`\x01`\x01`\xA0\x1B\x03\x82\x16\x81R\x90\x93P\x83\x91P\x7F\x821\xD1i\xF4\x16\xB6f\xAE\x7F\xA4?\xAA$\xA1\x88\x99s\x80u\xA5?2\xC9v\x17\xD1s\xB1\x89\xE3\x86\x90` \x01`@Q\x80\x91\x03\x90\xA1PP\x92\x91PPV[`@Qc5;\t\x01`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x84\x16\x90cjv\x12\x02\x90a\x14\xFD\x90\x85\x90_\x90\x86\x90\x82\x90\x81\x90\x81\x90\x81\x90\x81\x903\x90`\x03\x90`\x04\x01a\x1E\xF2V[` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\x15\x19W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x15=\x91\x90a\x1F\x97V[PPPPV[`@Qc5;\t\x01`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16\x90cjv\x12\x02\x90a\x15\x82\x90\x85\x90_\x90\x86\x90\x82\x90\x81\x90\x81\x90\x81\x90\x81\x903\x90`\x03\x90`\x04\x01a\x1E\xF2V[` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\x15\x9EW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x10d\x91\x90a\x1F\x97V[__` _\x84Q` \x86\x01_\x88Z\xF1\x80a\x15\xE1W`@Q=_\x82>=\x81\xFD[PP_Q=\x91P\x81\x15a\x15\xF8W\x80`\x01\x14\x15a\x16\x05V[`\x01`\x01`\xA0\x1B\x03\x84\x16;\x15[\x15a\x15=W`@QcRt\xAF\xE7`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x85\x16`\x04\x82\x01R`$\x01a\x05\xFFV[_\x83G\x10\x15a\x16YW`@Qc\xCFG\x91\x81`\xE0\x1B\x81RG`\x04\x82\x01R`$\x81\x01\x85\x90R`D\x01a\x05\xFFV[\x81Q_\x03a\x16zW`@Qc\x13(\x92w`\xE2\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x82\x82Q` \x84\x01\x86\xF5\x90P=\x15\x19\x81\x15\x16\x15a\x16\x9BW`@Q=_\x82>=\x81\xFD[`\x01`\x01`\xA0\x1B\x03\x81\x16a\x07\x95W`@Qc\xB0n\xBF=`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80T`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\x01`\x01`\xA0\x1B\x03\x19\x83\x16\x81\x17\x84U`@Q\x91\x90\x92\x16\x92\x83\x91\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0\x91\x90\xA3PPV[_`@Q\x83`@\x82\x01R\x84` \x82\x01R\x82\x81R`\x0B\x81\x01\x90P`\xFF\x81S`U\x90 `\x01`\x01`\xA0\x1B\x03\x16\x94\x93PPPPV[a\x03\xCF\x80a\x1F\xB7\x839\x01\x90V[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x05JW__\xFD[__\x83`\x1F\x84\x01\x12a\x17tW__\xFD[P\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x17\x8BW__\xFD[` \x83\x01\x91P\x83` \x82\x85\x01\x01\x11\x15a\x17\xA2W__\xFD[\x92P\x92\x90PV[________`\xC0\x89\x8B\x03\x12\x15a\x17\xC0W__\xFD[\x885a\x17\xCB\x81a\x17PV[\x97P` \x89\x015a\x17\xDB\x81a\x17PV[\x96P`@\x89\x015a\x17\xEB\x81a\x17PV[\x95P``\x89\x015\x94P`\x80\x89\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x18\rW__\xFD[a\x18\x19\x8B\x82\x8C\x01a\x17dV[\x90\x95P\x93PP`\xA0\x89\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x188W__\xFD[a\x18D\x8B\x82\x8C\x01a\x17dV[\x99\x9C\x98\x9BP\x96\x99P\x94\x97\x93\x96\x92\x95\x94PPPV[_` \x82\x84\x03\x12\x15a\x18hW__\xFD[\x815a\x07\x95\x81a\x17PV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@Q`\x1F\x82\x01`\x1F\x19\x16\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\x18\xB0Wa\x18\xB0a\x18sV[`@R\x91\x90PV[_``\x82\x84\x03\x12\x80\x15a\x18\xC9W__\xFD[P`@Q``\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\x18\xEDWa\x18\xEDa\x18sV[`@R\x825a\x18\xFB\x81a\x17PV[\x81R` \x83\x81\x015\x90\x82\x01R`@\x92\x83\x015\x92\x81\x01\x92\x90\x92RP\x91\x90PV[___``\x84\x86\x03\x12\x15a\x19,W__\xFD[\x835a\x197\x81a\x17PV[\x95` \x85\x015\x95P`@\x90\x94\x015\x93\x92PPPV[_\x81Q\x80\x84R\x80` \x84\x01` \x86\x01^_` \x82\x86\x01\x01R` `\x1F\x19`\x1F\x83\x01\x16\x85\x01\x01\x91PP\x92\x91PPV[` \x81R_a\x07\x95` \x83\x01\x84a\x19LV[___``\x84\x86\x03\x12\x15a\x19\x9EW__\xFD[\x835\x92P` \x84\x015a\x19\xB0\x81a\x17PV[\x92\x95\x92\x94PPP`@\x91\x90\x91\x015\x90V[_\x82`\x1F\x83\x01\x12a\x19\xD0W__\xFD[\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x19\xEAWa\x19\xEAa\x18sV[\x80`\x05\x1Ba\x19\xFA` \x82\x01a\x18\x87V[\x91\x82R` \x81\x85\x01\x81\x01\x92\x90\x81\x01\x90\x86\x84\x11\x15a\x1A\x15W__\xFD[` \x86\x01\x92P[\x83\x83\x10\x15a\nQW\x825a\x1A/\x81a\x17PV[\x82R` \x92\x83\x01\x92\x90\x91\x01\x90a\x1A\x1CV[___``\x84\x86\x03\x12\x15a\x1ARW__\xFD[\x835\x92P` \x84\x015\x91P`@\x84\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1AvW__\xFD[a\x1A\x82\x86\x82\x87\x01a\x19\xC1V[\x91PP\x92P\x92P\x92V[__`@\x83\x85\x03\x12\x15a\x1A\x9DW__\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1A\xB3W__\xFD[a\x1A\xBF\x85\x82\x86\x01a\x19\xC1V[\x95` \x94\x90\x94\x015\x94PPPPV[____`\x80\x85\x87\x03\x12\x15a\x1A\xE1W__\xFD[\x845a\x1A\xEC\x81a\x17PV[\x93P` \x85\x015\x92P`@\x85\x015a\x1B\x03\x81a\x17PV[\x93\x96\x92\x95P\x92\x93``\x015\x92PPV[_`\x80\x82\x84\x03\x12\x80\x15a\x1B$W__\xFD[P`@Q`\x80\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\x1BHWa\x1BHa\x18sV[`@R\x825a\x1BV\x81a\x17PV[\x81R` \x83\x015a\x1Bf\x81a\x17PV[` \x82\x01R`@\x83\x015a\x1By\x81a\x17PV[`@\x82\x01R``\x83\x015a\x1B\x8C\x81a\x17PV[``\x82\x01R\x93\x92PPPV[____`\x80\x85\x87\x03\x12\x15a\x1B\xABW__\xFD[\x845\x93P` \x85\x015\x92P`@\x85\x015\x91P``\x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1B\xD6W__\xFD[a\x1B\xE2\x87\x82\x88\x01a\x19\xC1V[\x91PP\x92\x95\x91\x94P\x92PV[_` \x82\x84\x03\x12\x15a\x1B\xFEW__\xFD[PQ\x91\x90PV[`\x01`\x01`\xA0\x1B\x03\x83\x16\x81R`@` \x82\x01\x81\x90R_\x90a\x1C(\x90\x83\x01\x84a\x19LV[\x94\x93PPPPV[_\x81Q\x80` \x84\x01\x85^_\x93\x01\x92\x83RP\x90\x91\x90PV[_a\x1C(a\x1CU\x83\x86a\x1C0V[\x84a\x1C0V[_\x81Q\x80\x84R` \x84\x01\x93P` \x83\x01_[\x82\x81\x10\x15a\x1C\x94W\x81Q`\x01`\x01`\xA0\x1B\x03\x16\x86R` \x95\x86\x01\x95\x90\x91\x01\x90`\x01\x01a\x1CmV[P\x93\x94\x93PPPPV[a\x01\0\x81R_a\x1C\xB2a\x01\0\x83\x01\x8Aa\x1C[V[`\xFF\x98\x89\x16` \x84\x81\x01\x91\x90\x91R`\x01`\x01`\xA0\x1B\x03\x98\x89\x16`@\x80\x86\x01\x91\x90\x91R\x84\x83\x03``\x86\x01R`\x01\x83R_\x91\x83\x01\x91\x90\x91R\x96\x88\x16`\x80\x84\x01R\x94\x87\x16`\xA0\x83\x01RP\x91\x90\x95\x16`\xC0\x82\x01R\x93\x90\x92\x16`\xE0\x90\x93\x01\x92\x90\x92R\x01\x91\x90PV[_` \x82\x84\x03\x12\x15a\x1D%W__\xFD[\x81Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1D;W__\xFD[\x82\x01`\x1F\x81\x01\x84\x13a\x1DKW__\xFD[\x80Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1DeWa\x1Dea\x18sV[a\x1Dx`\x1F\x82\x01`\x1F\x19\x16` \x01a\x18\x87V[\x81\x81R\x85` \x83\x85\x01\x01\x11\x15a\x1D\x8CW__\xFD[\x81` \x84\x01` \x83\x01^_\x91\x81\x01` \x01\x91\x90\x91R\x94\x93PPPPV[_a\x1D\xB4\x82\x85a\x1C0V[\x92\x83RPP` \x01\x91\x90PV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[\x81\x81\x03\x81\x81\x11\x15a\n\x03WcNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[` \x81R_a\x07\x95` \x83\x01\x84a\x1C[V[`\x01`\x01`\xA0\x1B\x03\x84\x16\x81R``` \x82\x01\x81\x90R_\x90a\x1E)\x90\x83\x01\x85a\x19LV[\x90P\x82`@\x83\x01R\x94\x93PPPPV[_` \x82\x84\x03\x12\x15a\x1EIW__\xFD[\x81Qa\x07\x95\x81a\x17PV[\x80T_\x90`\x01\x81\x81\x1C\x90\x82\x16\x80a\x1ElW`\x7F\x82\x16\x91P[` \x82\x10\x81\x03a\x1E\x8AWcNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x81\x86R` \x86\x01\x81\x80\x15a\x1E\xA5W`\x01\x81\x14a\x1E\xBBWa\x1E\xE7V[`\xFF\x19\x85\x16\x82R\x83\x15\x15`\x05\x1B\x82\x01\x95Pa\x1E\xE7V[_\x87\x81R` \x90 _[\x85\x81\x10\x15a\x1E\xE1W\x81T\x84\x82\x01R`\x01\x90\x91\x01\x90` \x01a\x1E\xC5V[\x83\x01\x96PP[PPPPP\x92\x91PPV[`\x01\x80`\xA0\x1B\x03\x8B\x16\x81R\x89` \x82\x01Ra\x01@`@\x82\x01R_a\x1F\x1Aa\x01@\x83\x01\x8Ba\x19LV[`\x02\x8A\x10a\x1F6WcNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[\x89``\x84\x01R\x88`\x80\x84\x01R\x87`\xA0\x84\x01R\x86`\xC0\x84\x01Ra\x1Fc`\xE0\x84\x01\x87`\x01`\x01`\xA0\x1B\x03\x16\x90RV[`\x01`\x01`\xA0\x1B\x03\x85\x16a\x01\0\x84\x01R\x82\x81\x03a\x01 \x84\x01Ra\x1F\x86\x81\x85a\x1ETV[\x9D\x9CPPPPPPPPPPPPPV[_` \x82\x84\x03\x12\x15a\x1F\xA7W__\xFD[\x81Q\x80\x15\x15\x81\x14a\x07\x95W__\xFD\xFE`\x80`@R`@Qa\x03\xCF8\x03\x80a\x03\xCF\x839\x81\x01`@\x81\x90Ra\0\"\x91a\x02;V[a\0,\x82\x82a\x003V[PPa\x03 V[a\0<\x82a\0\x91V[`@Q`\x01`\x01`\xA0\x1B\x03\x83\x16\x90\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;\x90_\x90\xA2\x80Q\x15a\0\x85Wa\0\x80\x82\x82a\x01\x0CV[PPPV[a\0\x8Da\x01\x7FV[PPV[\x80`\x01`\x01`\xA0\x1B\x03\x16;_\x03a\0\xCBW`@QcL\x9C\x8C\xE3`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x82\x16`\x04\x82\x01R`$\x01[`@Q\x80\x91\x03\x90\xFD[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16\x91\x90\x91\x17\x90UV[``__\x84`\x01`\x01`\xA0\x1B\x03\x16\x84`@Qa\x01(\x91\x90a\x03\nV[_`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80_\x81\x14a\x01`W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\x01eV[``\x91P[P\x90\x92P\x90Pa\x01v\x85\x83\x83a\x01\xA0V[\x95\x94PPPPPV[4\x15a\x01\x9EW`@Qc\xB3\x98\x97\x9F`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[``\x82a\x01\xB5Wa\x01\xB0\x82a\x01\xFFV[a\x01\xF8V[\x81Q\x15\x80\x15a\x01\xCCWP`\x01`\x01`\xA0\x1B\x03\x84\x16;\x15[\x15a\x01\xF5W`@Qc\x99\x96\xB3\x15`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x85\x16`\x04\x82\x01R`$\x01a\0\xC2V[P\x80[\x93\x92PPPV[\x80Q\x15a\x02\x0EW\x80Q` \x82\x01\xFD[`@Qc\xD6\xBD\xA2u`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[__`@\x83\x85\x03\x12\x15a\x02LW__\xFD[\x82Q`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x02bW__\xFD[` \x84\x01Q\x90\x92P`\x01`\x01`@\x1B\x03\x81\x11\x15a\x02}W__\xFD[\x83\x01`\x1F\x81\x01\x85\x13a\x02\x8DW__\xFD[\x80Q`\x01`\x01`@\x1B\x03\x81\x11\x15a\x02\xA6Wa\x02\xA6a\x02'V[`@Q`\x1F\x82\x01`\x1F\x19\x90\x81\x16`?\x01\x16\x81\x01`\x01`\x01`@\x1B\x03\x81\x11\x82\x82\x10\x17\x15a\x02\xD4Wa\x02\xD4a\x02'V[`@R\x81\x81R\x82\x82\x01` \x01\x87\x10\x15a\x02\xEBW__\xFD[\x81` \x84\x01` \x83\x01^_` \x83\x83\x01\x01R\x80\x93PPPP\x92P\x92\x90PV[_\x82Q\x80` \x85\x01\x84^_\x92\x01\x91\x82RP\x91\x90PV[`\xA3\x80a\x03,_9_\xF3\xFE`\x80`@R`\n`\x0CV[\0[`\x18`\x14`\x1AV[`PV[V[_`K\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCT`\x01`\x01`\xA0\x1B\x03\x16\x90V[\x90P\x90V[6__7__6_\x84Z\xF4=__>\x80\x80\x15`iW=_\xF3[=_\xFD\xFE\xA2dipfsX\"\x12 Yw5\xE3*m{\xEAl\x0B?J\xDF\xB8\xA17\xD7\x18\xBD*\x0CJ\x1E\xE1aU\xB3\0T\xD2B\xB6dsolcC\0\x08\x1E\x003\xB2\x81\xFC\x8C\x12\x95M\"TM\xB4]\xE3\x15\x9A9'(\x95\xB1i\xA8R\xB3\x14\xF9\xCCv.D\xC5;\xA2dipfsX\"\x12 \xCE5}o\xCF\xD0\x96\xB7\xE8M\xFE\x1F\xE6!s\xF2e\xB1\xED\x15\x06\x989\xDB\xAB\x03\xDA\xD5\xB9\x98\x8B\xFDdsolcC\0\x08\x1E\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561000f575f5ffd5b5060043610610147575f3560e01c80638afc3bf5116100bf578063c248a4e711610079578063c248a4e71461035e578063d48a66bd14610371578063e30c397814610384578063f2fde38b14610395578063f8ffe3c0146103a8578063fa2aeab4146103cf575f5ffd5b80638afc3bf5146102a25780638da5cb5b146102b55780639a94addf146102c55780639aef1ed9146102f8578063a7a6e4b81461030b578063abed205b1461034b575f5ffd5b8063715018a611610110578063715018a6146101eb57806372581cc0146101f357806379ba50971461020757806379d101fa1461020f5780637ef2721f146102225780638947890a14610249575f5ffd5b806223de291461014b5780630233296b1461016057806332838f6b1461017357806363f17ff914610186578063696ab635146101c0575b5f5ffd5b61015e6101593660046117a9565b6103e2565b005b61015e61016e366004611858565b610539565b61015e6101813660046118b8565b61054d565b6101ad7fdd24c144db91d1bc600aac99393baf8f8c664ba461188f057e37f2c37b962b4581565b6040519081526020015b60405180910390f35b6101d36101ce36600461191a565b61055e565b6040516001600160a01b0390911681526020016101b7565b61015e6105b8565b6101ad5f5160206123865f395f51905f5281565b61015e6105cb565b61015e61021d366004611858565b610611565b6040805180820182526005815264312e342e3160d81b602082015290516101b7919061197a565b60045460055460065460075461026f936001600160a01b03908116938116928116911684565b604080516001600160a01b03958616815293851660208501529184169183019190915290911660608201526080016101b7565b6101d36102b036600461198c565b6106a4565b5f546001600160a01b03166101d3565b6102d86102d3366004611a40565b61079c565b604080516001600160a01b039384168152929091166020830152016101b7565b6002546101d3906001600160a01b031681565b600854600954600a54610326926001600160a01b0316919083565b604080516001600160a01b0390941684526020840192909252908201526060016101b7565b61015e610359366004611858565b6107ce565b6101d361036c366004611a8c565b61085a565b6101d361037f366004611ace565b610a09565b6001546001600160a01b03166101d3565b61015e6103a3366004611858565b610a5b565b6101ad7f0105b97dcdf19d454ebe36f91ed516c2b90ee79f4a46af96a0138c1f5403c1cc81565b61015e6103dd366004611b13565b610acb565b6001600160a01b038616301461040b57604051633903b9f960e11b815260040160405180910390fd5b6008546001600160a01b0316331461043657604051637e5f934960e01b815260040160405180910390fd5b5f80808061044687890189611b98565b93509350935093505f7fdd24c144db91d1bc600aac99393baf8f8c664ba461188f057e37f2c37b962b455f1b85036104aa576104a184848e60085f015f9054906101000a90046001600160a01b031660086001015487610adc565b91506105139050565b7ffefa4682320e62bab141c906e12ae93d46f11860b5b950695fec73e0abfc3e3485016104fa576104a184848e60085f015f9054906101000a90046001600160a01b031660086001015487610d4e565b6040516342868c9b60e01b815260040160405180910390fd5b60085461052a906001600160a01b0316828c611012565b50505050505050505050505050565b610541611069565b61054a81611095565b50565b610555611069565b61054a816110ea565b5f61056b84848685611159565b604080516001600160a01b038084168252871660208201529192507f83a5c31bfee49d254d95e3946d8e8434e5975382fa8b849182db9e251aaaaa26910160405180910390a19392505050565b6105c0611069565b6105c95f6112dc565b565b60015433906001600160a01b031681146106085760405163118cdaa760e01b81526001600160a01b03821660048201526024015b60405180910390fd5b61054a816112dc565b610619611069565b61054a61062d5f546001600160a01b031690565b6040516370a0823160e01b81523060048201526001600160a01b038416906370a0823190602401602060405180830381865afa15801561066f573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906106939190611bee565b6001600160a01b0384169190611012565b5f5f604051806020016106b690611743565b601f1982820381018352601f909101166040818152600254600754600a546001600160a01b038a8116602087015291821684860152606085015260808085018990528351808603909101815260a085019093521691610718919060c40161197a565b60408051601f19818403018152918152602080830180516001600160e01b031663439fab9160e01b179052905161075193929101611c05565b60408051601f198184030181529082905261076f9291602001611c47565b60405160208183030381529060405280519060200120905061079185826112f5565b9150505b9392505050565b6008546009545f9182916107c2918791879133916001600160a01b039091169088610adc565b91509150935093915050565b6107d6611069565b6040516329965a1d60e01b81523060048201525f5160206123865f395f51905f5260248201526001600160a01b0382166044820152731820a4b7618bde71dce8cdc73aab6c95905fad24906329965a1d906064015f604051808303815f87803b158015610841575f5ffd5b505af1158015610853573d5f5f3e3d5ffd5b5050505050565b815160019081018084523060209091028401526006546040515f92839261089a9287929185916001600160a01b0390911690829081908190602401611c9e565b60408051601f19818403018152918152602080830180516001600160e01b031663b63e800d60e01b178152835190208251918201529081018590529091505f9060600160408051601f1981840301815282825280516020909101206005546353e5d93560e01b845291519093505f926001600160f81b0319926001600160a01b031691859183916353e5d9359160048082019289929091908290030181865afa158015610949573d5f5f3e3d5ffd5b505050506040513d5f823e601f3d908101601f191682016040526109709190810190611d15565b60045460405161098d92916001600160a01b031690602001611da9565b604051602081830303815290604052805190602001206040516020016109e594939291906001600160f81b031994909416845260609290921b6001600160601b03191660018401526015830152603582015260550190565b60408051601f19818403018152919052805160209091012093505050505b92915050565b6040516001600160601b0319606086901b166020820152603481018490525f908190605401604051602081830303815290604052805190602001209050610a518185856106a4565b9695505050505050565b610a63611069565b600180546001600160a01b0383166001600160a01b03199091168117909155610a935f546001600160a01b031690565b6001600160a01b03167f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e2270060405160405180910390a350565b610ad3611069565b61054a81611301565b5f5f8280515f03610b00576040516306bfe8d560e11b815260040160405180910390fd5b5f5b8151811015610b5e57306001600160a01b0316828281518110610b2757610b27611dc1565b60200260200101516001600160a01b031603610b56576040516349e27cff60e01b815260040160405180910390fd5b600101610b02565b5083516001018085523060209091028501525f610b7b858b6113a0565b90505f610b8a828b8b8e611159565b6040516001600160a01b038416602482018190525f5160206123865f395f51905f52604483015260648201529091505f9060840160408051601f198184030181529190526020810180516001600160e01b03166329965a1d60e01b1790529050610c0983731820a4b7618bde71dce8cdc73aab6c95905fad24836114be565b6040516001600160a01b03831660248201525f9060440160408051601f198184030181529190526020810180516001600160e01b031663610b592560e01b1790529050610c568482611543565b5f610c618d60601c90565b6040516001600160a01b039091166024820152604481018b905260640160408051601f198184030181529190526020810180516001600160e01b031663095ea7b360e01b1790529050610cb5858c836114be565b5f8960028b51610cc59190611dd5565b81518110610cd557610cd5611dc1565b60209081029190910101516040516001600160a01b0390911660248201523060448201526001606482015260840160408051601f198184030181529190526020810180516001600160e01b031663f8dc5dd960e01b1790529050610d398682611543565b50929d939c50929a5050505050505050505050565b5f5f8280515f03610d72576040516306bfe8d560e11b815260040160405180910390fd5b5f5b8151811015610dd057306001600160a01b0316828281518110610d9957610d99611dc1565b60200260200101516001600160a01b031603610dc8576040516349e27cff60e01b815260040160405180910390fd5b600101610d74565b5083516001018085523060209091028501525f610ded858b6113a0565b90505f610dfc828b8b8e611159565b6040516001600160a01b038416602482018190525f5160206123865f395f51905f52604483015260648201529091505f9060840160408051601f198184030181529190526020810180516001600160e01b03166329965a1d60e01b1790529050610e7b83731820a4b7618bde71dce8cdc73aab6c95905fad24836114be565b6040516001600160a01b03831660248201525f9060440160408051601f198184030181529190526020810180516001600160e01b031663610b592560e01b1790529050610ec88482611543565b5f610ed38d60601c90565b6040516001600160a01b039091166024820152604481018b905260640160408051601f198184030181529190526020810180516001600160e01b031663095ea7b360e01b1790529050610f27858c836114be565b88515f190189526040515f90610f41908b90602401611df4565b60408051601f198184030181529190526020810180516001600160e01b031663110dcee760e01b1790529050610f788686836114be565b5f8a60018c51610f889190611dd5565b81518110610f9857610f98611dc1565b60209081029190910101516040516001600160a01b0390911660248201523060448201526001606482015260840160408051601f198184030181529190526020810180516001600160e01b031663f8dc5dd960e01b1790529050610ffc8782611543565b50939e949d50939b505050505050505050505050565b604080516001600160a01b038416602482015260448082018490528251808303909101815260649091019091526020810180516001600160e01b031663a9059cbb60e01b1790526110649084906115c2565b505050565b5f546001600160a01b031633146105c95760405163118cdaa760e01b81523360048201526024016105ff565b600280546001600160a01b0319166001600160a01b0383169081179091556040519081527fdd60725a88508fe2dcb769bd824280a2a01356198c795515d175abc4bc40b74e906020015b60405180910390a150565b8051600880546001600160a01b0319166001600160a01b0390921691821790556020808301516009819055604080850151600a8190558151948552928401919091528201527f54cfcf4bdb6f20632ba544cd684130fc9db4dc2fe6360926d6b7866297f0315e906060016110df565b600754600a54604080516001600160a01b038089166020830152909316908301526060820152608081018490525f90819060a00160408051601f19818403018152908290526111aa9160240161197a565b60408051601f19818403018152918152602080830180516001600160e01b031663439fab9160e01b17905290519192505f9161120291879187910160609290921b6001600160601b0319168252601482015260340190565b6040516020818303038152906040528051906020012090506112935f826040518060200161122f90611743565b601f1982820381018352601f909101166040819052600254611261916001600160a01b03909116908890602001611c05565b60408051601f198184030181529082905261127f9291602001611c47565b60405160208183030381529060405261162e565b6040516001600160a01b03821681529093507ff966ce717349a940e403b8faae71fdaf573d8b9847deea16fca3d870cf6c292d9060200160405180910390a15050949350505050565b600180546001600160a01b031916905561054a816116c2565b5f610795838330611711565b8051600480546001600160a01b03199081166001600160a01b03938416908117909255602080850151600580548416918616918217905560408087015160068054861691881691821790556060808901516007805490971698169788179095558151958652928501919091528301528101919091527f87eb507b2b42eb659807d7a1f63c89b8e22c674689603eac07a3713f06fec9c3906080016110df565b6006546040515f9182916113cf91869160019185916001600160a01b0390911690829081908190602401611c9e565b60408051601f198184030181529181526020820180516001600160e01b031663b63e800d60e01b179052600554600480549251631688f0b960e01b81529394505f936001600160a01b0392831693631688f0b9936114349391169187918a9101611e06565b6020604051808303815f875af1158015611450573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906114749190611e39565b6040516001600160a01b03821681529093508391507f8231d169f416b666ae7fa43faa24a18899738075a53f32c97617d173b189e3869060200160405180910390a1505092915050565b60405163353b090160e11b81526001600160a01b03841690636a761202906114fd9085905f908690829081908190819081903390600390600401611ef2565b6020604051808303815f875af1158015611519573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061153d9190611f97565b50505050565b60405163353b090160e11b81526001600160a01b03831690636a761202906115829085905f908690829081908190819081903390600390600401611ef2565b6020604051808303815f875af115801561159e573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906110649190611f97565b5f5f60205f8451602086015f885af1806115e1576040513d5f823e3d81fd5b50505f513d915081156115f8578060011415611605565b6001600160a01b0384163b155b1561153d57604051635274afe760e01b81526001600160a01b03851660048201526024016105ff565b5f834710156116595760405163cf47918160e01b8152476004820152602481018590526044016105ff565b81515f0361167a57604051631328927760e21b815260040160405180910390fd5b8282516020840186f590503d15198115161561169b576040513d5f823e3d81fd5b6001600160a01b0381166107955760405163b06ebf3d60e01b815260040160405180910390fd5b5f80546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b5f604051836040820152846020820152828152600b8101905060ff8153605590206001600160a01b0316949350505050565b6103cf80611fb783390190565b6001600160a01b038116811461054a575f5ffd5b5f5f83601f840112611774575f5ffd5b50813567ffffffffffffffff81111561178b575f5ffd5b6020830191508360208285010111156117a2575f5ffd5b9250929050565b5f5f5f5f5f5f5f5f60c0898b0312156117c0575f5ffd5b88356117cb81611750565b975060208901356117db81611750565b965060408901356117eb81611750565b955060608901359450608089013567ffffffffffffffff81111561180d575f5ffd5b6118198b828c01611764565b90955093505060a089013567ffffffffffffffff811115611838575f5ffd5b6118448b828c01611764565b999c989b5096995094979396929594505050565b5f60208284031215611868575f5ffd5b813561079581611750565b634e487b7160e01b5f52604160045260245ffd5b604051601f8201601f1916810167ffffffffffffffff811182821017156118b0576118b0611873565b604052919050565b5f60608284031280156118c9575f5ffd5b506040516060810167ffffffffffffffff811182821017156118ed576118ed611873565b60405282356118fb81611750565b8152602083810135908201526040928301359281019290925250919050565b5f5f5f6060848603121561192c575f5ffd5b833561193781611750565b95602085013595506040909401359392505050565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b602081525f610795602083018461194c565b5f5f5f6060848603121561199e575f5ffd5b8335925060208401356119b081611750565b929592945050506040919091013590565b5f82601f8301126119d0575f5ffd5b813567ffffffffffffffff8111156119ea576119ea611873565b8060051b6119fa60208201611887565b91825260208185018101929081019086841115611a15575f5ffd5b6020860192505b83831015610a51578235611a2f81611750565b825260209283019290910190611a1c565b5f5f5f60608486031215611a52575f5ffd5b8335925060208401359150604084013567ffffffffffffffff811115611a76575f5ffd5b611a82868287016119c1565b9150509250925092565b5f5f60408385031215611a9d575f5ffd5b823567ffffffffffffffff811115611ab3575f5ffd5b611abf858286016119c1565b95602094909401359450505050565b5f5f5f5f60808587031215611ae1575f5ffd5b8435611aec81611750565b9350602085013592506040850135611b0381611750565b9396929550929360600135925050565b5f6080828403128015611b24575f5ffd5b506040516080810167ffffffffffffffff81118282101715611b4857611b48611873565b6040528235611b5681611750565b81526020830135611b6681611750565b60208201526040830135611b7981611750565b60408201526060830135611b8c81611750565b60608201529392505050565b5f5f5f5f60808587031215611bab575f5ffd5b843593506020850135925060408501359150606085013567ffffffffffffffff811115611bd6575f5ffd5b611be2878288016119c1565b91505092959194509250565b5f60208284031215611bfe575f5ffd5b5051919050565b6001600160a01b03831681526040602082018190525f90611c289083018461194c565b949350505050565b5f81518060208401855e5f93019283525090919050565b5f611c28611c558386611c30565b84611c30565b5f8151808452602084019350602083015f5b82811015611c945781516001600160a01b0316865260209586019590910190600101611c6d565b5093949350505050565b61010081525f611cb261010083018a611c5b565b60ff9889166020848101919091526001600160a01b039889166040808601919091528483036060860152600183525f91830191909152968816608084015294871660a0830152509190951660c08201529390921660e09093019290925201919050565b5f60208284031215611d25575f5ffd5b815167ffffffffffffffff811115611d3b575f5ffd5b8201601f81018413611d4b575f5ffd5b805167ffffffffffffffff811115611d6557611d65611873565b611d78601f8201601f1916602001611887565b818152856020838501011115611d8c575f5ffd5b8160208401602083015e5f91810160200191909152949350505050565b5f611db48285611c30565b9283525050602001919050565b634e487b7160e01b5f52603260045260245ffd5b81810381811115610a0357634e487b7160e01b5f52601160045260245ffd5b602081525f6107956020830184611c5b565b6001600160a01b03841681526060602082018190525f90611e299083018561194c565b9050826040830152949350505050565b5f60208284031215611e49575f5ffd5b815161079581611750565b80545f90600181811c90821680611e6c57607f821691505b602082108103611e8a57634e487b7160e01b5f52602260045260245ffd5b81865260208601818015611ea55760018114611ebb57611ee7565b60ff198516825283151560051b82019550611ee7565b5f878152602090205f5b85811015611ee157815484820152600190910190602001611ec5565b83019650505b505050505092915050565b60018060a01b038b16815289602082015261014060408201525f611f1a61014083018b61194c565b60028a10611f3657634e487b7160e01b5f52602160045260245ffd5b8960608401528860808401528760a08401528660c0840152611f6360e08401876001600160a01b03169052565b6001600160a01b038516610100840152828103610120840152611f868185611e54565b9d9c50505050505050505050505050565b5f60208284031215611fa7575f5ffd5b81518015158114610795575f5ffdfe60806040526040516103cf3803806103cf8339810160408190526100229161023b565b61002c8282610033565b5050610320565b61003c82610091565b6040516001600160a01b038316907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b905f90a280511561008557610080828261010c565b505050565b61008d61017f565b5050565b806001600160a01b03163b5f036100cb57604051634c9c8ce360e01b81526001600160a01b03821660048201526024015b60405180910390fd5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc80546001600160a01b0319166001600160a01b0392909216919091179055565b60605f5f846001600160a01b031684604051610128919061030a565b5f60405180830381855af49150503d805f8114610160576040519150601f19603f3d011682016040523d82523d5f602084013e610165565b606091505b5090925090506101768583836101a0565b95945050505050565b341561019e5760405163b398979f60e01b815260040160405180910390fd5b565b6060826101b5576101b0826101ff565b6101f8565b81511580156101cc57506001600160a01b0384163b155b156101f557604051639996b31560e01b81526001600160a01b03851660048201526024016100c2565b50805b9392505050565b80511561020e57805160208201fd5b60405163d6bda27560e01b815260040160405180910390fd5b634e487b7160e01b5f52604160045260245ffd5b5f5f6040838503121561024c575f5ffd5b82516001600160a01b0381168114610262575f5ffd5b60208401519092506001600160401b0381111561027d575f5ffd5b8301601f8101851361028d575f5ffd5b80516001600160401b038111156102a6576102a6610227565b604051601f8201601f19908116603f011681016001600160401b03811182821017156102d4576102d4610227565b6040528181528282016020018710156102eb575f5ffd5b8160208401602083015e5f602083830101528093505050509250929050565b5f82518060208501845e5f920191825250919050565b60a38061032c5f395ff3fe6080604052600a600c565b005b60186014601a565b6050565b565b5f604b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc546001600160a01b031690565b905090565b365f5f375f5f365f845af43d5f5f3e8080156069573d5ff35b3d5ffdfea2646970667358221220597735e32a6d7bea6c0b3f4adfb8a137d718bd2a0c4a1ee16155b30054d242b664736f6c634300081e0033b281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53ba2646970667358221220ce357d6fcfd096b7e84dfe1fe62173f265b1ed15069839dbab03dad5b9988bfd64736f6c634300081e0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\x01GW_5`\xE0\x1C\x80c\x8A\xFC;\xF5\x11a\0\xBFW\x80c\xC2H\xA4\xE7\x11a\0yW\x80c\xC2H\xA4\xE7\x14a\x03^W\x80c\xD4\x8Af\xBD\x14a\x03qW\x80c\xE3\x0C9x\x14a\x03\x84W\x80c\xF2\xFD\xE3\x8B\x14a\x03\x95W\x80c\xF8\xFF\xE3\xC0\x14a\x03\xA8W\x80c\xFA*\xEA\xB4\x14a\x03\xCFW__\xFD[\x80c\x8A\xFC;\xF5\x14a\x02\xA2W\x80c\x8D\xA5\xCB[\x14a\x02\xB5W\x80c\x9A\x94\xAD\xDF\x14a\x02\xC5W\x80c\x9A\xEF\x1E\xD9\x14a\x02\xF8W\x80c\xA7\xA6\xE4\xB8\x14a\x03\x0BW\x80c\xAB\xED [\x14a\x03KW__\xFD[\x80cqP\x18\xA6\x11a\x01\x10W\x80cqP\x18\xA6\x14a\x01\xEBW\x80crX\x1C\xC0\x14a\x01\xF3W\x80cy\xBAP\x97\x14a\x02\x07W\x80cy\xD1\x01\xFA\x14a\x02\x0FW\x80c~\xF2r\x1F\x14a\x02\"W\x80c\x89G\x89\n\x14a\x02IW__\xFD[\x80b#\xDE)\x14a\x01KW\x80c\x023)k\x14a\x01`W\x80c2\x83\x8Fk\x14a\x01sW\x80cc\xF1\x7F\xF9\x14a\x01\x86W\x80cij\xB65\x14a\x01\xC0W[__\xFD[a\x01^a\x01Y6`\x04a\x17\xA9V[a\x03\xE2V[\0[a\x01^a\x01n6`\x04a\x18XV[a\x059V[a\x01^a\x01\x816`\x04a\x18\xB8V[a\x05MV[a\x01\xAD\x7F\xDD$\xC1D\xDB\x91\xD1\xBC`\n\xAC\x999;\xAF\x8F\x8CfK\xA4a\x18\x8F\x05~7\xF2\xC3{\x96+E\x81V[`@Q\x90\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\x01\xD3a\x01\xCE6`\x04a\x19\x1AV[a\x05^V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\x01\xB7V[a\x01^a\x05\xB8V[a\x01\xAD_Q` a#\x86_9_Q\x90_R\x81V[a\x01^a\x05\xCBV[a\x01^a\x02\x1D6`\x04a\x18XV[a\x06\x11V[`@\x80Q\x80\x82\x01\x82R`\x05\x81Rd1.4.1`\xD8\x1B` \x82\x01R\x90Qa\x01\xB7\x91\x90a\x19zV[`\x04T`\x05T`\x06T`\x07Ta\x02o\x93`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x93\x81\x16\x92\x81\x16\x91\x16\x84V[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x95\x86\x16\x81R\x93\x85\x16` \x85\x01R\x91\x84\x16\x91\x83\x01\x91\x90\x91R\x90\x91\x16``\x82\x01R`\x80\x01a\x01\xB7V[a\x01\xD3a\x02\xB06`\x04a\x19\x8CV[a\x06\xA4V[_T`\x01`\x01`\xA0\x1B\x03\x16a\x01\xD3V[a\x02\xD8a\x02\xD36`\x04a\x1A@V[a\x07\x9CV[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x93\x84\x16\x81R\x92\x90\x91\x16` \x83\x01R\x01a\x01\xB7V[`\x02Ta\x01\xD3\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[`\x08T`\tT`\nTa\x03&\x92`\x01`\x01`\xA0\x1B\x03\x16\x91\x90\x83V[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x90\x94\x16\x84R` \x84\x01\x92\x90\x92R\x90\x82\x01R``\x01a\x01\xB7V[a\x01^a\x03Y6`\x04a\x18XV[a\x07\xCEV[a\x01\xD3a\x03l6`\x04a\x1A\x8CV[a\x08ZV[a\x01\xD3a\x03\x7F6`\x04a\x1A\xCEV[a\n\tV[`\x01T`\x01`\x01`\xA0\x1B\x03\x16a\x01\xD3V[a\x01^a\x03\xA36`\x04a\x18XV[a\n[V[a\x01\xAD\x7F\x01\x05\xB9}\xCD\xF1\x9DEN\xBE6\xF9\x1E\xD5\x16\xC2\xB9\x0E\xE7\x9FJF\xAF\x96\xA0\x13\x8C\x1FT\x03\xC1\xCC\x81V[a\x01^a\x03\xDD6`\x04a\x1B\x13V[a\n\xCBV[`\x01`\x01`\xA0\x1B\x03\x86\x160\x14a\x04\x0BW`@Qc9\x03\xB9\xF9`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x08T`\x01`\x01`\xA0\x1B\x03\x163\x14a\x046W`@Qc~_\x93I`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80\x80\x80a\x04F\x87\x89\x01\x89a\x1B\x98V[\x93P\x93P\x93P\x93P_\x7F\xDD$\xC1D\xDB\x91\xD1\xBC`\n\xAC\x999;\xAF\x8F\x8CfK\xA4a\x18\x8F\x05~7\xF2\xC3{\x96+E_\x1B\x85\x03a\x04\xAAWa\x04\xA1\x84\x84\x8E`\x08_\x01_\x90T\x90a\x01\0\n\x90\x04`\x01`\x01`\xA0\x1B\x03\x16`\x08`\x01\x01T\x87a\n\xDCV[\x91Pa\x05\x13\x90PV[\x7F\xFE\xFAF\x822\x0Eb\xBA\xB1A\xC9\x06\xE1*\xE9=F\xF1\x18`\xB5\xB9Pi_\xECs\xE0\xAB\xFC>4\x85\x01a\x04\xFAWa\x04\xA1\x84\x84\x8E`\x08_\x01_\x90T\x90a\x01\0\n\x90\x04`\x01`\x01`\xA0\x1B\x03\x16`\x08`\x01\x01T\x87a\rNV[`@QcB\x86\x8C\x9B`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x08Ta\x05*\x90`\x01`\x01`\xA0\x1B\x03\x16\x82\x8Ca\x10\x12V[PPPPPPPPPPPPPV[a\x05Aa\x10iV[a\x05J\x81a\x10\x95V[PV[a\x05Ua\x10iV[a\x05J\x81a\x10\xEAV[_a\x05k\x84\x84\x86\x85a\x11YV[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x80\x84\x16\x82R\x87\x16` \x82\x01R\x91\x92P\x7F\x83\xA5\xC3\x1B\xFE\xE4\x9D%M\x95\xE3\x94m\x8E\x844\xE5\x97S\x82\xFA\x8B\x84\x91\x82\xDB\x9E%\x1A\xAA\xAA&\x91\x01`@Q\x80\x91\x03\x90\xA1\x93\x92PPPV[a\x05\xC0a\x10iV[a\x05\xC9_a\x12\xDCV[V[`\x01T3\x90`\x01`\x01`\xA0\x1B\x03\x16\x81\x14a\x06\x08W`@Qc\x11\x8C\xDA\xA7`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x82\x16`\x04\x82\x01R`$\x01[`@Q\x80\x91\x03\x90\xFD[a\x05J\x81a\x12\xDCV[a\x06\x19a\x10iV[a\x05Ja\x06-_T`\x01`\x01`\xA0\x1B\x03\x16\x90V[`@Qcp\xA0\x821`\xE0\x1B\x81R0`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x84\x16\x90cp\xA0\x821\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x06oW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x06\x93\x91\x90a\x1B\xEEV[`\x01`\x01`\xA0\x1B\x03\x84\x16\x91\x90a\x10\x12V[__`@Q\x80` \x01a\x06\xB6\x90a\x17CV[`\x1F\x19\x82\x82\x03\x81\x01\x83R`\x1F\x90\x91\x01\x16`@\x81\x81R`\x02T`\x07T`\nT`\x01`\x01`\xA0\x1B\x03\x8A\x81\x16` \x87\x01R\x91\x82\x16\x84\x86\x01R``\x85\x01R`\x80\x80\x85\x01\x89\x90R\x83Q\x80\x86\x03\x90\x91\x01\x81R`\xA0\x85\x01\x90\x93R\x16\x91a\x07\x18\x91\x90`\xC4\x01a\x19zV[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x81R` \x80\x83\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16cC\x9F\xAB\x91`\xE0\x1B\x17\x90R\x90Qa\x07Q\x93\x92\x91\x01a\x1C\x05V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90Ra\x07o\x92\x91` \x01a\x1CGV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90Pa\x07\x91\x85\x82a\x12\xF5V[\x91PP[\x93\x92PPPV[`\x08T`\tT_\x91\x82\x91a\x07\xC2\x91\x87\x91\x87\x913\x91`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90\x88a\n\xDCV[\x91P\x91P\x93P\x93\x91PPV[a\x07\xD6a\x10iV[`@Qc)\x96Z\x1D`\xE0\x1B\x81R0`\x04\x82\x01R_Q` a#\x86_9_Q\x90_R`$\x82\x01R`\x01`\x01`\xA0\x1B\x03\x82\x16`D\x82\x01Rs\x18 \xA4\xB7a\x8B\xDEq\xDC\xE8\xCD\xC7:\xABl\x95\x90_\xAD$\x90c)\x96Z\x1D\x90`d\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x08AW__\xFD[PZ\xF1\x15\x80\x15a\x08SW=__>=_\xFD[PPPPPV[\x81Q`\x01\x90\x81\x01\x80\x84R0` \x90\x91\x02\x84\x01R`\x06T`@Q_\x92\x83\x92a\x08\x9A\x92\x87\x92\x91\x85\x91`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90\x82\x90\x81\x90\x81\x90`$\x01a\x1C\x9EV[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x81R` \x80\x83\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16c\xB6>\x80\r`\xE0\x1B\x17\x81R\x83Q\x90 \x82Q\x91\x82\x01R\x90\x81\x01\x85\x90R\x90\x91P_\x90``\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x82\x82R\x80Q` \x90\x91\x01 `\x05TcS\xE5\xD95`\xE0\x1B\x84R\x91Q\x90\x93P_\x92`\x01`\x01`\xF8\x1B\x03\x19\x92`\x01`\x01`\xA0\x1B\x03\x16\x91\x85\x91\x83\x91cS\xE5\xD95\x91`\x04\x80\x82\x01\x92\x89\x92\x90\x91\x90\x82\x90\x03\x01\x81\x86Z\xFA\x15\x80\x15a\tIW=__>=_\xFD[PPPP`@Q=_\x82>`\x1F=\x90\x81\x01`\x1F\x19\x16\x82\x01`@Ra\tp\x91\x90\x81\x01\x90a\x1D\x15V[`\x04T`@Qa\t\x8D\x92\x91`\x01`\x01`\xA0\x1B\x03\x16\x90` \x01a\x1D\xA9V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 `@Q` \x01a\t\xE5\x94\x93\x92\x91\x90`\x01`\x01`\xF8\x1B\x03\x19\x94\x90\x94\x16\x84R``\x92\x90\x92\x1B`\x01`\x01``\x1B\x03\x19\x16`\x01\x84\x01R`\x15\x83\x01R`5\x82\x01R`U\x01\x90V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R\x80Q` \x90\x91\x01 \x93PPPP[\x92\x91PPV[`@Q`\x01`\x01``\x1B\x03\x19``\x86\x90\x1B\x16` \x82\x01R`4\x81\x01\x84\x90R_\x90\x81\x90`T\x01`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90Pa\nQ\x81\x85\x85a\x06\xA4V[\x96\x95PPPPPPV[a\nca\x10iV[`\x01\x80T`\x01`\x01`\xA0\x1B\x03\x83\x16`\x01`\x01`\xA0\x1B\x03\x19\x90\x91\x16\x81\x17\x90\x91Ua\n\x93_T`\x01`\x01`\xA0\x1B\x03\x16\x90V[`\x01`\x01`\xA0\x1B\x03\x16\x7F8\xD1k\x8C\xAC\"\xD9\x9F\xC7\xC1$\xB9\xCD\r\xE2\xD3\xFA\x1F\xAE\xF4 \xBF\xE7\x91\xD8\xC3b\xD7e\xE2'\0`@Q`@Q\x80\x91\x03\x90\xA3PV[a\n\xD3a\x10iV[a\x05J\x81a\x13\x01V[__\x82\x80Q_\x03a\x0B\0W`@Qc\x06\xBF\xE8\xD5`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_[\x81Q\x81\x10\x15a\x0B^W0`\x01`\x01`\xA0\x1B\x03\x16\x82\x82\x81Q\x81\x10a\x0B'Wa\x0B'a\x1D\xC1V[` \x02` \x01\x01Q`\x01`\x01`\xA0\x1B\x03\x16\x03a\x0BVW`@QcI\xE2|\xFF`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x01\x01a\x0B\x02V[P\x83Q`\x01\x01\x80\x85R0` \x90\x91\x02\x85\x01R_a\x0B{\x85\x8Ba\x13\xA0V[\x90P_a\x0B\x8A\x82\x8B\x8B\x8Ea\x11YV[`@Q`\x01`\x01`\xA0\x1B\x03\x84\x16`$\x82\x01\x81\x90R_Q` a#\x86_9_Q\x90_R`D\x83\x01R`d\x82\x01R\x90\x91P_\x90`\x84\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R` \x81\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16c)\x96Z\x1D`\xE0\x1B\x17\x90R\x90Pa\x0C\t\x83s\x18 \xA4\xB7a\x8B\xDEq\xDC\xE8\xCD\xC7:\xABl\x95\x90_\xAD$\x83a\x14\xBEV[`@Q`\x01`\x01`\xA0\x1B\x03\x83\x16`$\x82\x01R_\x90`D\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R` \x81\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16ca\x0BY%`\xE0\x1B\x17\x90R\x90Pa\x0CV\x84\x82a\x15CV[_a\x0Ca\x8D``\x1C\x90V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16`$\x82\x01R`D\x81\x01\x8B\x90R`d\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R` \x81\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16c\t^\xA7\xB3`\xE0\x1B\x17\x90R\x90Pa\x0C\xB5\x85\x8C\x83a\x14\xBEV[_\x89`\x02\x8BQa\x0C\xC5\x91\x90a\x1D\xD5V[\x81Q\x81\x10a\x0C\xD5Wa\x0C\xD5a\x1D\xC1V[` \x90\x81\x02\x91\x90\x91\x01\x01Q`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16`$\x82\x01R0`D\x82\x01R`\x01`d\x82\x01R`\x84\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R` \x81\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16c\xF8\xDC]\xD9`\xE0\x1B\x17\x90R\x90Pa\r9\x86\x82a\x15CV[P\x92\x9D\x93\x9CP\x92\x9APPPPPPPPPPPV[__\x82\x80Q_\x03a\rrW`@Qc\x06\xBF\xE8\xD5`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_[\x81Q\x81\x10\x15a\r\xD0W0`\x01`\x01`\xA0\x1B\x03\x16\x82\x82\x81Q\x81\x10a\r\x99Wa\r\x99a\x1D\xC1V[` \x02` \x01\x01Q`\x01`\x01`\xA0\x1B\x03\x16\x03a\r\xC8W`@QcI\xE2|\xFF`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x01\x01a\rtV[P\x83Q`\x01\x01\x80\x85R0` \x90\x91\x02\x85\x01R_a\r\xED\x85\x8Ba\x13\xA0V[\x90P_a\r\xFC\x82\x8B\x8B\x8Ea\x11YV[`@Q`\x01`\x01`\xA0\x1B\x03\x84\x16`$\x82\x01\x81\x90R_Q` a#\x86_9_Q\x90_R`D\x83\x01R`d\x82\x01R\x90\x91P_\x90`\x84\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R` \x81\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16c)\x96Z\x1D`\xE0\x1B\x17\x90R\x90Pa\x0E{\x83s\x18 \xA4\xB7a\x8B\xDEq\xDC\xE8\xCD\xC7:\xABl\x95\x90_\xAD$\x83a\x14\xBEV[`@Q`\x01`\x01`\xA0\x1B\x03\x83\x16`$\x82\x01R_\x90`D\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R` \x81\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16ca\x0BY%`\xE0\x1B\x17\x90R\x90Pa\x0E\xC8\x84\x82a\x15CV[_a\x0E\xD3\x8D``\x1C\x90V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16`$\x82\x01R`D\x81\x01\x8B\x90R`d\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R` \x81\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16c\t^\xA7\xB3`\xE0\x1B\x17\x90R\x90Pa\x0F'\x85\x8C\x83a\x14\xBEV[\x88Q_\x19\x01\x89R`@Q_\x90a\x0FA\x90\x8B\x90`$\x01a\x1D\xF4V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R` \x81\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16c\x11\r\xCE\xE7`\xE0\x1B\x17\x90R\x90Pa\x0Fx\x86\x86\x83a\x14\xBEV[_\x8A`\x01\x8CQa\x0F\x88\x91\x90a\x1D\xD5V[\x81Q\x81\x10a\x0F\x98Wa\x0F\x98a\x1D\xC1V[` \x90\x81\x02\x91\x90\x91\x01\x01Q`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16`$\x82\x01R0`D\x82\x01R`\x01`d\x82\x01R`\x84\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R` \x81\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16c\xF8\xDC]\xD9`\xE0\x1B\x17\x90R\x90Pa\x0F\xFC\x87\x82a\x15CV[P\x93\x9E\x94\x9DP\x93\x9BPPPPPPPPPPPPV[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x84\x16`$\x82\x01R`D\x80\x82\x01\x84\x90R\x82Q\x80\x83\x03\x90\x91\x01\x81R`d\x90\x91\x01\x90\x91R` \x81\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16c\xA9\x05\x9C\xBB`\xE0\x1B\x17\x90Ra\x10d\x90\x84\x90a\x15\xC2V[PPPV[_T`\x01`\x01`\xA0\x1B\x03\x163\x14a\x05\xC9W`@Qc\x11\x8C\xDA\xA7`\xE0\x1B\x81R3`\x04\x82\x01R`$\x01a\x05\xFFV[`\x02\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x83\x16\x90\x81\x17\x90\x91U`@Q\x90\x81R\x7F\xDD`rZ\x88P\x8F\xE2\xDC\xB7i\xBD\x82B\x80\xA2\xA0\x13V\x19\x8CyU\x15\xD1u\xAB\xC4\xBC@\xB7N\x90` \x01[`@Q\x80\x91\x03\x90\xA1PV[\x80Q`\x08\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x90\x92\x16\x91\x82\x17\x90U` \x80\x83\x01Q`\t\x81\x90U`@\x80\x85\x01Q`\n\x81\x90U\x81Q\x94\x85R\x92\x84\x01\x91\x90\x91R\x82\x01R\x7FT\xCF\xCFK\xDBo c+\xA5D\xCDhA0\xFC\x9D\xB4\xDC/\xE66\t&\xD6\xB7\x86b\x97\xF01^\x90``\x01a\x10\xDFV[`\x07T`\nT`@\x80Q`\x01`\x01`\xA0\x1B\x03\x80\x89\x16` \x83\x01R\x90\x93\x16\x90\x83\x01R``\x82\x01R`\x80\x81\x01\x84\x90R_\x90\x81\x90`\xA0\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90Ra\x11\xAA\x91`$\x01a\x19zV[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x81R` \x80\x83\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16cC\x9F\xAB\x91`\xE0\x1B\x17\x90R\x90Q\x91\x92P_\x91a\x12\x02\x91\x87\x91\x87\x91\x01``\x92\x90\x92\x1B`\x01`\x01``\x1B\x03\x19\x16\x82R`\x14\x82\x01R`4\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90Pa\x12\x93_\x82`@Q\x80` \x01a\x12/\x90a\x17CV[`\x1F\x19\x82\x82\x03\x81\x01\x83R`\x1F\x90\x91\x01\x16`@\x81\x90R`\x02Ta\x12a\x91`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90\x88\x90` \x01a\x1C\x05V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90Ra\x12\x7F\x92\x91` \x01a\x1CGV[`@Q` \x81\x83\x03\x03\x81R\x90`@Ra\x16.V[`@Q`\x01`\x01`\xA0\x1B\x03\x82\x16\x81R\x90\x93P\x7F\xF9f\xCEqsI\xA9@\xE4\x03\xB8\xFA\xAEq\xFD\xAFW=\x8B\x98G\xDE\xEA\x16\xFC\xA3\xD8p\xCFl)-\x90` \x01`@Q\x80\x91\x03\x90\xA1PP\x94\x93PPPPV[`\x01\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16\x90Ua\x05J\x81a\x16\xC2V[_a\x07\x95\x83\x830a\x17\x11V[\x80Q`\x04\x80T`\x01`\x01`\xA0\x1B\x03\x19\x90\x81\x16`\x01`\x01`\xA0\x1B\x03\x93\x84\x16\x90\x81\x17\x90\x92U` \x80\x85\x01Q`\x05\x80T\x84\x16\x91\x86\x16\x91\x82\x17\x90U`@\x80\x87\x01Q`\x06\x80T\x86\x16\x91\x88\x16\x91\x82\x17\x90U``\x80\x89\x01Q`\x07\x80T\x90\x97\x16\x98\x16\x97\x88\x17\x90\x95U\x81Q\x95\x86R\x92\x85\x01\x91\x90\x91R\x83\x01R\x81\x01\x91\x90\x91R\x7F\x87\xEBP{+B\xEBe\x98\x07\xD7\xA1\xF6<\x89\xB8\xE2,gF\x89`>\xAC\x07\xA3q?\x06\xFE\xC9\xC3\x90`\x80\x01a\x10\xDFV[`\x06T`@Q_\x91\x82\x91a\x13\xCF\x91\x86\x91`\x01\x91\x85\x91`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90\x82\x90\x81\x90\x81\x90`$\x01a\x1C\x9EV[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x81R` \x82\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16c\xB6>\x80\r`\xE0\x1B\x17\x90R`\x05T`\x04\x80T\x92Qc\x16\x88\xF0\xB9`\xE0\x1B\x81R\x93\x94P_\x93`\x01`\x01`\xA0\x1B\x03\x92\x83\x16\x93c\x16\x88\xF0\xB9\x93a\x144\x93\x91\x16\x91\x87\x91\x8A\x91\x01a\x1E\x06V[` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\x14PW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x14t\x91\x90a\x1E9V[`@Q`\x01`\x01`\xA0\x1B\x03\x82\x16\x81R\x90\x93P\x83\x91P\x7F\x821\xD1i\xF4\x16\xB6f\xAE\x7F\xA4?\xAA$\xA1\x88\x99s\x80u\xA5?2\xC9v\x17\xD1s\xB1\x89\xE3\x86\x90` \x01`@Q\x80\x91\x03\x90\xA1PP\x92\x91PPV[`@Qc5;\t\x01`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x84\x16\x90cjv\x12\x02\x90a\x14\xFD\x90\x85\x90_\x90\x86\x90\x82\x90\x81\x90\x81\x90\x81\x90\x81\x903\x90`\x03\x90`\x04\x01a\x1E\xF2V[` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\x15\x19W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x15=\x91\x90a\x1F\x97V[PPPPV[`@Qc5;\t\x01`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16\x90cjv\x12\x02\x90a\x15\x82\x90\x85\x90_\x90\x86\x90\x82\x90\x81\x90\x81\x90\x81\x90\x81\x903\x90`\x03\x90`\x04\x01a\x1E\xF2V[` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\x15\x9EW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x10d\x91\x90a\x1F\x97V[__` _\x84Q` \x86\x01_\x88Z\xF1\x80a\x15\xE1W`@Q=_\x82>=\x81\xFD[PP_Q=\x91P\x81\x15a\x15\xF8W\x80`\x01\x14\x15a\x16\x05V[`\x01`\x01`\xA0\x1B\x03\x84\x16;\x15[\x15a\x15=W`@QcRt\xAF\xE7`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x85\x16`\x04\x82\x01R`$\x01a\x05\xFFV[_\x83G\x10\x15a\x16YW`@Qc\xCFG\x91\x81`\xE0\x1B\x81RG`\x04\x82\x01R`$\x81\x01\x85\x90R`D\x01a\x05\xFFV[\x81Q_\x03a\x16zW`@Qc\x13(\x92w`\xE2\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x82\x82Q` \x84\x01\x86\xF5\x90P=\x15\x19\x81\x15\x16\x15a\x16\x9BW`@Q=_\x82>=\x81\xFD[`\x01`\x01`\xA0\x1B\x03\x81\x16a\x07\x95W`@Qc\xB0n\xBF=`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80T`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\x01`\x01`\xA0\x1B\x03\x19\x83\x16\x81\x17\x84U`@Q\x91\x90\x92\x16\x92\x83\x91\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0\x91\x90\xA3PPV[_`@Q\x83`@\x82\x01R\x84` \x82\x01R\x82\x81R`\x0B\x81\x01\x90P`\xFF\x81S`U\x90 `\x01`\x01`\xA0\x1B\x03\x16\x94\x93PPPPV[a\x03\xCF\x80a\x1F\xB7\x839\x01\x90V[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x05JW__\xFD[__\x83`\x1F\x84\x01\x12a\x17tW__\xFD[P\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x17\x8BW__\xFD[` \x83\x01\x91P\x83` \x82\x85\x01\x01\x11\x15a\x17\xA2W__\xFD[\x92P\x92\x90PV[________`\xC0\x89\x8B\x03\x12\x15a\x17\xC0W__\xFD[\x885a\x17\xCB\x81a\x17PV[\x97P` \x89\x015a\x17\xDB\x81a\x17PV[\x96P`@\x89\x015a\x17\xEB\x81a\x17PV[\x95P``\x89\x015\x94P`\x80\x89\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x18\rW__\xFD[a\x18\x19\x8B\x82\x8C\x01a\x17dV[\x90\x95P\x93PP`\xA0\x89\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x188W__\xFD[a\x18D\x8B\x82\x8C\x01a\x17dV[\x99\x9C\x98\x9BP\x96\x99P\x94\x97\x93\x96\x92\x95\x94PPPV[_` \x82\x84\x03\x12\x15a\x18hW__\xFD[\x815a\x07\x95\x81a\x17PV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@Q`\x1F\x82\x01`\x1F\x19\x16\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\x18\xB0Wa\x18\xB0a\x18sV[`@R\x91\x90PV[_``\x82\x84\x03\x12\x80\x15a\x18\xC9W__\xFD[P`@Q``\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\x18\xEDWa\x18\xEDa\x18sV[`@R\x825a\x18\xFB\x81a\x17PV[\x81R` \x83\x81\x015\x90\x82\x01R`@\x92\x83\x015\x92\x81\x01\x92\x90\x92RP\x91\x90PV[___``\x84\x86\x03\x12\x15a\x19,W__\xFD[\x835a\x197\x81a\x17PV[\x95` \x85\x015\x95P`@\x90\x94\x015\x93\x92PPPV[_\x81Q\x80\x84R\x80` \x84\x01` \x86\x01^_` \x82\x86\x01\x01R` `\x1F\x19`\x1F\x83\x01\x16\x85\x01\x01\x91PP\x92\x91PPV[` \x81R_a\x07\x95` \x83\x01\x84a\x19LV[___``\x84\x86\x03\x12\x15a\x19\x9EW__\xFD[\x835\x92P` \x84\x015a\x19\xB0\x81a\x17PV[\x92\x95\x92\x94PPP`@\x91\x90\x91\x015\x90V[_\x82`\x1F\x83\x01\x12a\x19\xD0W__\xFD[\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x19\xEAWa\x19\xEAa\x18sV[\x80`\x05\x1Ba\x19\xFA` \x82\x01a\x18\x87V[\x91\x82R` \x81\x85\x01\x81\x01\x92\x90\x81\x01\x90\x86\x84\x11\x15a\x1A\x15W__\xFD[` \x86\x01\x92P[\x83\x83\x10\x15a\nQW\x825a\x1A/\x81a\x17PV[\x82R` \x92\x83\x01\x92\x90\x91\x01\x90a\x1A\x1CV[___``\x84\x86\x03\x12\x15a\x1ARW__\xFD[\x835\x92P` \x84\x015\x91P`@\x84\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1AvW__\xFD[a\x1A\x82\x86\x82\x87\x01a\x19\xC1V[\x91PP\x92P\x92P\x92V[__`@\x83\x85\x03\x12\x15a\x1A\x9DW__\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1A\xB3W__\xFD[a\x1A\xBF\x85\x82\x86\x01a\x19\xC1V[\x95` \x94\x90\x94\x015\x94PPPPV[____`\x80\x85\x87\x03\x12\x15a\x1A\xE1W__\xFD[\x845a\x1A\xEC\x81a\x17PV[\x93P` \x85\x015\x92P`@\x85\x015a\x1B\x03\x81a\x17PV[\x93\x96\x92\x95P\x92\x93``\x015\x92PPV[_`\x80\x82\x84\x03\x12\x80\x15a\x1B$W__\xFD[P`@Q`\x80\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\x1BHWa\x1BHa\x18sV[`@R\x825a\x1BV\x81a\x17PV[\x81R` \x83\x015a\x1Bf\x81a\x17PV[` \x82\x01R`@\x83\x015a\x1By\x81a\x17PV[`@\x82\x01R``\x83\x015a\x1B\x8C\x81a\x17PV[``\x82\x01R\x93\x92PPPV[____`\x80\x85\x87\x03\x12\x15a\x1B\xABW__\xFD[\x845\x93P` \x85\x015\x92P`@\x85\x015\x91P``\x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1B\xD6W__\xFD[a\x1B\xE2\x87\x82\x88\x01a\x19\xC1V[\x91PP\x92\x95\x91\x94P\x92PV[_` \x82\x84\x03\x12\x15a\x1B\xFEW__\xFD[PQ\x91\x90PV[`\x01`\x01`\xA0\x1B\x03\x83\x16\x81R`@` \x82\x01\x81\x90R_\x90a\x1C(\x90\x83\x01\x84a\x19LV[\x94\x93PPPPV[_\x81Q\x80` \x84\x01\x85^_\x93\x01\x92\x83RP\x90\x91\x90PV[_a\x1C(a\x1CU\x83\x86a\x1C0V[\x84a\x1C0V[_\x81Q\x80\x84R` \x84\x01\x93P` \x83\x01_[\x82\x81\x10\x15a\x1C\x94W\x81Q`\x01`\x01`\xA0\x1B\x03\x16\x86R` \x95\x86\x01\x95\x90\x91\x01\x90`\x01\x01a\x1CmV[P\x93\x94\x93PPPPV[a\x01\0\x81R_a\x1C\xB2a\x01\0\x83\x01\x8Aa\x1C[V[`\xFF\x98\x89\x16` \x84\x81\x01\x91\x90\x91R`\x01`\x01`\xA0\x1B\x03\x98\x89\x16`@\x80\x86\x01\x91\x90\x91R\x84\x83\x03``\x86\x01R`\x01\x83R_\x91\x83\x01\x91\x90\x91R\x96\x88\x16`\x80\x84\x01R\x94\x87\x16`\xA0\x83\x01RP\x91\x90\x95\x16`\xC0\x82\x01R\x93\x90\x92\x16`\xE0\x90\x93\x01\x92\x90\x92R\x01\x91\x90PV[_` \x82\x84\x03\x12\x15a\x1D%W__\xFD[\x81Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1D;W__\xFD[\x82\x01`\x1F\x81\x01\x84\x13a\x1DKW__\xFD[\x80Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1DeWa\x1Dea\x18sV[a\x1Dx`\x1F\x82\x01`\x1F\x19\x16` \x01a\x18\x87V[\x81\x81R\x85` \x83\x85\x01\x01\x11\x15a\x1D\x8CW__\xFD[\x81` \x84\x01` \x83\x01^_\x91\x81\x01` \x01\x91\x90\x91R\x94\x93PPPPV[_a\x1D\xB4\x82\x85a\x1C0V[\x92\x83RPP` \x01\x91\x90PV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[\x81\x81\x03\x81\x81\x11\x15a\n\x03WcNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[` \x81R_a\x07\x95` \x83\x01\x84a\x1C[V[`\x01`\x01`\xA0\x1B\x03\x84\x16\x81R``` \x82\x01\x81\x90R_\x90a\x1E)\x90\x83\x01\x85a\x19LV[\x90P\x82`@\x83\x01R\x94\x93PPPPV[_` \x82\x84\x03\x12\x15a\x1EIW__\xFD[\x81Qa\x07\x95\x81a\x17PV[\x80T_\x90`\x01\x81\x81\x1C\x90\x82\x16\x80a\x1ElW`\x7F\x82\x16\x91P[` \x82\x10\x81\x03a\x1E\x8AWcNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x81\x86R` \x86\x01\x81\x80\x15a\x1E\xA5W`\x01\x81\x14a\x1E\xBBWa\x1E\xE7V[`\xFF\x19\x85\x16\x82R\x83\x15\x15`\x05\x1B\x82\x01\x95Pa\x1E\xE7V[_\x87\x81R` \x90 _[\x85\x81\x10\x15a\x1E\xE1W\x81T\x84\x82\x01R`\x01\x90\x91\x01\x90` \x01a\x1E\xC5V[\x83\x01\x96PP[PPPPP\x92\x91PPV[`\x01\x80`\xA0\x1B\x03\x8B\x16\x81R\x89` \x82\x01Ra\x01@`@\x82\x01R_a\x1F\x1Aa\x01@\x83\x01\x8Ba\x19LV[`\x02\x8A\x10a\x1F6WcNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[\x89``\x84\x01R\x88`\x80\x84\x01R\x87`\xA0\x84\x01R\x86`\xC0\x84\x01Ra\x1Fc`\xE0\x84\x01\x87`\x01`\x01`\xA0\x1B\x03\x16\x90RV[`\x01`\x01`\xA0\x1B\x03\x85\x16a\x01\0\x84\x01R\x82\x81\x03a\x01 \x84\x01Ra\x1F\x86\x81\x85a\x1ETV[\x9D\x9CPPPPPPPPPPPPPV[_` \x82\x84\x03\x12\x15a\x1F\xA7W__\xFD[\x81Q\x80\x15\x15\x81\x14a\x07\x95W__\xFD\xFE`\x80`@R`@Qa\x03\xCF8\x03\x80a\x03\xCF\x839\x81\x01`@\x81\x90Ra\0\"\x91a\x02;V[a\0,\x82\x82a\x003V[PPa\x03 V[a\0<\x82a\0\x91V[`@Q`\x01`\x01`\xA0\x1B\x03\x83\x16\x90\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;\x90_\x90\xA2\x80Q\x15a\0\x85Wa\0\x80\x82\x82a\x01\x0CV[PPPV[a\0\x8Da\x01\x7FV[PPV[\x80`\x01`\x01`\xA0\x1B\x03\x16;_\x03a\0\xCBW`@QcL\x9C\x8C\xE3`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x82\x16`\x04\x82\x01R`$\x01[`@Q\x80\x91\x03\x90\xFD[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16\x91\x90\x91\x17\x90UV[``__\x84`\x01`\x01`\xA0\x1B\x03\x16\x84`@Qa\x01(\x91\x90a\x03\nV[_`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80_\x81\x14a\x01`W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\x01eV[``\x91P[P\x90\x92P\x90Pa\x01v\x85\x83\x83a\x01\xA0V[\x95\x94PPPPPV[4\x15a\x01\x9EW`@Qc\xB3\x98\x97\x9F`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[``\x82a\x01\xB5Wa\x01\xB0\x82a\x01\xFFV[a\x01\xF8V[\x81Q\x15\x80\x15a\x01\xCCWP`\x01`\x01`\xA0\x1B\x03\x84\x16;\x15[\x15a\x01\xF5W`@Qc\x99\x96\xB3\x15`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x85\x16`\x04\x82\x01R`$\x01a\0\xC2V[P\x80[\x93\x92PPPV[\x80Q\x15a\x02\x0EW\x80Q` \x82\x01\xFD[`@Qc\xD6\xBD\xA2u`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[__`@\x83\x85\x03\x12\x15a\x02LW__\xFD[\x82Q`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x02bW__\xFD[` \x84\x01Q\x90\x92P`\x01`\x01`@\x1B\x03\x81\x11\x15a\x02}W__\xFD[\x83\x01`\x1F\x81\x01\x85\x13a\x02\x8DW__\xFD[\x80Q`\x01`\x01`@\x1B\x03\x81\x11\x15a\x02\xA6Wa\x02\xA6a\x02'V[`@Q`\x1F\x82\x01`\x1F\x19\x90\x81\x16`?\x01\x16\x81\x01`\x01`\x01`@\x1B\x03\x81\x11\x82\x82\x10\x17\x15a\x02\xD4Wa\x02\xD4a\x02'V[`@R\x81\x81R\x82\x82\x01` \x01\x87\x10\x15a\x02\xEBW__\xFD[\x81` \x84\x01` \x83\x01^_` \x83\x83\x01\x01R\x80\x93PPPP\x92P\x92\x90PV[_\x82Q\x80` \x85\x01\x84^_\x92\x01\x91\x82RP\x91\x90PV[`\xA3\x80a\x03,_9_\xF3\xFE`\x80`@R`\n`\x0CV[\0[`\x18`\x14`\x1AV[`PV[V[_`K\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCT`\x01`\x01`\xA0\x1B\x03\x16\x90V[\x90P\x90V[6__7__6_\x84Z\xF4=__>\x80\x80\x15`iW=_\xF3[=_\xFD\xFE\xA2dipfsX\"\x12 Yw5\xE3*m{\xEAl\x0B?J\xDF\xB8\xA17\xD7\x18\xBD*\x0CJ\x1E\xE1aU\xB3\0T\xD2B\xB6dsolcC\0\x08\x1E\x003\xB2\x81\xFC\x8C\x12\x95M\"TM\xB4]\xE3\x15\x9A9'(\x95\xB1i\xA8R\xB3\x14\xF9\xCCv.D\xC5;\xA2dipfsX\"\x12 \xCE5}o\xCF\xD0\x96\xB7\xE8M\xFE\x1F\xE6!s\xF2e\xB1\xED\x15\x06\x989\xDB\xAB\x03\xDA\xD5\xB9\x98\x8B\xFDdsolcC\0\x08\x1E\x003",
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct HoprNetwork { address tokenAddress; uint256 defaultTokenAllowance; bytes32 defaultAnnouncementTarget; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct HoprNetwork {
        #[allow(missing_docs)]
        pub tokenAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub defaultTokenAllowance: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub defaultAnnouncementTarget: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<HoprNetwork> for UnderlyingRustTuple<'_> {
            fn from(value: HoprNetwork) -> Self {
                (
                    value.tokenAddress,
                    value.defaultTokenAllowance,
                    value.defaultAnnouncementTarget,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for HoprNetwork {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    tokenAddress: tuple.0,
                    defaultTokenAllowance: tuple.1,
                    defaultAnnouncementTarget: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for HoprNetwork {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for HoprNetwork {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.tokenAddress,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.defaultTokenAllowance,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.defaultAnnouncementTarget,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for HoprNetwork {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for HoprNetwork {
            const NAME: &'static str = "HoprNetwork";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "HoprNetwork(address tokenAddress,uint256 defaultTokenAllowance,bytes32 defaultAnnouncementTarget)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.tokenAddress,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.defaultTokenAllowance,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.defaultAnnouncementTarget,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for HoprNetwork {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.tokenAddress,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.defaultTokenAllowance,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.defaultAnnouncementTarget,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.tokenAddress,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.defaultTokenAllowance,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.defaultAnnouncementTarget,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct SafeLibAddress { address safeAddress; address safeProxyFactoryAddress; address fallbackHandlerAddress; address multiSendAddress; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SafeLibAddress {
        #[allow(missing_docs)]
        pub safeAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub safeProxyFactoryAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub fallbackHandlerAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub multiSendAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SafeLibAddress> for UnderlyingRustTuple<'_> {
            fn from(value: SafeLibAddress) -> Self {
                (
                    value.safeAddress,
                    value.safeProxyFactoryAddress,
                    value.fallbackHandlerAddress,
                    value.multiSendAddress,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for SafeLibAddress {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    safeAddress: tuple.0,
                    safeProxyFactoryAddress: tuple.1,
                    fallbackHandlerAddress: tuple.2,
                    multiSendAddress: tuple.3,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for SafeLibAddress {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for SafeLibAddress {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.safeAddress,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.safeProxyFactoryAddress,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.fallbackHandlerAddress,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.multiSendAddress,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for SafeLibAddress {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for SafeLibAddress {
            const NAME: &'static str = "SafeLibAddress";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "SafeLibAddress(address safeAddress,address safeProxyFactoryAddress,address fallbackHandlerAddress,address multiSendAddress)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.safeAddress,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.safeProxyFactoryAddress,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.fallbackHandlerAddress,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.multiSendAddress,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for SafeLibAddress {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.safeAddress,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.safeProxyFactoryAddress,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.fallbackHandlerAddress,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.multiSendAddress,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.safeAddress,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.safeProxyFactoryAddress,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.fallbackHandlerAddress,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.multiSendAddress,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `Create2EmptyBytecode()` and selector `0x4ca249dc`.
```solidity
error Create2EmptyBytecode();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Create2EmptyBytecode;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Create2EmptyBytecode> for UnderlyingRustTuple<'_> {
            fn from(value: Create2EmptyBytecode) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Create2EmptyBytecode {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for Create2EmptyBytecode {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "Create2EmptyBytecode()";
            const SELECTOR: [u8; 4] = [76u8, 162u8, 73u8, 220u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `FailedDeployment()` and selector `0xb06ebf3d`.
```solidity
error FailedDeployment();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct FailedDeployment;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<FailedDeployment> for UnderlyingRustTuple<'_> {
            fn from(value: FailedDeployment) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for FailedDeployment {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for FailedDeployment {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "FailedDeployment()";
            const SELECTOR: [u8; 4] = [176u8, 110u8, 191u8, 61u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InsufficientBalance(uint256,uint256)` and selector `0xcf479181`.
```solidity
error InsufficientBalance(uint256 balance, uint256 needed);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientBalance {
        #[allow(missing_docs)]
        pub balance: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub needed: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientBalance> for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientBalance) -> Self {
                (value.balance, value.needed)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InsufficientBalance {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    balance: tuple.0,
                    needed: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientBalance {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientBalance(uint256,uint256)";
            const SELECTOR: [u8; 4] = [207u8, 71u8, 145u8, 129u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.balance),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.needed),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidFunctionSelector()` and selector `0x42868c9b`.
```solidity
error InvalidFunctionSelector();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidFunctionSelector;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidFunctionSelector> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidFunctionSelector) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidFunctionSelector {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidFunctionSelector {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidFunctionSelector()";
            const SELECTOR: [u8; 4] = [66u8, 134u8, 140u8, 155u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidOwner()` and selector `0x49e27cff`.
```solidity
error InvalidOwner();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidOwner;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidOwner> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidOwner) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidOwner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidOwner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidOwner()";
            const SELECTOR: [u8; 4] = [73u8, 226u8, 124u8, 255u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotTokenRecipient()` and selector `0x720773f2`.
```solidity
error NotTokenRecipient();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotTokenRecipient;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotTokenRecipient> for UnderlyingRustTuple<'_> {
            fn from(value: NotTokenRecipient) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotTokenRecipient {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotTokenRecipient {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotTokenRecipient()";
            const SELECTOR: [u8; 4] = [114u8, 7u8, 115u8, 242u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `OwnableInvalidOwner(address)` and selector `0x1e4fbdf7`.
```solidity
error OwnableInvalidOwner(address owner);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OwnableInvalidOwner {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OwnableInvalidOwner> for UnderlyingRustTuple<'_> {
            fn from(value: OwnableInvalidOwner) -> Self {
                (value.owner,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for OwnableInvalidOwner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { owner: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OwnableInvalidOwner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OwnableInvalidOwner(address)";
            const SELECTOR: [u8; 4] = [30u8, 79u8, 189u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `OwnableUnauthorizedAccount(address)` and selector `0x118cdaa7`.
```solidity
error OwnableUnauthorizedAccount(address account);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OwnableUnauthorizedAccount {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OwnableUnauthorizedAccount>
        for UnderlyingRustTuple<'_> {
            fn from(value: OwnableUnauthorizedAccount) -> Self {
                (value.account,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for OwnableUnauthorizedAccount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { account: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OwnableUnauthorizedAccount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OwnableUnauthorizedAccount(address)";
            const SELECTOR: [u8; 4] = [17u8, 140u8, 218u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `SafeERC20FailedOperation(address)` and selector `0x5274afe7`.
```solidity
error SafeERC20FailedOperation(address token);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SafeERC20FailedOperation {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SafeERC20FailedOperation>
        for UnderlyingRustTuple<'_> {
            fn from(value: SafeERC20FailedOperation) -> Self {
                (value.token,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SafeERC20FailedOperation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { token: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SafeERC20FailedOperation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SafeERC20FailedOperation(address)";
            const SELECTOR: [u8; 4] = [82u8, 116u8, 175u8, 231u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `TooFewOwners()` and selector `0x0d7fd1aa`.
```solidity
error TooFewOwners();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TooFewOwners;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<TooFewOwners> for UnderlyingRustTuple<'_> {
            fn from(value: TooFewOwners) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for TooFewOwners {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for TooFewOwners {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TooFewOwners()";
            const SELECTOR: [u8; 4] = [13u8, 127u8, 209u8, 170u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UnauthorizedToken()` and selector `0x7e5f9349`.
```solidity
error UnauthorizedToken();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UnauthorizedToken;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnauthorizedToken> for UnderlyingRustTuple<'_> {
            fn from(value: UnauthorizedToken) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for UnauthorizedToken {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UnauthorizedToken {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UnauthorizedToken()";
            const SELECTOR: [u8; 4] = [126u8, 95u8, 147u8, 73u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `HoprNodeStakeHoprNetworkUpdated((address,uint256,bytes32))` and selector `0x54cfcf4bdb6f20632ba544cd684130fc9db4dc2fe6360926d6b7866297f0315e`.
```solidity
event HoprNodeStakeHoprNetworkUpdated(HoprNetwork hoprNetwork);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct HoprNodeStakeHoprNetworkUpdated {
        #[allow(missing_docs)]
        pub hoprNetwork: <HoprNetwork as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for HoprNodeStakeHoprNetworkUpdated {
            type DataTuple<'a> = (HoprNetwork,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "HoprNodeStakeHoprNetworkUpdated((address,uint256,bytes32))";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                84u8, 207u8, 207u8, 75u8, 219u8, 111u8, 32u8, 99u8, 43u8, 165u8, 68u8,
                205u8, 104u8, 65u8, 48u8, 252u8, 157u8, 180u8, 220u8, 47u8, 230u8, 54u8,
                9u8, 38u8, 214u8, 183u8, 134u8, 98u8, 151u8, 240u8, 49u8, 94u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { hoprNetwork: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (<HoprNetwork as alloy_sol_types::SolType>::tokenize(&self.hoprNetwork),)
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for HoprNodeStakeHoprNetworkUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&HoprNodeStakeHoprNetworkUpdated>
        for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &HoprNodeStakeHoprNetworkUpdated,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `HoprNodeStakeModuleUpdated(address)` and selector `0xdd60725a88508fe2dcb769bd824280a2a01356198c795515d175abc4bc40b74e`.
```solidity
event HoprNodeStakeModuleUpdated(address moduleImplementation);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct HoprNodeStakeModuleUpdated {
        #[allow(missing_docs)]
        pub moduleImplementation: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for HoprNodeStakeModuleUpdated {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "HoprNodeStakeModuleUpdated(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                221u8, 96u8, 114u8, 90u8, 136u8, 80u8, 143u8, 226u8, 220u8, 183u8, 105u8,
                189u8, 130u8, 66u8, 128u8, 162u8, 160u8, 19u8, 86u8, 25u8, 140u8, 121u8,
                85u8, 21u8, 209u8, 117u8, 171u8, 196u8, 188u8, 64u8, 183u8, 78u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    moduleImplementation: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.moduleImplementation,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for HoprNodeStakeModuleUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&HoprNodeStakeModuleUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &HoprNodeStakeModuleUpdated,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `HoprNodeStakeSafeLibUpdated((address,address,address,address))` and selector `0x87eb507b2b42eb659807d7a1f63c89b8e22c674689603eac07a3713f06fec9c3`.
```solidity
event HoprNodeStakeSafeLibUpdated(SafeLibAddress safeLibAddresses);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct HoprNodeStakeSafeLibUpdated {
        #[allow(missing_docs)]
        pub safeLibAddresses: <SafeLibAddress as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for HoprNodeStakeSafeLibUpdated {
            type DataTuple<'a> = (SafeLibAddress,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "HoprNodeStakeSafeLibUpdated((address,address,address,address))";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                135u8, 235u8, 80u8, 123u8, 43u8, 66u8, 235u8, 101u8, 152u8, 7u8, 215u8,
                161u8, 246u8, 60u8, 137u8, 184u8, 226u8, 44u8, 103u8, 70u8, 137u8, 96u8,
                62u8, 172u8, 7u8, 163u8, 113u8, 63u8, 6u8, 254u8, 201u8, 195u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { safeLibAddresses: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <SafeLibAddress as alloy_sol_types::SolType>::tokenize(
                        &self.safeLibAddresses,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for HoprNodeStakeSafeLibUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&HoprNodeStakeSafeLibUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &HoprNodeStakeSafeLibUpdated,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `NewHoprNodeStakeModule(address)` and selector `0xf966ce717349a940e403b8faae71fdaf573d8b9847deea16fca3d870cf6c292d`.
```solidity
event NewHoprNodeStakeModule(address instance);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct NewHoprNodeStakeModule {
        #[allow(missing_docs)]
        pub instance: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for NewHoprNodeStakeModule {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "NewHoprNodeStakeModule(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                249u8, 102u8, 206u8, 113u8, 115u8, 73u8, 169u8, 64u8, 228u8, 3u8, 184u8,
                250u8, 174u8, 113u8, 253u8, 175u8, 87u8, 61u8, 139u8, 152u8, 71u8, 222u8,
                234u8, 22u8, 252u8, 163u8, 216u8, 112u8, 207u8, 108u8, 41u8, 45u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { instance: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.instance,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for NewHoprNodeStakeModule {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&NewHoprNodeStakeModule> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &NewHoprNodeStakeModule) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `NewHoprNodeStakeModuleForSafe(address,address)` and selector `0x83a5c31bfee49d254d95e3946d8e8434e5975382fa8b849182db9e251aaaaa26`.
```solidity
event NewHoprNodeStakeModuleForSafe(address module, address safe);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct NewHoprNodeStakeModuleForSafe {
        #[allow(missing_docs)]
        pub module: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub safe: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for NewHoprNodeStakeModuleForSafe {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "NewHoprNodeStakeModuleForSafe(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                131u8, 165u8, 195u8, 27u8, 254u8, 228u8, 157u8, 37u8, 77u8, 149u8, 227u8,
                148u8, 109u8, 142u8, 132u8, 52u8, 229u8, 151u8, 83u8, 130u8, 250u8,
                139u8, 132u8, 145u8, 130u8, 219u8, 158u8, 37u8, 26u8, 170u8, 170u8, 38u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    module: data.0,
                    safe: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.module,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.safe,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for NewHoprNodeStakeModuleForSafe {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&NewHoprNodeStakeModuleForSafe> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &NewHoprNodeStakeModuleForSafe,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `NewHoprNodeStakeSafe(address)` and selector `0x8231d169f416b666ae7fa43faa24a18899738075a53f32c97617d173b189e386`.
```solidity
event NewHoprNodeStakeSafe(address instance);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct NewHoprNodeStakeSafe {
        #[allow(missing_docs)]
        pub instance: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for NewHoprNodeStakeSafe {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "NewHoprNodeStakeSafe(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                130u8, 49u8, 209u8, 105u8, 244u8, 22u8, 182u8, 102u8, 174u8, 127u8,
                164u8, 63u8, 170u8, 36u8, 161u8, 136u8, 153u8, 115u8, 128u8, 117u8,
                165u8, 63u8, 50u8, 201u8, 118u8, 23u8, 209u8, 115u8, 177u8, 137u8, 227u8,
                134u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { instance: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.instance,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for NewHoprNodeStakeSafe {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&NewHoprNodeStakeSafe> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &NewHoprNodeStakeSafe) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `OwnershipTransferStarted(address,address)` and selector `0x38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e22700`.
```solidity
event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OwnershipTransferStarted {
        #[allow(missing_docs)]
        pub previousOwner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OwnershipTransferStarted {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OwnershipTransferStarted(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                56u8, 209u8, 107u8, 140u8, 172u8, 34u8, 217u8, 159u8, 199u8, 193u8, 36u8,
                185u8, 205u8, 13u8, 226u8, 211u8, 250u8, 31u8, 174u8, 244u8, 32u8, 191u8,
                231u8, 145u8, 216u8, 195u8, 98u8, 215u8, 101u8, 226u8, 39u8, 0u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    previousOwner: topics.1,
                    newOwner: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.previousOwner.clone(),
                    self.newOwner.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.previousOwner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newOwner,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OwnershipTransferStarted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OwnershipTransferStarted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &OwnershipTransferStarted,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `OwnershipTransferred(address,address)` and selector `0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0`.
```solidity
event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OwnershipTransferred {
        #[allow(missing_docs)]
        pub previousOwner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OwnershipTransferred {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OwnershipTransferred(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                139u8, 224u8, 7u8, 156u8, 83u8, 22u8, 89u8, 20u8, 19u8, 68u8, 205u8,
                31u8, 208u8, 164u8, 242u8, 132u8, 25u8, 73u8, 127u8, 151u8, 34u8, 163u8,
                218u8, 175u8, 227u8, 180u8, 24u8, 111u8, 107u8, 100u8, 87u8, 224u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    previousOwner: topics.1,
                    newOwner: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.previousOwner.clone(),
                    self.newOwner.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.previousOwner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newOwner,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OwnershipTransferred {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OwnershipTransferred> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OwnershipTransferred) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(address _moduleSingletonAddress, address _announcementAddress, address initialOwner);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub _moduleSingletonAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _announcementAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub initialOwner: alloy::sol_types::private::Address,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (
                        value._moduleSingletonAddress,
                        value._announcementAddress,
                        value.initialOwner,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _moduleSingletonAddress: tuple.0,
                        _announcementAddress: tuple.1,
                        initialOwner: tuple.2,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._moduleSingletonAddress,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._announcementAddress,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.initialOwner,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `DEPLOYSAFEANDMODULEANDINCLUDENODES_IDENTIFIER()` and selector `0xf8ffe3c0`.
```solidity
function DEPLOYSAFEANDMODULEANDINCLUDENODES_IDENTIFIER() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEPLOYSAFEANDMODULEANDINCLUDENODES_IDENTIFIERCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`DEPLOYSAFEANDMODULEANDINCLUDENODES_IDENTIFIER()`](DEPLOYSAFEANDMODULEANDINCLUDENODES_IDENTIFIERCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEPLOYSAFEANDMODULEANDINCLUDENODES_IDENTIFIERReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEPLOYSAFEANDMODULEANDINCLUDENODES_IDENTIFIERCall>
            for UnderlyingRustTuple<'_> {
                fn from(
                    value: DEPLOYSAFEANDMODULEANDINCLUDENODES_IDENTIFIERCall,
                ) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEPLOYSAFEANDMODULEANDINCLUDENODES_IDENTIFIERCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<
                DEPLOYSAFEANDMODULEANDINCLUDENODES_IDENTIFIERReturn,
            > for UnderlyingRustTuple<'_> {
                fn from(
                    value: DEPLOYSAFEANDMODULEANDINCLUDENODES_IDENTIFIERReturn,
                ) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEPLOYSAFEANDMODULEANDINCLUDENODES_IDENTIFIERReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall
        for DEPLOYSAFEANDMODULEANDINCLUDENODES_IDENTIFIERCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DEPLOYSAFEANDMODULEANDINCLUDENODES_IDENTIFIER()";
            const SELECTOR: [u8; 4] = [248u8, 255u8, 227u8, 192u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: DEPLOYSAFEANDMODULEANDINCLUDENODES_IDENTIFIERReturn = r
                            .into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: DEPLOYSAFEANDMODULEANDINCLUDENODES_IDENTIFIERReturn = r
                            .into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `DEPLOYSAFEMODULE_FUNCTION_IDENTIFIER()` and selector `0x63f17ff9`.
```solidity
function DEPLOYSAFEMODULE_FUNCTION_IDENTIFIER() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEPLOYSAFEMODULE_FUNCTION_IDENTIFIERCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`DEPLOYSAFEMODULE_FUNCTION_IDENTIFIER()`](DEPLOYSAFEMODULE_FUNCTION_IDENTIFIERCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEPLOYSAFEMODULE_FUNCTION_IDENTIFIERReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEPLOYSAFEMODULE_FUNCTION_IDENTIFIERCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEPLOYSAFEMODULE_FUNCTION_IDENTIFIERCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEPLOYSAFEMODULE_FUNCTION_IDENTIFIERCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEPLOYSAFEMODULE_FUNCTION_IDENTIFIERReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEPLOYSAFEMODULE_FUNCTION_IDENTIFIERReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEPLOYSAFEMODULE_FUNCTION_IDENTIFIERReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DEPLOYSAFEMODULE_FUNCTION_IDENTIFIERCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DEPLOYSAFEMODULE_FUNCTION_IDENTIFIER()";
            const SELECTOR: [u8; 4] = [99u8, 241u8, 127u8, 249u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: DEPLOYSAFEMODULE_FUNCTION_IDENTIFIERReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: DEPLOYSAFEMODULE_FUNCTION_IDENTIFIERReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `TOKENS_RECIPIENT_INTERFACE_HASH()` and selector `0x72581cc0`.
```solidity
function TOKENS_RECIPIENT_INTERFACE_HASH() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TOKENS_RECIPIENT_INTERFACE_HASHCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`TOKENS_RECIPIENT_INTERFACE_HASH()`](TOKENS_RECIPIENT_INTERFACE_HASHCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TOKENS_RECIPIENT_INTERFACE_HASHReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TOKENS_RECIPIENT_INTERFACE_HASHCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: TOKENS_RECIPIENT_INTERFACE_HASHCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for TOKENS_RECIPIENT_INTERFACE_HASHCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TOKENS_RECIPIENT_INTERFACE_HASHReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: TOKENS_RECIPIENT_INTERFACE_HASHReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for TOKENS_RECIPIENT_INTERFACE_HASHReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for TOKENS_RECIPIENT_INTERFACE_HASHCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TOKENS_RECIPIENT_INTERFACE_HASH()";
            const SELECTOR: [u8; 4] = [114u8, 88u8, 28u8, 192u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: TOKENS_RECIPIENT_INTERFACE_HASHReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: TOKENS_RECIPIENT_INTERFACE_HASHReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `acceptOwnership()` and selector `0x79ba5097`.
```solidity
function acceptOwnership() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct acceptOwnershipCall;
    ///Container type for the return parameters of the [`acceptOwnership()`](acceptOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct acceptOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<acceptOwnershipCall> for UnderlyingRustTuple<'_> {
                fn from(value: acceptOwnershipCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for acceptOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<acceptOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: acceptOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for acceptOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl acceptOwnershipReturn {
            fn _tokenize(
                &self,
            ) -> <acceptOwnershipCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for acceptOwnershipCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = acceptOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "acceptOwnership()";
            const SELECTOR: [u8; 4] = [121u8, 186u8, 80u8, 151u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                acceptOwnershipReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `clone(uint256,bytes32,address[])` and selector `0x9a94addf`.
```solidity
function clone(uint256 nonce, bytes32 defaultTarget, address[] memory admins) external returns (address, address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct cloneCall {
        #[allow(missing_docs)]
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub defaultTarget: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub admins: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`clone(uint256,bytes32,address[])`](cloneCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct cloneReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _1: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<cloneCall> for UnderlyingRustTuple<'_> {
                fn from(value: cloneCall) -> Self {
                    (value.nonce, value.defaultTarget, value.admins)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for cloneCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        nonce: tuple.0,
                        defaultTarget: tuple.1,
                        admins: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<cloneReturn> for UnderlyingRustTuple<'_> {
                fn from(value: cloneReturn) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for cloneReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0, _1: tuple.1 }
                }
            }
        }
        impl cloneReturn {
            fn _tokenize(
                &self,
            ) -> <cloneCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._1,
                    ),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for cloneCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = cloneReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "clone(uint256,bytes32,address[])";
            const SELECTOR: [u8; 4] = [154u8, 148u8, 173u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.defaultTarget),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.admins),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                cloneReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `defaultHoprNetwork()` and selector `0xa7a6e4b8`.
```solidity
function defaultHoprNetwork() external view returns (address tokenAddress, uint256 defaultTokenAllowance, bytes32 defaultAnnouncementTarget);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct defaultHoprNetworkCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`defaultHoprNetwork()`](defaultHoprNetworkCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct defaultHoprNetworkReturn {
        #[allow(missing_docs)]
        pub tokenAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub defaultTokenAllowance: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub defaultAnnouncementTarget: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<defaultHoprNetworkCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: defaultHoprNetworkCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for defaultHoprNetworkCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<defaultHoprNetworkReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: defaultHoprNetworkReturn) -> Self {
                    (
                        value.tokenAddress,
                        value.defaultTokenAllowance,
                        value.defaultAnnouncementTarget,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for defaultHoprNetworkReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        tokenAddress: tuple.0,
                        defaultTokenAllowance: tuple.1,
                        defaultAnnouncementTarget: tuple.2,
                    }
                }
            }
        }
        impl defaultHoprNetworkReturn {
            fn _tokenize(
                &self,
            ) -> <defaultHoprNetworkCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.tokenAddress,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.defaultTokenAllowance,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.defaultAnnouncementTarget,
                    ),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for defaultHoprNetworkCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = defaultHoprNetworkReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "defaultHoprNetwork()";
            const SELECTOR: [u8; 4] = [167u8, 166u8, 228u8, 184u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                defaultHoprNetworkReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `deployModule(address,bytes32,uint256)` and selector `0x696ab635`.
```solidity
function deployModule(address safeProxyAddr, bytes32 defaultTarget, uint256 nonce) external returns (address moduleProxy);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct deployModuleCall {
        #[allow(missing_docs)]
        pub safeProxyAddr: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub defaultTarget: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`deployModule(address,bytes32,uint256)`](deployModuleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct deployModuleReturn {
        #[allow(missing_docs)]
        pub moduleProxy: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<deployModuleCall> for UnderlyingRustTuple<'_> {
                fn from(value: deployModuleCall) -> Self {
                    (value.safeProxyAddr, value.defaultTarget, value.nonce)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for deployModuleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        safeProxyAddr: tuple.0,
                        defaultTarget: tuple.1,
                        nonce: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<deployModuleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: deployModuleReturn) -> Self {
                    (value.moduleProxy,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for deployModuleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { moduleProxy: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for deployModuleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "deployModule(address,bytes32,uint256)";
            const SELECTOR: [u8; 4] = [105u8, 106u8, 182u8, 53u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.safeProxyAddr,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.defaultTarget),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: deployModuleReturn = r.into();
                        r.moduleProxy
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: deployModuleReturn = r.into();
                        r.moduleProxy
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `moduleSingletonAddress()` and selector `0x9aef1ed9`.
```solidity
function moduleSingletonAddress() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct moduleSingletonAddressCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`moduleSingletonAddress()`](moduleSingletonAddressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct moduleSingletonAddressReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<moduleSingletonAddressCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: moduleSingletonAddressCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for moduleSingletonAddressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<moduleSingletonAddressReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: moduleSingletonAddressReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for moduleSingletonAddressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for moduleSingletonAddressCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "moduleSingletonAddress()";
            const SELECTOR: [u8; 4] = [154u8, 239u8, 30u8, 217u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: moduleSingletonAddressReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: moduleSingletonAddressReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `owner()` and selector `0x8da5cb5b`.
```solidity
function owner() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`owner()`](ownerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerCall> for UnderlyingRustTuple<'_> {
                fn from(value: ownerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ownerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ownerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "owner()";
            const SELECTOR: [u8; 4] = [141u8, 165u8, 203u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: ownerReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: ownerReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `pendingOwner()` and selector `0xe30c3978`.
```solidity
function pendingOwner() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pendingOwnerCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`pendingOwner()`](pendingOwnerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pendingOwnerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pendingOwnerCall> for UnderlyingRustTuple<'_> {
                fn from(value: pendingOwnerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pendingOwnerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pendingOwnerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pendingOwnerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pendingOwnerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pendingOwnerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pendingOwner()";
            const SELECTOR: [u8; 4] = [227u8, 12u8, 57u8, 120u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: pendingOwnerReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: pendingOwnerReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `predictModuleAddress(bytes32,address,bytes32)` and selector `0x8afc3bf5`.
```solidity
function predictModuleAddress(bytes32 salt, address safe, bytes32 defaultTarget) external view returns (address predicted);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct predictModuleAddress_0Call {
        #[allow(missing_docs)]
        pub salt: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub safe: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub defaultTarget: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`predictModuleAddress(bytes32,address,bytes32)`](predictModuleAddress_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct predictModuleAddress_0Return {
        #[allow(missing_docs)]
        pub predicted: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<predictModuleAddress_0Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: predictModuleAddress_0Call) -> Self {
                    (value.salt, value.safe, value.defaultTarget)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for predictModuleAddress_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        salt: tuple.0,
                        safe: tuple.1,
                        defaultTarget: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<predictModuleAddress_0Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: predictModuleAddress_0Return) -> Self {
                    (value.predicted,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for predictModuleAddress_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { predicted: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for predictModuleAddress_0Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "predictModuleAddress(bytes32,address,bytes32)";
            const SELECTOR: [u8; 4] = [138u8, 252u8, 59u8, 245u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.salt),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.safe,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.defaultTarget),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: predictModuleAddress_0Return = r.into();
                        r.predicted
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: predictModuleAddress_0Return = r.into();
                        r.predicted
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `predictModuleAddress(address,uint256,address,bytes32)` and selector `0xd48a66bd`.
```solidity
function predictModuleAddress(address caller, uint256 nonce, address safe, bytes32 defaultTarget) external view returns (address predicted);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct predictModuleAddress_1Call {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub safe: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub defaultTarget: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`predictModuleAddress(address,uint256,address,bytes32)`](predictModuleAddress_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct predictModuleAddress_1Return {
        #[allow(missing_docs)]
        pub predicted: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<predictModuleAddress_1Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: predictModuleAddress_1Call) -> Self {
                    (value.caller, value.nonce, value.safe, value.defaultTarget)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for predictModuleAddress_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        caller: tuple.0,
                        nonce: tuple.1,
                        safe: tuple.2,
                        defaultTarget: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<predictModuleAddress_1Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: predictModuleAddress_1Return) -> Self {
                    (value.predicted,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for predictModuleAddress_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { predicted: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for predictModuleAddress_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "predictModuleAddress(address,uint256,address,bytes32)";
            const SELECTOR: [u8; 4] = [212u8, 138u8, 102u8, 189u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.safe,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.defaultTarget),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: predictModuleAddress_1Return = r.into();
                        r.predicted
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: predictModuleAddress_1Return = r.into();
                        r.predicted
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `predictSafeAddress(address[],uint256)` and selector `0xc248a4e7`.
```solidity
function predictSafeAddress(address[] memory admins, uint256 nonce) external view returns (address predicted);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct predictSafeAddressCall {
        #[allow(missing_docs)]
        pub admins: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
        #[allow(missing_docs)]
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`predictSafeAddress(address[],uint256)`](predictSafeAddressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct predictSafeAddressReturn {
        #[allow(missing_docs)]
        pub predicted: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<predictSafeAddressCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: predictSafeAddressCall) -> Self {
                    (value.admins, value.nonce)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for predictSafeAddressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        admins: tuple.0,
                        nonce: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<predictSafeAddressReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: predictSafeAddressReturn) -> Self {
                    (value.predicted,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for predictSafeAddressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { predicted: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for predictSafeAddressCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "predictSafeAddress(address[],uint256)";
            const SELECTOR: [u8; 4] = [194u8, 72u8, 164u8, 231u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.admins),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: predictSafeAddressReturn = r.into();
                        r.predicted
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: predictSafeAddressReturn = r.into();
                        r.predicted
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `reclaimErc20(address)` and selector `0x79d101fa`.
```solidity
function reclaimErc20(address token) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct reclaimErc20Call {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`reclaimErc20(address)`](reclaimErc20Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct reclaimErc20Return {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<reclaimErc20Call> for UnderlyingRustTuple<'_> {
                fn from(value: reclaimErc20Call) -> Self {
                    (value.token,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for reclaimErc20Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { token: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<reclaimErc20Return> for UnderlyingRustTuple<'_> {
                fn from(value: reclaimErc20Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for reclaimErc20Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl reclaimErc20Return {
            fn _tokenize(
                &self,
            ) -> <reclaimErc20Call as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for reclaimErc20Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = reclaimErc20Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "reclaimErc20(address)";
            const SELECTOR: [u8; 4] = [121u8, 209u8, 1u8, 250u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                reclaimErc20Return::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `renounceOwnership()` and selector `0x715018a6`.
```solidity
function renounceOwnership() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipCall;
    ///Container type for the return parameters of the [`renounceOwnership()`](renounceOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl renounceOwnershipReturn {
            fn _tokenize(
                &self,
            ) -> <renounceOwnershipCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceOwnershipCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceOwnership()";
            const SELECTOR: [u8; 4] = [113u8, 80u8, 24u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                renounceOwnershipReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `safeLibAddresses()` and selector `0x8947890a`.
```solidity
function safeLibAddresses() external view returns (address safeAddress, address safeProxyFactoryAddress, address fallbackHandlerAddress, address multiSendAddress);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct safeLibAddressesCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`safeLibAddresses()`](safeLibAddressesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct safeLibAddressesReturn {
        #[allow(missing_docs)]
        pub safeAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub safeProxyFactoryAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub fallbackHandlerAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub multiSendAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<safeLibAddressesCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: safeLibAddressesCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for safeLibAddressesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<safeLibAddressesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: safeLibAddressesReturn) -> Self {
                    (
                        value.safeAddress,
                        value.safeProxyFactoryAddress,
                        value.fallbackHandlerAddress,
                        value.multiSendAddress,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for safeLibAddressesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        safeAddress: tuple.0,
                        safeProxyFactoryAddress: tuple.1,
                        fallbackHandlerAddress: tuple.2,
                        multiSendAddress: tuple.3,
                    }
                }
            }
        }
        impl safeLibAddressesReturn {
            fn _tokenize(
                &self,
            ) -> <safeLibAddressesCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.safeAddress,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.safeProxyFactoryAddress,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.fallbackHandlerAddress,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.multiSendAddress,
                    ),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for safeLibAddressesCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = safeLibAddressesReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "safeLibAddresses()";
            const SELECTOR: [u8; 4] = [137u8, 71u8, 137u8, 10u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                safeLibAddressesReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `safeVersion()` and selector `0x7ef2721f`.
```solidity
function safeVersion() external pure returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct safeVersionCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`safeVersion()`](safeVersionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct safeVersionReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<safeVersionCall> for UnderlyingRustTuple<'_> {
                fn from(value: safeVersionCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for safeVersionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<safeVersionReturn> for UnderlyingRustTuple<'_> {
                fn from(value: safeVersionReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for safeVersionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for safeVersionCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::String;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "safeVersion()";
            const SELECTOR: [u8; 4] = [126u8, 242u8, 114u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: safeVersionReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: safeVersionReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `tokensReceived(address,address,address,uint256,bytes,bytes)` and selector `0x0023de29`.
```solidity
function tokensReceived(address, address from, address to, uint256 amount, bytes memory userData, bytes memory) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct tokensReceivedCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub from: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub userData: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub _5: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`tokensReceived(address,address,address,uint256,bytes,bytes)`](tokensReceivedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct tokensReceivedReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<tokensReceivedCall> for UnderlyingRustTuple<'_> {
                fn from(value: tokensReceivedCall) -> Self {
                    (
                        value._0,
                        value.from,
                        value.to,
                        value.amount,
                        value.userData,
                        value._5,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for tokensReceivedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _0: tuple.0,
                        from: tuple.1,
                        to: tuple.2,
                        amount: tuple.3,
                        userData: tuple.4,
                        _5: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<tokensReceivedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: tokensReceivedReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for tokensReceivedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl tokensReceivedReturn {
            fn _tokenize(
                &self,
            ) -> <tokensReceivedCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for tokensReceivedCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = tokensReceivedReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "tokensReceived(address,address,address,uint256,bytes,bytes)";
            const SELECTOR: [u8; 4] = [0u8, 35u8, 222u8, 41u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.from,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.userData,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self._5,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                tokensReceivedReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `transferOwnership(address)` and selector `0xf2fde38b`.
```solidity
function transferOwnership(address newOwner) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipCall {
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`transferOwnership(address)`](transferOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipCall) -> Self {
                    (value.newOwner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newOwner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl transferOwnershipReturn {
            fn _tokenize(
                &self,
            ) -> <transferOwnershipCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferOwnershipCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferOwnership(address)";
            const SELECTOR: [u8; 4] = [242u8, 253u8, 227u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newOwner,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                transferOwnershipReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `updateErc1820Implementer(address)` and selector `0xabed205b`.
```solidity
function updateErc1820Implementer(address _newImplementer) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateErc1820ImplementerCall {
        #[allow(missing_docs)]
        pub _newImplementer: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`updateErc1820Implementer(address)`](updateErc1820ImplementerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateErc1820ImplementerReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateErc1820ImplementerCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateErc1820ImplementerCall) -> Self {
                    (value._newImplementer,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateErc1820ImplementerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _newImplementer: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateErc1820ImplementerReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateErc1820ImplementerReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateErc1820ImplementerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl updateErc1820ImplementerReturn {
            fn _tokenize(
                &self,
            ) -> <updateErc1820ImplementerCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateErc1820ImplementerCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateErc1820ImplementerReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateErc1820Implementer(address)";
            const SELECTOR: [u8; 4] = [171u8, 237u8, 32u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._newImplementer,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                updateErc1820ImplementerReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `updateHoprNetwork((address,uint256,bytes32))` and selector `0x32838f6b`.
```solidity
function updateHoprNetwork(HoprNetwork memory _newHoprNetwork) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateHoprNetworkCall {
        #[allow(missing_docs)]
        pub _newHoprNetwork: <HoprNetwork as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`updateHoprNetwork((address,uint256,bytes32))`](updateHoprNetworkCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateHoprNetworkReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (HoprNetwork,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <HoprNetwork as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateHoprNetworkCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateHoprNetworkCall) -> Self {
                    (value._newHoprNetwork,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateHoprNetworkCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _newHoprNetwork: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateHoprNetworkReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateHoprNetworkReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateHoprNetworkReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl updateHoprNetworkReturn {
            fn _tokenize(
                &self,
            ) -> <updateHoprNetworkCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateHoprNetworkCall {
            type Parameters<'a> = (HoprNetwork,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateHoprNetworkReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateHoprNetwork((address,uint256,bytes32))";
            const SELECTOR: [u8; 4] = [50u8, 131u8, 143u8, 107u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <HoprNetwork as alloy_sol_types::SolType>::tokenize(
                        &self._newHoprNetwork,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                updateHoprNetworkReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `updateModuleSingletonAddress(address)` and selector `0x0233296b`.
```solidity
function updateModuleSingletonAddress(address _newModuleSingletonAddress) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateModuleSingletonAddressCall {
        #[allow(missing_docs)]
        pub _newModuleSingletonAddress: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`updateModuleSingletonAddress(address)`](updateModuleSingletonAddressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateModuleSingletonAddressReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateModuleSingletonAddressCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateModuleSingletonAddressCall) -> Self {
                    (value._newModuleSingletonAddress,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateModuleSingletonAddressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _newModuleSingletonAddress: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateModuleSingletonAddressReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateModuleSingletonAddressReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateModuleSingletonAddressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl updateModuleSingletonAddressReturn {
            fn _tokenize(
                &self,
            ) -> <updateModuleSingletonAddressCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateModuleSingletonAddressCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateModuleSingletonAddressReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateModuleSingletonAddress(address)";
            const SELECTOR: [u8; 4] = [2u8, 51u8, 41u8, 107u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._newModuleSingletonAddress,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                updateModuleSingletonAddressReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `updateSafeLibAddress((address,address,address,address))` and selector `0xfa2aeab4`.
```solidity
function updateSafeLibAddress(SafeLibAddress memory _newSafeLibAddresses) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateSafeLibAddressCall {
        #[allow(missing_docs)]
        pub _newSafeLibAddresses: <SafeLibAddress as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`updateSafeLibAddress((address,address,address,address))`](updateSafeLibAddressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateSafeLibAddressReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (SafeLibAddress,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <SafeLibAddress as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateSafeLibAddressCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateSafeLibAddressCall) -> Self {
                    (value._newSafeLibAddresses,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateSafeLibAddressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _newSafeLibAddresses: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateSafeLibAddressReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateSafeLibAddressReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateSafeLibAddressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl updateSafeLibAddressReturn {
            fn _tokenize(
                &self,
            ) -> <updateSafeLibAddressCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateSafeLibAddressCall {
            type Parameters<'a> = (SafeLibAddress,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateSafeLibAddressReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateSafeLibAddress((address,address,address,address))";
            const SELECTOR: [u8; 4] = [250u8, 42u8, 234u8, 180u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <SafeLibAddress as alloy_sol_types::SolType>::tokenize(
                        &self._newSafeLibAddresses,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                updateSafeLibAddressReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`HoprNodeStakeFactory`](self) function calls.
    #[derive(Clone)]
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    pub enum HoprNodeStakeFactoryCalls {
        #[allow(missing_docs)]
        DEPLOYSAFEANDMODULEANDINCLUDENODES_IDENTIFIER(
            DEPLOYSAFEANDMODULEANDINCLUDENODES_IDENTIFIERCall,
        ),
        #[allow(missing_docs)]
        DEPLOYSAFEMODULE_FUNCTION_IDENTIFIER(DEPLOYSAFEMODULE_FUNCTION_IDENTIFIERCall),
        #[allow(missing_docs)]
        TOKENS_RECIPIENT_INTERFACE_HASH(TOKENS_RECIPIENT_INTERFACE_HASHCall),
        #[allow(missing_docs)]
        acceptOwnership(acceptOwnershipCall),
        #[allow(missing_docs)]
        clone(cloneCall),
        #[allow(missing_docs)]
        defaultHoprNetwork(defaultHoprNetworkCall),
        #[allow(missing_docs)]
        deployModule(deployModuleCall),
        #[allow(missing_docs)]
        moduleSingletonAddress(moduleSingletonAddressCall),
        #[allow(missing_docs)]
        owner(ownerCall),
        #[allow(missing_docs)]
        pendingOwner(pendingOwnerCall),
        #[allow(missing_docs)]
        predictModuleAddress_0(predictModuleAddress_0Call),
        #[allow(missing_docs)]
        predictModuleAddress_1(predictModuleAddress_1Call),
        #[allow(missing_docs)]
        predictSafeAddress(predictSafeAddressCall),
        #[allow(missing_docs)]
        reclaimErc20(reclaimErc20Call),
        #[allow(missing_docs)]
        renounceOwnership(renounceOwnershipCall),
        #[allow(missing_docs)]
        safeLibAddresses(safeLibAddressesCall),
        #[allow(missing_docs)]
        safeVersion(safeVersionCall),
        #[allow(missing_docs)]
        tokensReceived(tokensReceivedCall),
        #[allow(missing_docs)]
        transferOwnership(transferOwnershipCall),
        #[allow(missing_docs)]
        updateErc1820Implementer(updateErc1820ImplementerCall),
        #[allow(missing_docs)]
        updateHoprNetwork(updateHoprNetworkCall),
        #[allow(missing_docs)]
        updateModuleSingletonAddress(updateModuleSingletonAddressCall),
        #[allow(missing_docs)]
        updateSafeLibAddress(updateSafeLibAddressCall),
    }
    impl HoprNodeStakeFactoryCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [0u8, 35u8, 222u8, 41u8],
            [2u8, 51u8, 41u8, 107u8],
            [50u8, 131u8, 143u8, 107u8],
            [99u8, 241u8, 127u8, 249u8],
            [105u8, 106u8, 182u8, 53u8],
            [113u8, 80u8, 24u8, 166u8],
            [114u8, 88u8, 28u8, 192u8],
            [121u8, 186u8, 80u8, 151u8],
            [121u8, 209u8, 1u8, 250u8],
            [126u8, 242u8, 114u8, 31u8],
            [137u8, 71u8, 137u8, 10u8],
            [138u8, 252u8, 59u8, 245u8],
            [141u8, 165u8, 203u8, 91u8],
            [154u8, 148u8, 173u8, 223u8],
            [154u8, 239u8, 30u8, 217u8],
            [167u8, 166u8, 228u8, 184u8],
            [171u8, 237u8, 32u8, 91u8],
            [194u8, 72u8, 164u8, 231u8],
            [212u8, 138u8, 102u8, 189u8],
            [227u8, 12u8, 57u8, 120u8],
            [242u8, 253u8, 227u8, 139u8],
            [248u8, 255u8, 227u8, 192u8],
            [250u8, 42u8, 234u8, 180u8],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(tokensReceived),
            ::core::stringify!(updateModuleSingletonAddress),
            ::core::stringify!(updateHoprNetwork),
            ::core::stringify!(DEPLOYSAFEMODULE_FUNCTION_IDENTIFIER),
            ::core::stringify!(deployModule),
            ::core::stringify!(renounceOwnership),
            ::core::stringify!(TOKENS_RECIPIENT_INTERFACE_HASH),
            ::core::stringify!(acceptOwnership),
            ::core::stringify!(reclaimErc20),
            ::core::stringify!(safeVersion),
            ::core::stringify!(safeLibAddresses),
            ::core::stringify!(predictModuleAddress_0),
            ::core::stringify!(owner),
            ::core::stringify!(clone),
            ::core::stringify!(moduleSingletonAddress),
            ::core::stringify!(defaultHoprNetwork),
            ::core::stringify!(updateErc1820Implementer),
            ::core::stringify!(predictSafeAddress),
            ::core::stringify!(predictModuleAddress_1),
            ::core::stringify!(pendingOwner),
            ::core::stringify!(transferOwnership),
            ::core::stringify!(DEPLOYSAFEANDMODULEANDINCLUDENODES_IDENTIFIER),
            ::core::stringify!(updateSafeLibAddress),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <tokensReceivedCall as alloy_sol_types::SolCall>::SIGNATURE,
            <updateModuleSingletonAddressCall as alloy_sol_types::SolCall>::SIGNATURE,
            <updateHoprNetworkCall as alloy_sol_types::SolCall>::SIGNATURE,
            <DEPLOYSAFEMODULE_FUNCTION_IDENTIFIERCall as alloy_sol_types::SolCall>::SIGNATURE,
            <deployModuleCall as alloy_sol_types::SolCall>::SIGNATURE,
            <renounceOwnershipCall as alloy_sol_types::SolCall>::SIGNATURE,
            <TOKENS_RECIPIENT_INTERFACE_HASHCall as alloy_sol_types::SolCall>::SIGNATURE,
            <acceptOwnershipCall as alloy_sol_types::SolCall>::SIGNATURE,
            <reclaimErc20Call as alloy_sol_types::SolCall>::SIGNATURE,
            <safeVersionCall as alloy_sol_types::SolCall>::SIGNATURE,
            <safeLibAddressesCall as alloy_sol_types::SolCall>::SIGNATURE,
            <predictModuleAddress_0Call as alloy_sol_types::SolCall>::SIGNATURE,
            <ownerCall as alloy_sol_types::SolCall>::SIGNATURE,
            <cloneCall as alloy_sol_types::SolCall>::SIGNATURE,
            <moduleSingletonAddressCall as alloy_sol_types::SolCall>::SIGNATURE,
            <defaultHoprNetworkCall as alloy_sol_types::SolCall>::SIGNATURE,
            <updateErc1820ImplementerCall as alloy_sol_types::SolCall>::SIGNATURE,
            <predictSafeAddressCall as alloy_sol_types::SolCall>::SIGNATURE,
            <predictModuleAddress_1Call as alloy_sol_types::SolCall>::SIGNATURE,
            <pendingOwnerCall as alloy_sol_types::SolCall>::SIGNATURE,
            <transferOwnershipCall as alloy_sol_types::SolCall>::SIGNATURE,
            <DEPLOYSAFEANDMODULEANDINCLUDENODES_IDENTIFIERCall as alloy_sol_types::SolCall>::SIGNATURE,
            <updateSafeLibAddressCall as alloy_sol_types::SolCall>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for HoprNodeStakeFactoryCalls {
        const NAME: &'static str = "HoprNodeStakeFactoryCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 23usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::DEPLOYSAFEANDMODULEANDINCLUDENODES_IDENTIFIER(_) => {
                    <DEPLOYSAFEANDMODULEANDINCLUDENODES_IDENTIFIERCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::DEPLOYSAFEMODULE_FUNCTION_IDENTIFIER(_) => {
                    <DEPLOYSAFEMODULE_FUNCTION_IDENTIFIERCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::TOKENS_RECIPIENT_INTERFACE_HASH(_) => {
                    <TOKENS_RECIPIENT_INTERFACE_HASHCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::acceptOwnership(_) => {
                    <acceptOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::clone(_) => <cloneCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::defaultHoprNetwork(_) => {
                    <defaultHoprNetworkCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::deployModule(_) => {
                    <deployModuleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::moduleSingletonAddress(_) => {
                    <moduleSingletonAddressCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::owner(_) => <ownerCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::pendingOwner(_) => {
                    <pendingOwnerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::predictModuleAddress_0(_) => {
                    <predictModuleAddress_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::predictModuleAddress_1(_) => {
                    <predictModuleAddress_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::predictSafeAddress(_) => {
                    <predictSafeAddressCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::reclaimErc20(_) => {
                    <reclaimErc20Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::renounceOwnership(_) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::safeLibAddresses(_) => {
                    <safeLibAddressesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::safeVersion(_) => {
                    <safeVersionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::tokensReceived(_) => {
                    <tokensReceivedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::transferOwnership(_) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::updateErc1820Implementer(_) => {
                    <updateErc1820ImplementerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::updateHoprNetwork(_) => {
                    <updateHoprNetworkCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::updateModuleSingletonAddress(_) => {
                    <updateModuleSingletonAddressCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::updateSafeLibAddress(_) => {
                    <updateSafeLibAddressCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls>] = &[
                {
                    fn tokensReceived(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <tokensReceivedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::tokensReceived)
                    }
                    tokensReceived
                },
                {
                    fn updateModuleSingletonAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <updateModuleSingletonAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::updateModuleSingletonAddress)
                    }
                    updateModuleSingletonAddress
                },
                {
                    fn updateHoprNetwork(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <updateHoprNetworkCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::updateHoprNetwork)
                    }
                    updateHoprNetwork
                },
                {
                    fn DEPLOYSAFEMODULE_FUNCTION_IDENTIFIER(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <DEPLOYSAFEMODULE_FUNCTION_IDENTIFIERCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                HoprNodeStakeFactoryCalls::DEPLOYSAFEMODULE_FUNCTION_IDENTIFIER,
                            )
                    }
                    DEPLOYSAFEMODULE_FUNCTION_IDENTIFIER
                },
                {
                    fn deployModule(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <deployModuleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::deployModule)
                    }
                    deployModule
                },
                {
                    fn renounceOwnership(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::renounceOwnership)
                    }
                    renounceOwnership
                },
                {
                    fn TOKENS_RECIPIENT_INTERFACE_HASH(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <TOKENS_RECIPIENT_INTERFACE_HASHCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                HoprNodeStakeFactoryCalls::TOKENS_RECIPIENT_INTERFACE_HASH,
                            )
                    }
                    TOKENS_RECIPIENT_INTERFACE_HASH
                },
                {
                    fn acceptOwnership(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <acceptOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::acceptOwnership)
                    }
                    acceptOwnership
                },
                {
                    fn reclaimErc20(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <reclaimErc20Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::reclaimErc20)
                    }
                    reclaimErc20
                },
                {
                    fn safeVersion(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <safeVersionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::safeVersion)
                    }
                    safeVersion
                },
                {
                    fn safeLibAddresses(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <safeLibAddressesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::safeLibAddresses)
                    }
                    safeLibAddresses
                },
                {
                    fn predictModuleAddress_0(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <predictModuleAddress_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::predictModuleAddress_0)
                    }
                    predictModuleAddress_0
                },
                {
                    fn owner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprNodeStakeFactoryCalls::owner)
                    }
                    owner
                },
                {
                    fn clone(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <cloneCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprNodeStakeFactoryCalls::clone)
                    }
                    clone
                },
                {
                    fn moduleSingletonAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <moduleSingletonAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::moduleSingletonAddress)
                    }
                    moduleSingletonAddress
                },
                {
                    fn defaultHoprNetwork(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <defaultHoprNetworkCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::defaultHoprNetwork)
                    }
                    defaultHoprNetwork
                },
                {
                    fn updateErc1820Implementer(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <updateErc1820ImplementerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::updateErc1820Implementer)
                    }
                    updateErc1820Implementer
                },
                {
                    fn predictSafeAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <predictSafeAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::predictSafeAddress)
                    }
                    predictSafeAddress
                },
                {
                    fn predictModuleAddress_1(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <predictModuleAddress_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::predictModuleAddress_1)
                    }
                    predictModuleAddress_1
                },
                {
                    fn pendingOwner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <pendingOwnerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::pendingOwner)
                    }
                    pendingOwner
                },
                {
                    fn transferOwnership(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <transferOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::transferOwnership)
                    }
                    transferOwnership
                },
                {
                    fn DEPLOYSAFEANDMODULEANDINCLUDENODES_IDENTIFIER(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <DEPLOYSAFEANDMODULEANDINCLUDENODES_IDENTIFIERCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                HoprNodeStakeFactoryCalls::DEPLOYSAFEANDMODULEANDINCLUDENODES_IDENTIFIER,
                            )
                    }
                    DEPLOYSAFEANDMODULEANDINCLUDENODES_IDENTIFIER
                },
                {
                    fn updateSafeLibAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <updateSafeLibAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::updateSafeLibAddress)
                    }
                    updateSafeLibAddress
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls>] = &[
                {
                    fn tokensReceived(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <tokensReceivedCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::tokensReceived)
                    }
                    tokensReceived
                },
                {
                    fn updateModuleSingletonAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <updateModuleSingletonAddressCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::updateModuleSingletonAddress)
                    }
                    updateModuleSingletonAddress
                },
                {
                    fn updateHoprNetwork(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <updateHoprNetworkCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::updateHoprNetwork)
                    }
                    updateHoprNetwork
                },
                {
                    fn DEPLOYSAFEMODULE_FUNCTION_IDENTIFIER(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <DEPLOYSAFEMODULE_FUNCTION_IDENTIFIERCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                HoprNodeStakeFactoryCalls::DEPLOYSAFEMODULE_FUNCTION_IDENTIFIER,
                            )
                    }
                    DEPLOYSAFEMODULE_FUNCTION_IDENTIFIER
                },
                {
                    fn deployModule(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <deployModuleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::deployModule)
                    }
                    deployModule
                },
                {
                    fn renounceOwnership(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::renounceOwnership)
                    }
                    renounceOwnership
                },
                {
                    fn TOKENS_RECIPIENT_INTERFACE_HASH(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <TOKENS_RECIPIENT_INTERFACE_HASHCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                HoprNodeStakeFactoryCalls::TOKENS_RECIPIENT_INTERFACE_HASH,
                            )
                    }
                    TOKENS_RECIPIENT_INTERFACE_HASH
                },
                {
                    fn acceptOwnership(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <acceptOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::acceptOwnership)
                    }
                    acceptOwnership
                },
                {
                    fn reclaimErc20(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <reclaimErc20Call as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::reclaimErc20)
                    }
                    reclaimErc20
                },
                {
                    fn safeVersion(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <safeVersionCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::safeVersion)
                    }
                    safeVersion
                },
                {
                    fn safeLibAddresses(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <safeLibAddressesCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::safeLibAddresses)
                    }
                    safeLibAddresses
                },
                {
                    fn predictModuleAddress_0(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <predictModuleAddress_0Call as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::predictModuleAddress_0)
                    }
                    predictModuleAddress_0
                },
                {
                    fn owner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::owner)
                    }
                    owner
                },
                {
                    fn clone(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <cloneCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::clone)
                    }
                    clone
                },
                {
                    fn moduleSingletonAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <moduleSingletonAddressCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::moduleSingletonAddress)
                    }
                    moduleSingletonAddress
                },
                {
                    fn defaultHoprNetwork(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <defaultHoprNetworkCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::defaultHoprNetwork)
                    }
                    defaultHoprNetwork
                },
                {
                    fn updateErc1820Implementer(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <updateErc1820ImplementerCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::updateErc1820Implementer)
                    }
                    updateErc1820Implementer
                },
                {
                    fn predictSafeAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <predictSafeAddressCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::predictSafeAddress)
                    }
                    predictSafeAddress
                },
                {
                    fn predictModuleAddress_1(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <predictModuleAddress_1Call as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::predictModuleAddress_1)
                    }
                    predictModuleAddress_1
                },
                {
                    fn pendingOwner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <pendingOwnerCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::pendingOwner)
                    }
                    pendingOwner
                },
                {
                    fn transferOwnership(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <transferOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::transferOwnership)
                    }
                    transferOwnership
                },
                {
                    fn DEPLOYSAFEANDMODULEANDINCLUDENODES_IDENTIFIER(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <DEPLOYSAFEANDMODULEANDINCLUDENODES_IDENTIFIERCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                HoprNodeStakeFactoryCalls::DEPLOYSAFEANDMODULEANDINCLUDENODES_IDENTIFIER,
                            )
                    }
                    DEPLOYSAFEANDMODULEANDINCLUDENODES_IDENTIFIER
                },
                {
                    fn updateSafeLibAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <updateSafeLibAddressCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::updateSafeLibAddress)
                    }
                    updateSafeLibAddress
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::DEPLOYSAFEANDMODULEANDINCLUDENODES_IDENTIFIER(inner) => {
                    <DEPLOYSAFEANDMODULEANDINCLUDENODES_IDENTIFIERCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::DEPLOYSAFEMODULE_FUNCTION_IDENTIFIER(inner) => {
                    <DEPLOYSAFEMODULE_FUNCTION_IDENTIFIERCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TOKENS_RECIPIENT_INTERFACE_HASH(inner) => {
                    <TOKENS_RECIPIENT_INTERFACE_HASHCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::acceptOwnership(inner) => {
                    <acceptOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::clone(inner) => {
                    <cloneCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::defaultHoprNetwork(inner) => {
                    <defaultHoprNetworkCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::deployModule(inner) => {
                    <deployModuleCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::moduleSingletonAddress(inner) => {
                    <moduleSingletonAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::pendingOwner(inner) => {
                    <pendingOwnerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::predictModuleAddress_0(inner) => {
                    <predictModuleAddress_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::predictModuleAddress_1(inner) => {
                    <predictModuleAddress_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::predictSafeAddress(inner) => {
                    <predictSafeAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::reclaimErc20(inner) => {
                    <reclaimErc20Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::safeLibAddresses(inner) => {
                    <safeLibAddressesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::safeVersion(inner) => {
                    <safeVersionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::tokensReceived(inner) => {
                    <tokensReceivedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::updateErc1820Implementer(inner) => {
                    <updateErc1820ImplementerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::updateHoprNetwork(inner) => {
                    <updateHoprNetworkCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::updateModuleSingletonAddress(inner) => {
                    <updateModuleSingletonAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::updateSafeLibAddress(inner) => {
                    <updateSafeLibAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::DEPLOYSAFEANDMODULEANDINCLUDENODES_IDENTIFIER(inner) => {
                    <DEPLOYSAFEANDMODULEANDINCLUDENODES_IDENTIFIERCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DEPLOYSAFEMODULE_FUNCTION_IDENTIFIER(inner) => {
                    <DEPLOYSAFEMODULE_FUNCTION_IDENTIFIERCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TOKENS_RECIPIENT_INTERFACE_HASH(inner) => {
                    <TOKENS_RECIPIENT_INTERFACE_HASHCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::acceptOwnership(inner) => {
                    <acceptOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::clone(inner) => {
                    <cloneCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::defaultHoprNetwork(inner) => {
                    <defaultHoprNetworkCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::deployModule(inner) => {
                    <deployModuleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::moduleSingletonAddress(inner) => {
                    <moduleSingletonAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::pendingOwner(inner) => {
                    <pendingOwnerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::predictModuleAddress_0(inner) => {
                    <predictModuleAddress_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::predictModuleAddress_1(inner) => {
                    <predictModuleAddress_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::predictSafeAddress(inner) => {
                    <predictSafeAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::reclaimErc20(inner) => {
                    <reclaimErc20Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::safeLibAddresses(inner) => {
                    <safeLibAddressesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::safeVersion(inner) => {
                    <safeVersionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::tokensReceived(inner) => {
                    <tokensReceivedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::updateErc1820Implementer(inner) => {
                    <updateErc1820ImplementerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::updateHoprNetwork(inner) => {
                    <updateHoprNetworkCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::updateModuleSingletonAddress(inner) => {
                    <updateModuleSingletonAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::updateSafeLibAddress(inner) => {
                    <updateSafeLibAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`HoprNodeStakeFactory`](self) custom errors.
    #[derive(Clone)]
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum HoprNodeStakeFactoryErrors {
        #[allow(missing_docs)]
        Create2EmptyBytecode(Create2EmptyBytecode),
        #[allow(missing_docs)]
        FailedDeployment(FailedDeployment),
        #[allow(missing_docs)]
        InsufficientBalance(InsufficientBalance),
        #[allow(missing_docs)]
        InvalidFunctionSelector(InvalidFunctionSelector),
        #[allow(missing_docs)]
        InvalidOwner(InvalidOwner),
        #[allow(missing_docs)]
        NotTokenRecipient(NotTokenRecipient),
        #[allow(missing_docs)]
        OwnableInvalidOwner(OwnableInvalidOwner),
        #[allow(missing_docs)]
        OwnableUnauthorizedAccount(OwnableUnauthorizedAccount),
        #[allow(missing_docs)]
        SafeERC20FailedOperation(SafeERC20FailedOperation),
        #[allow(missing_docs)]
        TooFewOwners(TooFewOwners),
        #[allow(missing_docs)]
        UnauthorizedToken(UnauthorizedToken),
    }
    impl HoprNodeStakeFactoryErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [13u8, 127u8, 209u8, 170u8],
            [17u8, 140u8, 218u8, 167u8],
            [30u8, 79u8, 189u8, 247u8],
            [66u8, 134u8, 140u8, 155u8],
            [73u8, 226u8, 124u8, 255u8],
            [76u8, 162u8, 73u8, 220u8],
            [82u8, 116u8, 175u8, 231u8],
            [114u8, 7u8, 115u8, 242u8],
            [126u8, 95u8, 147u8, 73u8],
            [176u8, 110u8, 191u8, 61u8],
            [207u8, 71u8, 145u8, 129u8],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(TooFewOwners),
            ::core::stringify!(OwnableUnauthorizedAccount),
            ::core::stringify!(OwnableInvalidOwner),
            ::core::stringify!(InvalidFunctionSelector),
            ::core::stringify!(InvalidOwner),
            ::core::stringify!(Create2EmptyBytecode),
            ::core::stringify!(SafeERC20FailedOperation),
            ::core::stringify!(NotTokenRecipient),
            ::core::stringify!(UnauthorizedToken),
            ::core::stringify!(FailedDeployment),
            ::core::stringify!(InsufficientBalance),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <TooFewOwners as alloy_sol_types::SolError>::SIGNATURE,
            <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::SIGNATURE,
            <OwnableInvalidOwner as alloy_sol_types::SolError>::SIGNATURE,
            <InvalidFunctionSelector as alloy_sol_types::SolError>::SIGNATURE,
            <InvalidOwner as alloy_sol_types::SolError>::SIGNATURE,
            <Create2EmptyBytecode as alloy_sol_types::SolError>::SIGNATURE,
            <SafeERC20FailedOperation as alloy_sol_types::SolError>::SIGNATURE,
            <NotTokenRecipient as alloy_sol_types::SolError>::SIGNATURE,
            <UnauthorizedToken as alloy_sol_types::SolError>::SIGNATURE,
            <FailedDeployment as alloy_sol_types::SolError>::SIGNATURE,
            <InsufficientBalance as alloy_sol_types::SolError>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for HoprNodeStakeFactoryErrors {
        const NAME: &'static str = "HoprNodeStakeFactoryErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 11usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::Create2EmptyBytecode(_) => {
                    <Create2EmptyBytecode as alloy_sol_types::SolError>::SELECTOR
                }
                Self::FailedDeployment(_) => {
                    <FailedDeployment as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientBalance(_) => {
                    <InsufficientBalance as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidFunctionSelector(_) => {
                    <InvalidFunctionSelector as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidOwner(_) => {
                    <InvalidOwner as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotTokenRecipient(_) => {
                    <NotTokenRecipient as alloy_sol_types::SolError>::SELECTOR
                }
                Self::OwnableInvalidOwner(_) => {
                    <OwnableInvalidOwner as alloy_sol_types::SolError>::SELECTOR
                }
                Self::OwnableUnauthorizedAccount(_) => {
                    <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SafeERC20FailedOperation(_) => {
                    <SafeERC20FailedOperation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::TooFewOwners(_) => {
                    <TooFewOwners as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UnauthorizedToken(_) => {
                    <UnauthorizedToken as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<HoprNodeStakeFactoryErrors>] = &[
                {
                    fn TooFewOwners(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryErrors> {
                        <TooFewOwners as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(HoprNodeStakeFactoryErrors::TooFewOwners)
                    }
                    TooFewOwners
                },
                {
                    fn OwnableUnauthorizedAccount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryErrors> {
                        <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNodeStakeFactoryErrors::OwnableUnauthorizedAccount)
                    }
                    OwnableUnauthorizedAccount
                },
                {
                    fn OwnableInvalidOwner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryErrors> {
                        <OwnableInvalidOwner as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNodeStakeFactoryErrors::OwnableInvalidOwner)
                    }
                    OwnableInvalidOwner
                },
                {
                    fn InvalidFunctionSelector(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryErrors> {
                        <InvalidFunctionSelector as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNodeStakeFactoryErrors::InvalidFunctionSelector)
                    }
                    InvalidFunctionSelector
                },
                {
                    fn InvalidOwner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryErrors> {
                        <InvalidOwner as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(HoprNodeStakeFactoryErrors::InvalidOwner)
                    }
                    InvalidOwner
                },
                {
                    fn Create2EmptyBytecode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryErrors> {
                        <Create2EmptyBytecode as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNodeStakeFactoryErrors::Create2EmptyBytecode)
                    }
                    Create2EmptyBytecode
                },
                {
                    fn SafeERC20FailedOperation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryErrors> {
                        <SafeERC20FailedOperation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNodeStakeFactoryErrors::SafeERC20FailedOperation)
                    }
                    SafeERC20FailedOperation
                },
                {
                    fn NotTokenRecipient(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryErrors> {
                        <NotTokenRecipient as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNodeStakeFactoryErrors::NotTokenRecipient)
                    }
                    NotTokenRecipient
                },
                {
                    fn UnauthorizedToken(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryErrors> {
                        <UnauthorizedToken as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNodeStakeFactoryErrors::UnauthorizedToken)
                    }
                    UnauthorizedToken
                },
                {
                    fn FailedDeployment(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryErrors> {
                        <FailedDeployment as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNodeStakeFactoryErrors::FailedDeployment)
                    }
                    FailedDeployment
                },
                {
                    fn InsufficientBalance(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryErrors> {
                        <InsufficientBalance as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNodeStakeFactoryErrors::InsufficientBalance)
                    }
                    InsufficientBalance
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<HoprNodeStakeFactoryErrors>] = &[
                {
                    fn TooFewOwners(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryErrors> {
                        <TooFewOwners as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNodeStakeFactoryErrors::TooFewOwners)
                    }
                    TooFewOwners
                },
                {
                    fn OwnableUnauthorizedAccount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryErrors> {
                        <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNodeStakeFactoryErrors::OwnableUnauthorizedAccount)
                    }
                    OwnableUnauthorizedAccount
                },
                {
                    fn OwnableInvalidOwner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryErrors> {
                        <OwnableInvalidOwner as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNodeStakeFactoryErrors::OwnableInvalidOwner)
                    }
                    OwnableInvalidOwner
                },
                {
                    fn InvalidFunctionSelector(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryErrors> {
                        <InvalidFunctionSelector as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNodeStakeFactoryErrors::InvalidFunctionSelector)
                    }
                    InvalidFunctionSelector
                },
                {
                    fn InvalidOwner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryErrors> {
                        <InvalidOwner as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNodeStakeFactoryErrors::InvalidOwner)
                    }
                    InvalidOwner
                },
                {
                    fn Create2EmptyBytecode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryErrors> {
                        <Create2EmptyBytecode as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNodeStakeFactoryErrors::Create2EmptyBytecode)
                    }
                    Create2EmptyBytecode
                },
                {
                    fn SafeERC20FailedOperation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryErrors> {
                        <SafeERC20FailedOperation as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNodeStakeFactoryErrors::SafeERC20FailedOperation)
                    }
                    SafeERC20FailedOperation
                },
                {
                    fn NotTokenRecipient(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryErrors> {
                        <NotTokenRecipient as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNodeStakeFactoryErrors::NotTokenRecipient)
                    }
                    NotTokenRecipient
                },
                {
                    fn UnauthorizedToken(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryErrors> {
                        <UnauthorizedToken as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNodeStakeFactoryErrors::UnauthorizedToken)
                    }
                    UnauthorizedToken
                },
                {
                    fn FailedDeployment(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryErrors> {
                        <FailedDeployment as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNodeStakeFactoryErrors::FailedDeployment)
                    }
                    FailedDeployment
                },
                {
                    fn InsufficientBalance(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryErrors> {
                        <InsufficientBalance as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNodeStakeFactoryErrors::InsufficientBalance)
                    }
                    InsufficientBalance
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::Create2EmptyBytecode(inner) => {
                    <Create2EmptyBytecode as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::FailedDeployment(inner) => {
                    <FailedDeployment as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientBalance(inner) => {
                    <InsufficientBalance as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidFunctionSelector(inner) => {
                    <InvalidFunctionSelector as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidOwner(inner) => {
                    <InvalidOwner as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::NotTokenRecipient(inner) => {
                    <NotTokenRecipient as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::OwnableInvalidOwner(inner) => {
                    <OwnableInvalidOwner as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::OwnableUnauthorizedAccount(inner) => {
                    <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SafeERC20FailedOperation(inner) => {
                    <SafeERC20FailedOperation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TooFewOwners(inner) => {
                    <TooFewOwners as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::UnauthorizedToken(inner) => {
                    <UnauthorizedToken as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::Create2EmptyBytecode(inner) => {
                    <Create2EmptyBytecode as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::FailedDeployment(inner) => {
                    <FailedDeployment as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientBalance(inner) => {
                    <InsufficientBalance as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidFunctionSelector(inner) => {
                    <InvalidFunctionSelector as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidOwner(inner) => {
                    <InvalidOwner as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotTokenRecipient(inner) => {
                    <NotTokenRecipient as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OwnableInvalidOwner(inner) => {
                    <OwnableInvalidOwner as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OwnableUnauthorizedAccount(inner) => {
                    <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SafeERC20FailedOperation(inner) => {
                    <SafeERC20FailedOperation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TooFewOwners(inner) => {
                    <TooFewOwners as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UnauthorizedToken(inner) => {
                    <UnauthorizedToken as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`HoprNodeStakeFactory`](self) events.
    #[derive(Clone)]
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum HoprNodeStakeFactoryEvents {
        #[allow(missing_docs)]
        HoprNodeStakeHoprNetworkUpdated(HoprNodeStakeHoprNetworkUpdated),
        #[allow(missing_docs)]
        HoprNodeStakeModuleUpdated(HoprNodeStakeModuleUpdated),
        #[allow(missing_docs)]
        HoprNodeStakeSafeLibUpdated(HoprNodeStakeSafeLibUpdated),
        #[allow(missing_docs)]
        NewHoprNodeStakeModule(NewHoprNodeStakeModule),
        #[allow(missing_docs)]
        NewHoprNodeStakeModuleForSafe(NewHoprNodeStakeModuleForSafe),
        #[allow(missing_docs)]
        NewHoprNodeStakeSafe(NewHoprNodeStakeSafe),
        #[allow(missing_docs)]
        OwnershipTransferStarted(OwnershipTransferStarted),
        #[allow(missing_docs)]
        OwnershipTransferred(OwnershipTransferred),
    }
    impl HoprNodeStakeFactoryEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                56u8, 209u8, 107u8, 140u8, 172u8, 34u8, 217u8, 159u8, 199u8, 193u8, 36u8,
                185u8, 205u8, 13u8, 226u8, 211u8, 250u8, 31u8, 174u8, 244u8, 32u8, 191u8,
                231u8, 145u8, 216u8, 195u8, 98u8, 215u8, 101u8, 226u8, 39u8, 0u8,
            ],
            [
                84u8, 207u8, 207u8, 75u8, 219u8, 111u8, 32u8, 99u8, 43u8, 165u8, 68u8,
                205u8, 104u8, 65u8, 48u8, 252u8, 157u8, 180u8, 220u8, 47u8, 230u8, 54u8,
                9u8, 38u8, 214u8, 183u8, 134u8, 98u8, 151u8, 240u8, 49u8, 94u8,
            ],
            [
                130u8, 49u8, 209u8, 105u8, 244u8, 22u8, 182u8, 102u8, 174u8, 127u8,
                164u8, 63u8, 170u8, 36u8, 161u8, 136u8, 153u8, 115u8, 128u8, 117u8,
                165u8, 63u8, 50u8, 201u8, 118u8, 23u8, 209u8, 115u8, 177u8, 137u8, 227u8,
                134u8,
            ],
            [
                131u8, 165u8, 195u8, 27u8, 254u8, 228u8, 157u8, 37u8, 77u8, 149u8, 227u8,
                148u8, 109u8, 142u8, 132u8, 52u8, 229u8, 151u8, 83u8, 130u8, 250u8,
                139u8, 132u8, 145u8, 130u8, 219u8, 158u8, 37u8, 26u8, 170u8, 170u8, 38u8,
            ],
            [
                135u8, 235u8, 80u8, 123u8, 43u8, 66u8, 235u8, 101u8, 152u8, 7u8, 215u8,
                161u8, 246u8, 60u8, 137u8, 184u8, 226u8, 44u8, 103u8, 70u8, 137u8, 96u8,
                62u8, 172u8, 7u8, 163u8, 113u8, 63u8, 6u8, 254u8, 201u8, 195u8,
            ],
            [
                139u8, 224u8, 7u8, 156u8, 83u8, 22u8, 89u8, 20u8, 19u8, 68u8, 205u8,
                31u8, 208u8, 164u8, 242u8, 132u8, 25u8, 73u8, 127u8, 151u8, 34u8, 163u8,
                218u8, 175u8, 227u8, 180u8, 24u8, 111u8, 107u8, 100u8, 87u8, 224u8,
            ],
            [
                221u8, 96u8, 114u8, 90u8, 136u8, 80u8, 143u8, 226u8, 220u8, 183u8, 105u8,
                189u8, 130u8, 66u8, 128u8, 162u8, 160u8, 19u8, 86u8, 25u8, 140u8, 121u8,
                85u8, 21u8, 209u8, 117u8, 171u8, 196u8, 188u8, 64u8, 183u8, 78u8,
            ],
            [
                249u8, 102u8, 206u8, 113u8, 115u8, 73u8, 169u8, 64u8, 228u8, 3u8, 184u8,
                250u8, 174u8, 113u8, 253u8, 175u8, 87u8, 61u8, 139u8, 152u8, 71u8, 222u8,
                234u8, 22u8, 252u8, 163u8, 216u8, 112u8, 207u8, 108u8, 41u8, 45u8,
            ],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(OwnershipTransferStarted),
            ::core::stringify!(HoprNodeStakeHoprNetworkUpdated),
            ::core::stringify!(NewHoprNodeStakeSafe),
            ::core::stringify!(NewHoprNodeStakeModuleForSafe),
            ::core::stringify!(HoprNodeStakeSafeLibUpdated),
            ::core::stringify!(OwnershipTransferred),
            ::core::stringify!(HoprNodeStakeModuleUpdated),
            ::core::stringify!(NewHoprNodeStakeModule),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <OwnershipTransferStarted as alloy_sol_types::SolEvent>::SIGNATURE,
            <HoprNodeStakeHoprNetworkUpdated as alloy_sol_types::SolEvent>::SIGNATURE,
            <NewHoprNodeStakeSafe as alloy_sol_types::SolEvent>::SIGNATURE,
            <NewHoprNodeStakeModuleForSafe as alloy_sol_types::SolEvent>::SIGNATURE,
            <HoprNodeStakeSafeLibUpdated as alloy_sol_types::SolEvent>::SIGNATURE,
            <OwnershipTransferred as alloy_sol_types::SolEvent>::SIGNATURE,
            <HoprNodeStakeModuleUpdated as alloy_sol_types::SolEvent>::SIGNATURE,
            <NewHoprNodeStakeModule as alloy_sol_types::SolEvent>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 32usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 32usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for HoprNodeStakeFactoryEvents {
        const NAME: &'static str = "HoprNodeStakeFactoryEvents";
        const COUNT: usize = 8usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(
                    <HoprNodeStakeHoprNetworkUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <HoprNodeStakeHoprNetworkUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::HoprNodeStakeHoprNetworkUpdated)
                }
                Some(
                    <HoprNodeStakeModuleUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <HoprNodeStakeModuleUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::HoprNodeStakeModuleUpdated)
                }
                Some(
                    <HoprNodeStakeSafeLibUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <HoprNodeStakeSafeLibUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::HoprNodeStakeSafeLibUpdated)
                }
                Some(
                    <NewHoprNodeStakeModule as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <NewHoprNodeStakeModule as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::NewHoprNodeStakeModule)
                }
                Some(
                    <NewHoprNodeStakeModuleForSafe as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <NewHoprNodeStakeModuleForSafe as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::NewHoprNodeStakeModuleForSafe)
                }
                Some(
                    <NewHoprNodeStakeSafe as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <NewHoprNodeStakeSafe as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::NewHoprNodeStakeSafe)
                }
                Some(
                    <OwnershipTransferStarted as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OwnershipTransferStarted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::OwnershipTransferStarted)
                }
                Some(
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::OwnershipTransferred)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for HoprNodeStakeFactoryEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::HoprNodeStakeHoprNetworkUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::HoprNodeStakeModuleUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::HoprNodeStakeSafeLibUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::NewHoprNodeStakeModule(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::NewHoprNodeStakeModuleForSafe(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::NewHoprNodeStakeSafe(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OwnershipTransferStarted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::HoprNodeStakeHoprNetworkUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::HoprNodeStakeModuleUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::HoprNodeStakeSafeLibUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::NewHoprNodeStakeModule(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::NewHoprNodeStakeModuleForSafe(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::NewHoprNodeStakeSafe(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OwnershipTransferStarted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`HoprNodeStakeFactory`](self) contract instance.

See the [wrapper's documentation](`HoprNodeStakeFactoryInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        __provider: P,
    ) -> HoprNodeStakeFactoryInstance<P, N> {
        HoprNodeStakeFactoryInstance::<P, N>::new(address, __provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        __provider: P,
        _moduleSingletonAddress: alloy::sol_types::private::Address,
        _announcementAddress: alloy::sol_types::private::Address,
        initialOwner: alloy::sol_types::private::Address,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<HoprNodeStakeFactoryInstance<P, N>>,
    > {
        HoprNodeStakeFactoryInstance::<
            P,
            N,
        >::deploy(
            __provider,
            _moduleSingletonAddress,
            _announcementAddress,
            initialOwner,
        )
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        __provider: P,
        _moduleSingletonAddress: alloy::sol_types::private::Address,
        _announcementAddress: alloy::sol_types::private::Address,
        initialOwner: alloy::sol_types::private::Address,
    ) -> alloy_contract::RawCallBuilder<P, N> {
        HoprNodeStakeFactoryInstance::<
            P,
            N,
        >::deploy_builder(
            __provider,
            _moduleSingletonAddress,
            _announcementAddress,
            initialOwner,
        )
    }
    /**A [`HoprNodeStakeFactory`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`HoprNodeStakeFactory`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct HoprNodeStakeFactoryInstance<P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for HoprNodeStakeFactoryInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("HoprNodeStakeFactoryInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > HoprNodeStakeFactoryInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`HoprNodeStakeFactory`](self) contract instance.

See the [wrapper's documentation](`HoprNodeStakeFactoryInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            __provider: P,
        ) -> Self {
            Self {
                address,
                provider: __provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            __provider: P,
            _moduleSingletonAddress: alloy::sol_types::private::Address,
            _announcementAddress: alloy::sol_types::private::Address,
            initialOwner: alloy::sol_types::private::Address,
        ) -> alloy_contract::Result<HoprNodeStakeFactoryInstance<P, N>> {
            let call_builder = Self::deploy_builder(
                __provider,
                _moduleSingletonAddress,
                _announcementAddress,
                initialOwner,
            );
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            __provider: P,
            _moduleSingletonAddress: alloy::sol_types::private::Address,
            _announcementAddress: alloy::sol_types::private::Address,
            initialOwner: alloy::sol_types::private::Address,
        ) -> alloy_contract::RawCallBuilder<P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                __provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall {
                            _moduleSingletonAddress,
                            _announcementAddress,
                            initialOwner,
                        },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> HoprNodeStakeFactoryInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> HoprNodeStakeFactoryInstance<P, N> {
            HoprNodeStakeFactoryInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > HoprNodeStakeFactoryInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`DEPLOYSAFEANDMODULEANDINCLUDENODES_IDENTIFIER`] function.
        pub fn DEPLOYSAFEANDMODULEANDINCLUDENODES_IDENTIFIER(
            &self,
        ) -> alloy_contract::SolCallBuilder<
            &P,
            DEPLOYSAFEANDMODULEANDINCLUDENODES_IDENTIFIERCall,
            N,
        > {
            self.call_builder(&DEPLOYSAFEANDMODULEANDINCLUDENODES_IDENTIFIERCall)
        }
        ///Creates a new call builder for the [`DEPLOYSAFEMODULE_FUNCTION_IDENTIFIER`] function.
        pub fn DEPLOYSAFEMODULE_FUNCTION_IDENTIFIER(
            &self,
        ) -> alloy_contract::SolCallBuilder<
            &P,
            DEPLOYSAFEMODULE_FUNCTION_IDENTIFIERCall,
            N,
        > {
            self.call_builder(&DEPLOYSAFEMODULE_FUNCTION_IDENTIFIERCall)
        }
        ///Creates a new call builder for the [`TOKENS_RECIPIENT_INTERFACE_HASH`] function.
        pub fn TOKENS_RECIPIENT_INTERFACE_HASH(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, TOKENS_RECIPIENT_INTERFACE_HASHCall, N> {
            self.call_builder(&TOKENS_RECIPIENT_INTERFACE_HASHCall)
        }
        ///Creates a new call builder for the [`acceptOwnership`] function.
        pub fn acceptOwnership(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, acceptOwnershipCall, N> {
            self.call_builder(&acceptOwnershipCall)
        }
        ///Creates a new call builder for the [`clone`] function.
        pub fn clone(
            &self,
            nonce: alloy::sol_types::private::primitives::aliases::U256,
            defaultTarget: alloy::sol_types::private::FixedBytes<32>,
            admins: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
        ) -> alloy_contract::SolCallBuilder<&P, cloneCall, N> {
            self.call_builder(
                &cloneCall {
                    nonce,
                    defaultTarget,
                    admins,
                },
            )
        }
        ///Creates a new call builder for the [`defaultHoprNetwork`] function.
        pub fn defaultHoprNetwork(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, defaultHoprNetworkCall, N> {
            self.call_builder(&defaultHoprNetworkCall)
        }
        ///Creates a new call builder for the [`deployModule`] function.
        pub fn deployModule(
            &self,
            safeProxyAddr: alloy::sol_types::private::Address,
            defaultTarget: alloy::sol_types::private::FixedBytes<32>,
            nonce: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, deployModuleCall, N> {
            self.call_builder(
                &deployModuleCall {
                    safeProxyAddr,
                    defaultTarget,
                    nonce,
                },
            )
        }
        ///Creates a new call builder for the [`moduleSingletonAddress`] function.
        pub fn moduleSingletonAddress(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, moduleSingletonAddressCall, N> {
            self.call_builder(&moduleSingletonAddressCall)
        }
        ///Creates a new call builder for the [`owner`] function.
        pub fn owner(&self) -> alloy_contract::SolCallBuilder<&P, ownerCall, N> {
            self.call_builder(&ownerCall)
        }
        ///Creates a new call builder for the [`pendingOwner`] function.
        pub fn pendingOwner(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, pendingOwnerCall, N> {
            self.call_builder(&pendingOwnerCall)
        }
        ///Creates a new call builder for the [`predictModuleAddress_0`] function.
        pub fn predictModuleAddress_0(
            &self,
            salt: alloy::sol_types::private::FixedBytes<32>,
            safe: alloy::sol_types::private::Address,
            defaultTarget: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, predictModuleAddress_0Call, N> {
            self.call_builder(
                &predictModuleAddress_0Call {
                    salt,
                    safe,
                    defaultTarget,
                },
            )
        }
        ///Creates a new call builder for the [`predictModuleAddress_1`] function.
        pub fn predictModuleAddress_1(
            &self,
            caller: alloy::sol_types::private::Address,
            nonce: alloy::sol_types::private::primitives::aliases::U256,
            safe: alloy::sol_types::private::Address,
            defaultTarget: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, predictModuleAddress_1Call, N> {
            self.call_builder(
                &predictModuleAddress_1Call {
                    caller,
                    nonce,
                    safe,
                    defaultTarget,
                },
            )
        }
        ///Creates a new call builder for the [`predictSafeAddress`] function.
        pub fn predictSafeAddress(
            &self,
            admins: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            nonce: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, predictSafeAddressCall, N> {
            self.call_builder(
                &predictSafeAddressCall {
                    admins,
                    nonce,
                },
            )
        }
        ///Creates a new call builder for the [`reclaimErc20`] function.
        pub fn reclaimErc20(
            &self,
            token: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, reclaimErc20Call, N> {
            self.call_builder(&reclaimErc20Call { token })
        }
        ///Creates a new call builder for the [`renounceOwnership`] function.
        pub fn renounceOwnership(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, renounceOwnershipCall, N> {
            self.call_builder(&renounceOwnershipCall)
        }
        ///Creates a new call builder for the [`safeLibAddresses`] function.
        pub fn safeLibAddresses(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, safeLibAddressesCall, N> {
            self.call_builder(&safeLibAddressesCall)
        }
        ///Creates a new call builder for the [`safeVersion`] function.
        pub fn safeVersion(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, safeVersionCall, N> {
            self.call_builder(&safeVersionCall)
        }
        ///Creates a new call builder for the [`tokensReceived`] function.
        pub fn tokensReceived(
            &self,
            _0: alloy::sol_types::private::Address,
            from: alloy::sol_types::private::Address,
            to: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
            userData: alloy::sol_types::private::Bytes,
            _5: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<&P, tokensReceivedCall, N> {
            self.call_builder(
                &tokensReceivedCall {
                    _0,
                    from,
                    to,
                    amount,
                    userData,
                    _5,
                },
            )
        }
        ///Creates a new call builder for the [`transferOwnership`] function.
        pub fn transferOwnership(
            &self,
            newOwner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, transferOwnershipCall, N> {
            self.call_builder(&transferOwnershipCall { newOwner })
        }
        ///Creates a new call builder for the [`updateErc1820Implementer`] function.
        pub fn updateErc1820Implementer(
            &self,
            _newImplementer: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, updateErc1820ImplementerCall, N> {
            self.call_builder(
                &updateErc1820ImplementerCall {
                    _newImplementer,
                },
            )
        }
        ///Creates a new call builder for the [`updateHoprNetwork`] function.
        pub fn updateHoprNetwork(
            &self,
            _newHoprNetwork: <HoprNetwork as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<&P, updateHoprNetworkCall, N> {
            self.call_builder(
                &updateHoprNetworkCall {
                    _newHoprNetwork,
                },
            )
        }
        ///Creates a new call builder for the [`updateModuleSingletonAddress`] function.
        pub fn updateModuleSingletonAddress(
            &self,
            _newModuleSingletonAddress: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, updateModuleSingletonAddressCall, N> {
            self.call_builder(
                &updateModuleSingletonAddressCall {
                    _newModuleSingletonAddress,
                },
            )
        }
        ///Creates a new call builder for the [`updateSafeLibAddress`] function.
        pub fn updateSafeLibAddress(
            &self,
            _newSafeLibAddresses: <SafeLibAddress as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<&P, updateSafeLibAddressCall, N> {
            self.call_builder(
                &updateSafeLibAddressCall {
                    _newSafeLibAddresses,
                },
            )
        }
    }
    /// Event filters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > HoprNodeStakeFactoryInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`HoprNodeStakeHoprNetworkUpdated`] event.
        pub fn HoprNodeStakeHoprNetworkUpdated_filter(
            &self,
        ) -> alloy_contract::Event<&P, HoprNodeStakeHoprNetworkUpdated, N> {
            self.event_filter::<HoprNodeStakeHoprNetworkUpdated>()
        }
        ///Creates a new event filter for the [`HoprNodeStakeModuleUpdated`] event.
        pub fn HoprNodeStakeModuleUpdated_filter(
            &self,
        ) -> alloy_contract::Event<&P, HoprNodeStakeModuleUpdated, N> {
            self.event_filter::<HoprNodeStakeModuleUpdated>()
        }
        ///Creates a new event filter for the [`HoprNodeStakeSafeLibUpdated`] event.
        pub fn HoprNodeStakeSafeLibUpdated_filter(
            &self,
        ) -> alloy_contract::Event<&P, HoprNodeStakeSafeLibUpdated, N> {
            self.event_filter::<HoprNodeStakeSafeLibUpdated>()
        }
        ///Creates a new event filter for the [`NewHoprNodeStakeModule`] event.
        pub fn NewHoprNodeStakeModule_filter(
            &self,
        ) -> alloy_contract::Event<&P, NewHoprNodeStakeModule, N> {
            self.event_filter::<NewHoprNodeStakeModule>()
        }
        ///Creates a new event filter for the [`NewHoprNodeStakeModuleForSafe`] event.
        pub fn NewHoprNodeStakeModuleForSafe_filter(
            &self,
        ) -> alloy_contract::Event<&P, NewHoprNodeStakeModuleForSafe, N> {
            self.event_filter::<NewHoprNodeStakeModuleForSafe>()
        }
        ///Creates a new event filter for the [`NewHoprNodeStakeSafe`] event.
        pub fn NewHoprNodeStakeSafe_filter(
            &self,
        ) -> alloy_contract::Event<&P, NewHoprNodeStakeSafe, N> {
            self.event_filter::<NewHoprNodeStakeSafe>()
        }
        ///Creates a new event filter for the [`OwnershipTransferStarted`] event.
        pub fn OwnershipTransferStarted_filter(
            &self,
        ) -> alloy_contract::Event<&P, OwnershipTransferStarted, N> {
            self.event_filter::<OwnershipTransferStarted>()
        }
        ///Creates a new event filter for the [`OwnershipTransferred`] event.
        pub fn OwnershipTransferred_filter(
            &self,
        ) -> alloy_contract::Event<&P, OwnershipTransferred, N> {
            self.event_filter::<OwnershipTransferred>()
        }
    }
}
