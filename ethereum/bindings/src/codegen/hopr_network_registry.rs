/**

Generated by the following Solidity interface...
```solidity
interface HoprNetworkRegistry {
    error AccessControlBadConfirmation();
    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
    error ArrayLengthNotMatch();
    error CannotOperateForNode(address nodeAddress);
    error GloballyDisabledRegistry();
    error GloballyEnabledRegistry();
    error NodeAlreadyRegisterd(address nodeAddress);
    error NodeNotYetRegisterd(address nodeAddress);
    error NodeRegisterdToOtherAccount(address nodeAddress);
    error NotEnoughAllowanceToRegisterNode();
    error ZeroAddress(string reason);

    event Deregistered(address indexed stakingAccount, address indexed nodeAddress);
    event DeregisteredByManager(address indexed stakingAccount, address indexed nodeAddress);
    event EligibilityUpdated(address indexed stakingAccount, bool indexed eligibility);
    event NetworkRegistryStatusUpdated(bool indexed isEnabled);
    event Registered(address indexed stakingAccount, address indexed nodeAddress);
    event RegisteredByManager(address indexed stakingAccount, address indexed nodeAddress);
    event RequirementUpdated(address indexed requirementImplementation);
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    constructor(address _requirementImplementation, address _newOwner, address _manager);

    function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
    function MANAGER_ROLE() external view returns (bytes32);
    function countRegisterdNodesPerAccount(address) external view returns (uint256);
    function disableRegistry() external;
    function enableRegistry() external;
    function enabled() external view returns (bool);
    function getRoleAdmin(bytes32 role) external view returns (bytes32);
    function getRoleMember(bytes32 role, uint256 index) external view returns (address);
    function getRoleMemberCount(bytes32 role) external view returns (uint256);
    function getRoleMembers(bytes32 role) external view returns (address[] memory);
    function grantRole(bytes32 role, address account) external;
    function hasRole(bytes32 role, address account) external view returns (bool);
    function isAccountEligible(address stakingAccount) external view returns (bool);
    function isNodeRegisteredAndEligible(address nodeAddress) external view returns (bool);
    function isNodeRegisteredByAccount(address nodeAddress, address account) external view returns (bool);
    function managerDeregister(address[] memory nodeAddresses) external;
    function managerForceSync(address[] memory stakingAccounts, bool[] memory eligibilities) external;
    function managerRegister(address[] memory stakingAccounts, address[] memory nodeAddresses) external;
    function managerSync(address[] memory stakingAccounts) external;
    function maxAdditionalRegistrations(address stakingAccount) external view returns (uint256);
    function nodeRegisterdToAccount(address) external view returns (address);
    function renounceRole(bytes32 role, address callerConfirmation) external;
    function requirementImplementation() external view returns (address);
    function revokeRole(bytes32 role, address account) external;
    function selfDeregister(address[] memory nodeAddresses) external;
    function selfRegister(address[] memory nodeAddresses) external;
    function selfSync() external;
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
    function updateRequirementImplementation(address _requirementImplementation) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "_requirementImplementation",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_newOwner",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_manager",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "DEFAULT_ADMIN_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "MANAGER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "countRegisterdNodesPerAccount",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "disableRegistry",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "enableRegistry",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "enabled",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRoleAdmin",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRoleMember",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "index",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRoleMemberCount",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRoleMembers",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "grantRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "hasRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isAccountEligible",
    "inputs": [
      {
        "name": "stakingAccount",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isNodeRegisteredAndEligible",
    "inputs": [
      {
        "name": "nodeAddress",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isNodeRegisteredByAccount",
    "inputs": [
      {
        "name": "nodeAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "managerDeregister",
    "inputs": [
      {
        "name": "nodeAddresses",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "managerForceSync",
    "inputs": [
      {
        "name": "stakingAccounts",
        "type": "address[]",
        "internalType": "address[]"
      },
      {
        "name": "eligibilities",
        "type": "bool[]",
        "internalType": "bool[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "managerRegister",
    "inputs": [
      {
        "name": "stakingAccounts",
        "type": "address[]",
        "internalType": "address[]"
      },
      {
        "name": "nodeAddresses",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "managerSync",
    "inputs": [
      {
        "name": "stakingAccounts",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "maxAdditionalRegistrations",
    "inputs": [
      {
        "name": "stakingAccount",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "nodeRegisterdToAccount",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "renounceRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "callerConfirmation",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "requirementImplementation",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IHoprNetworkRegistryRequirement"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "revokeRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "selfDeregister",
    "inputs": [
      {
        "name": "nodeAddresses",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "selfRegister",
    "inputs": [
      {
        "name": "nodeAddresses",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "selfSync",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "supportsInterface",
    "inputs": [
      {
        "name": "interfaceId",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "updateRequirementImplementation",
    "inputs": [
      {
        "name": "_requirementImplementation",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "Deregistered",
    "inputs": [
      {
        "name": "stakingAccount",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "nodeAddress",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "DeregisteredByManager",
    "inputs": [
      {
        "name": "stakingAccount",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "nodeAddress",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EligibilityUpdated",
    "inputs": [
      {
        "name": "stakingAccount",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "eligibility",
        "type": "bool",
        "indexed": true,
        "internalType": "bool"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "NetworkRegistryStatusUpdated",
    "inputs": [
      {
        "name": "isEnabled",
        "type": "bool",
        "indexed": true,
        "internalType": "bool"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Registered",
    "inputs": [
      {
        "name": "stakingAccount",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "nodeAddress",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RegisteredByManager",
    "inputs": [
      {
        "name": "stakingAccount",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "nodeAddress",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RequirementUpdated",
    "inputs": [
      {
        "name": "requirementImplementation",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleAdminChanged",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "previousAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "newAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleGranted",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleRevoked",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AccessControlBadConfirmation",
    "inputs": []
  },
  {
    "type": "error",
    "name": "AccessControlUnauthorizedAccount",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "neededRole",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "ArrayLengthNotMatch",
    "inputs": []
  },
  {
    "type": "error",
    "name": "CannotOperateForNode",
    "inputs": [
      {
        "name": "nodeAddress",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "GloballyDisabledRegistry",
    "inputs": []
  },
  {
    "type": "error",
    "name": "GloballyEnabledRegistry",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NodeAlreadyRegisterd",
    "inputs": [
      {
        "name": "nodeAddress",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NodeNotYetRegisterd",
    "inputs": [
      {
        "name": "nodeAddress",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NodeRegisterdToOtherAccount",
    "inputs": [
      {
        "name": "nodeAddress",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotEnoughAllowanceToRegisterNode",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ZeroAddress",
    "inputs": [
      {
        "name": "reason",
        "type": "string",
        "internalType": "string"
      }
    ]
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod HoprNetworkRegistry {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x608060405234801561000f575f5ffd5b50604051611c64380380611c6483398101604081905261002e9161035a565b6001600160a01b03831661009f5760405163eac0d38960e01b815260206004820152602c60248201527f5f726571756972656d656e74496d706c656d656e746174696f6e206d7573742060448201526b6e6f7420626520656d70747960a01b60648201526084015b60405180910390fd5b6001600160a01b0382166100f65760405163eac0d38960e01b815260206004820152601b60248201527f5f6e65774f776e6572206d757374206e6f7420626520656d70747900000000006044820152606401610096565b6001600160a01b03811661014d5760405163eac0d38960e01b815260206004820152601a60248201527f5f6d616e61676572206d757374206e6f7420626520656d7074790000000000006044820152606401610096565b6101575f8361020e565b5061016f5f516020611c445f395f51905f528361020e565b506101875f516020611c445f395f51905f528261020e565b50600280546001600160a01b0319166001600160a01b0385169081179091556005805460ff191660011790556040517f8ac4b2eb7749f75c5b99b898e547fd615dd7a424e68356ea196b7dae742d6c32905f90a26040516001907f8bc85f25e3e933978f099408b3bb3eb7630b76f7455f2e205bcbc0a780e17e72905f90a250505061039a565b5f8061021a8484610244565b9050801561023b575f84815260016020526040902061023990846102eb565b505b90505b92915050565b5f828152602081815260408083206001600160a01b038516845290915281205460ff166102e4575f838152602081815260408083206001600160a01b03861684529091529020805460ff1916600117905561029c3390565b6001600160a01b0316826001600160a01b0316847f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a450600161023e565b505f61023e565b5f61023b836001600160a01b0384165f8181526001830160205260408120546102e457508154600181810184555f84815260208082209093018490558454848252828601909352604090209190915561023e565b80516001600160a01b0381168114610355575f5ffd5b919050565b5f5f5f6060848603121561036c575f5ffd5b6103758461033f565b92506103836020850161033f565b91506103916040850161033f565b90509250925092565b61189d806103a75f395ff3fe608060405234801561000f575f5ffd5b50600436106101c6575f3560e01c80639010d07c116100fe578063c7ecab8f1161009e578063cfb3735f1161006e578063cfb3735f146103f7578063d547741f146103ff578063e3d2a07114610412578063ec87621c14610425575f5ffd5b8063c7ecab8f146103a1578063ca15c873146103c9578063caf5f501146103dc578063cbebafe0146103ef575f5ffd5b8063a05e0f6d116100d9578063a05e0f6d14610354578063a217fddf14610367578063a3246ad31461036e578063a5605da51461038e575f5ffd5b80639010d07c1461030e57806391d14854146103395780639c7f643b1461034c575f5ffd5b806336568abe116101695780634eb1805c116101445780634eb1805c146102c25780636ffbf988146102d557806376593a39146102e85780638d753b2d146102fb575f5ffd5b806336568abe1461027d5780633fa584571461029057806341b64965146102af575f5ffd5b806327b040a1116101a457806327b040a11461022f5780632a2deee2146102445780632c33cafb146102575780632f2ff15d1461026a575f5ffd5b806301ffc9a7146101ca578063238dafe0146101f2578063248a9ca3146101ff575b5f5ffd5b6101dd6101d836600461142f565b610439565b60405190151581526020015b60405180910390f35b6005546101dd9060ff1681565b61022161020d366004611456565b5f9081526020819052604090206001015490565b6040519081526020016101e9565b61024261023d366004611488565b610463565b005b610221610252366004611488565b6104c4565b6102426102653660046114e9565b610571565b610242610278366004611528565b6105cf565b61024261028b366004611528565b6105f3565b61022161029e366004611488565b60036020525f908152604090205481565b6102426102bd3660046114e9565b61062b565b6101dd6102d0366004611488565b610742565b6101dd6102e3366004611488565b61078f565b6102426102f63660046114e9565b610799565b610242610309366004611552565b61091c565b61032161031c3660046115be565b610a84565b6040516001600160a01b0390911681526020016101e9565b6101dd610347366004611528565b610a9b565b610242610ac3565b6102426103623660046114e9565b610af1565b6102215f81565b61038161037c366004611456565b610c38565b6040516101e991906115de565b6101dd61039c366004611629565b610c51565b6103216103af366004611488565b60046020525f90815260409020546001600160a01b031681565b6102216103d7366004611456565b610c9d565b6102426103ea36600461167d565b610cb3565b610242610dbe565b610242610e2f565b61024261040d366004611528565b610ea5565b600254610321906001600160a01b031681565b6102215f5160206118285f395f51905f5281565b5f6001600160e01b03198216635a05180f60e01b148061045d575061045d82610ec9565b92915050565b5f5160206118285f395f51905f5261047a81610efd565b600280546001600160a01b0319166001600160a01b0384169081179091556040517f8ac4b2eb7749f75c5b99b898e547fd615dd7a424e68356ea196b7dae742d6c32905f90a25050565b6002546040516359aa274160e11b81526001600160a01b0383811660048301525f92839291169063b3544e8290602401602060405180830381865afa15801561050f573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906105339190611779565b6001600160a01b0384165f90815260036020526040902054909150808211156105685761056081836117a4565b949350505050565b505f9392505050565b5f5160206118285f395f51905f5261058881610efd565b5f5b828110156105c9576105c18484838181106105a7576105a76117b7565b90506020020160208101906105bc9190611488565b610f0a565b60010161058a565b50505050565b5f828152602081905260409020600101546105e981610efd565b6105c98383610f63565b6001600160a01b038116331461061c5760405163334bd91960e11b815260040160405180910390fd5b6106268282610f96565b505050565b5f5160206118285f395f51905f5261064281610efd565b5f5b828110156105c9575f84848381811061065f5761065f6117b7565b90506020020160208101906106749190611488565b6001600160a01b038082165f9081526004602052604090205491925016806106bf57604051631638791560e31b81526001600160a01b03831660048201526024015b60405180910390fd5b6001600160a01b0381165f9081526003602052604081208054916106e2836117cb565b90915550506001600160a01b038083165f8181526004602052604080822080546001600160a01b03191690555191928416917f91760a1001f531ec2bee8602be55ad2b1159465edff5bbcd41d20703742a4d429190a35050600101610644565b5f6001600160a01b03821661075857505f919050565b6001600160a01b038083165f90815260046020526040902054168061077f57505f92915050565b61078881610fc1565b9392505050565b5f61045d82610fc1565b60055460ff166107bc5760405163c42638bb60e01b815260040160405180910390fd5b5f5b818110156108d7575f8383838181106107d9576107d96117b7565b90506020020160208101906107ee9190611488565b6001600160a01b038082165f90815260046020526040902054919250166108153383611070565b6001600160a01b03811661089957335f90815260036020526040812080549161083d836117e0565b90915550506001600160a01b0382165f8181526004602052604080822080546001600160a01b03191633908117909155905190917f0a31ee9d46a828884b81003c8498156ea6aa15b9b54bdd0ef0b533d9eba57e5591a36108cd565b6001600160a01b03811633146108cd57604051635b533ba160e01b81526001600160a01b03831660048201526024016106b6565b50506001016107be565b506108e133610fc1565b6108fe576040516303ee6f5760e21b815260040160405180910390fd5b60405160019033905f5160206118485f395f51905f52905f90a35050565b5f5160206118285f395f51905f5261093381610efd565b8382146109535760405163ed882f7160e01b815260040160405180910390fd5b5f5b84811015610a7c575f848483818110610970576109706117b7565b90506020020160208101906109859190611488565b90505f87878481811061099a5761099a6117b7565b90506020020160208101906109af9190611488565b6001600160a01b038381165f9081526004602052604090205491925016156109f557604051635b533ba160e01b81526001600160a01b03831660048201526024016106b6565b6001600160a01b0381165f908152600360205260408120805491610a18836117e0565b90915550506001600160a01b038281165f8181526004602052604080822080546001600160a01b0319169486169485179055519192917f04e1eaa4da18f7e742a4edbbe9ede36cdf75f793bb03ab2158c0877f1caf2b939190a35050600101610955565b505050505050565b5f828152600160205260408120610788908361110f565b5f918252602082815260408084206001600160a01b0393909316845291905290205460ff1690565b60055460ff16610ae65760405163c42638bb60e01b815260040160405180910390fd5b610aef33610f0a565b565b60055460ff16610b145760405163c42638bb60e01b815260040160405180910390fd5b5f5b81811015610c2a575f838383818110610b3157610b316117b7565b9050602002016020810190610b469190611488565b6001600160a01b038082165f9081526004602052604090205491925016610b6d3383611070565b336001600160a01b03821603610bed57335f908152600360205260408120805491610b97836117cb565b90915550506001600160a01b0382165f8181526004602052604080822080546001600160a01b03191690555133917f159a8ae948fcc6e7f8b5495c0d73e91598440af8a62817246c09edc2c28dba8a91a3610c20565b6001600160a01b03811615610c205760405163bf4fdd7360e01b81526001600160a01b03831660048201526024016106b6565b5050600101610b16565b50610c3433610f0a565b5050565b5f81815260016020526040902060609061045d9061111a565b5f6001600160a01b0383161580610c6f57506001600160a01b038216155b15610c7b57505f61045d565b506001600160a01b039182165f90815260046020526040902054821691161490565b5f81815260016020526040812061045d90611126565b5f5160206118285f395f51905f52610cca81610efd565b81518314610ceb5760405163ed882f7160e01b815260040160405180910390fd5b5f5b83811015610db757828181518110610d0757610d076117b7565b602002602001015115610d64576001858583818110610d2857610d286117b7565b9050602002016020810190610d3d9190611488565b6001600160a01b03165f5160206118485f395f51905f5260405160405180910390a3610daf565b5f858583818110610d7757610d776117b7565b9050602002016020810190610d8c9190611488565b6001600160a01b03165f5160206118485f395f51905f5260405160405180910390a35b600101610ced565b5050505050565b5f5160206118285f395f51905f52610dd581610efd565b60055460ff16610df85760405163c42638bb60e01b815260040160405180910390fd5b6005805460ff191690556040515f907f8bc85f25e3e933978f099408b3bb3eb7630b76f7455f2e205bcbc0a780e17e72908290a250565b5f5160206118285f395f51905f52610e4681610efd565b60055460ff1615610e6a5760405163ed1a0c7760e01b815260040160405180910390fd5b6005805460ff191660019081179091556040517f8bc85f25e3e933978f099408b3bb3eb7630b76f7455f2e205bcbc0a780e17e72905f90a250565b5f82815260208190526040902060010154610ebf81610efd565b6105c98383610f96565b5f6001600160e01b03198216637965db0b60e01b148061045d57506301ffc9a760e01b6001600160e01b031983161461045d565b610f07813361112f565b50565b610f1381610fc1565b15610f3e576040516001906001600160a01b038316905f5160206118485f395f51905f52905f90a350565b6040515f906001600160a01b038316905f5160206118485f395f51905f52908390a350565b5f5f610f6f8484611168565b90508015610788575f848152600160205260409020610f8e90846111f7565b509392505050565b5f5f610fa2848461120b565b90508015610788575f848152600160205260409020610f8e9084611274565b6002546040516359aa274160e11b81526001600160a01b0383811660048301525f92839291169063b3544e8290602401602060405180830381865afa15801561100c573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906110309190611779565b9050805f0361104157505f92915050565b6001600160a01b0383165f9081526003602052604090205481106110685750600192915050565b505f92915050565b600254604051633616b41160e21b81526001600160a01b03848116600483015283811660248301525f92169063d85ad04490604401602060405180830381865afa1580156110c0573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906110e491906117f8565b90508061062657604051630741496760e01b81526001600160a01b03831660048201526024016106b6565b5f6107888383611288565b60605f610788836112ae565b5f61045d825490565b6111398282610a9b565b610c345760405163e2517d3f60e01b81526001600160a01b0382166004820152602481018390526044016106b6565b5f6111738383610a9b565b6111f0575f838152602081815260408083206001600160a01b03861684529091529020805460ff191660011790556111a83390565b6001600160a01b0316826001600160a01b0316847f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a450600161045d565b505f61045d565b5f610788836001600160a01b038416611307565b5f6112168383610a9b565b156111f0575f838152602081815260408083206001600160a01b0386168085529252808320805460ff1916905551339286917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a450600161045d565b5f610788836001600160a01b03841661134c565b5f825f01828154811061129d5761129d6117b7565b905f5260205f200154905092915050565b6060815f018054806020026020016040519081016040528092919081815260200182805480156112fb57602002820191905f5260205f20905b8154815260200190600101908083116112e7575b50505050509050919050565b5f8181526001830160205260408120546111f057508154600181810184555f84815260208082209093018490558454848252828601909352604090209190915561045d565b5f8181526001830160205260408120548015611426575f61136e6001836117a4565b85549091505f90611381906001906117a4565b90508082146113e0575f865f01828154811061139f5761139f6117b7565b905f5260205f200154905080875f0184815481106113bf576113bf6117b7565b5f918252602080832090910192909255918252600188019052604090208390555b85548690806113f1576113f1611813565b600190038181905f5260205f20015f90559055856001015f8681526020019081526020015f205f90556001935050505061045d565b5f91505061045d565b5f6020828403121561143f575f5ffd5b81356001600160e01b031981168114610788575f5ffd5b5f60208284031215611466575f5ffd5b5035919050565b80356001600160a01b0381168114611483575f5ffd5b919050565b5f60208284031215611498575f5ffd5b6107888261146d565b5f5f83601f8401126114b1575f5ffd5b50813567ffffffffffffffff8111156114c8575f5ffd5b6020830191508360208260051b85010111156114e2575f5ffd5b9250929050565b5f5f602083850312156114fa575f5ffd5b823567ffffffffffffffff811115611510575f5ffd5b61151c858286016114a1565b90969095509350505050565b5f5f60408385031215611539575f5ffd5b823591506115496020840161146d565b90509250929050565b5f5f5f5f60408587031215611565575f5ffd5b843567ffffffffffffffff81111561157b575f5ffd5b611587878288016114a1565b909550935050602085013567ffffffffffffffff8111156115a6575f5ffd5b6115b2878288016114a1565b95989497509550505050565b5f5f604083850312156115cf575f5ffd5b50508035926020909101359150565b602080825282518282018190525f918401906040840190835b8181101561161e5783516001600160a01b03168352602093840193909201916001016115f7565b509095945050505050565b5f5f6040838503121561163a575f5ffd5b6116438361146d565b91506115496020840161146d565b634e487b7160e01b5f52604160045260245ffd5b8015158114610f07575f5ffd5b803561148381611665565b5f5f5f6040848603121561168f575f5ffd5b833567ffffffffffffffff8111156116a5575f5ffd5b6116b1868287016114a1565b909450925050602084013567ffffffffffffffff8111156116d0575f5ffd5b8401601f810186136116e0575f5ffd5b803567ffffffffffffffff8111156116fa576116fa611651565b8060051b604051601f19603f830116810181811067ffffffffffffffff8211171561172757611727611651565b604052918252602081840181019290810189841115611744575f5ffd5b6020850194505b8385101561176a5761175c85611672565b81526020948501940161174b565b50809450505050509250925092565b5f60208284031215611789575f5ffd5b5051919050565b634e487b7160e01b5f52601160045260245ffd5b8181038181111561045d5761045d611790565b634e487b7160e01b5f52603260045260245ffd5b5f816117d9576117d9611790565b505f190190565b5f600182016117f1576117f1611790565b5060010190565b5f60208284031215611808575f5ffd5b815161078881611665565b634e487b7160e01b5f52603160045260245ffdfe241ecf16d79d0f8dbfb92cbc07fe17840425976cf0667f022fe9877caa831b08e2994f8d6f600ad473dba82c0a890ab7affacb860d3365f474baa3dc04a2e557a2646970667358221220de1016be1f1dcc735510002b24025c7fd5328e8e9a8c87cc0b5f89ba1223c3ea64736f6c634300081e0033241ecf16d79d0f8dbfb92cbc07fe17840425976cf0667f022fe9877caa831b08
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`@Qa\x1Cd8\x03\x80a\x1Cd\x839\x81\x01`@\x81\x90Ra\0.\x91a\x03ZV[`\x01`\x01`\xA0\x1B\x03\x83\x16a\0\x9FW`@Qc\xEA\xC0\xD3\x89`\xE0\x1B\x81R` `\x04\x82\x01R`,`$\x82\x01R\x7F_requirementImplementation must `D\x82\x01Rknot be empty`\xA0\x1B`d\x82\x01R`\x84\x01[`@Q\x80\x91\x03\x90\xFD[`\x01`\x01`\xA0\x1B\x03\x82\x16a\0\xF6W`@Qc\xEA\xC0\xD3\x89`\xE0\x1B\x81R` `\x04\x82\x01R`\x1B`$\x82\x01R\x7F_newOwner must not be empty\0\0\0\0\0`D\x82\x01R`d\x01a\0\x96V[`\x01`\x01`\xA0\x1B\x03\x81\x16a\x01MW`@Qc\xEA\xC0\xD3\x89`\xE0\x1B\x81R` `\x04\x82\x01R`\x1A`$\x82\x01R\x7F_manager must not be empty\0\0\0\0\0\0`D\x82\x01R`d\x01a\0\x96V[a\x01W_\x83a\x02\x0EV[Pa\x01o_Q` a\x1CD_9_Q\x90_R\x83a\x02\x0EV[Pa\x01\x87_Q` a\x1CD_9_Q\x90_R\x82a\x02\x0EV[P`\x02\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x85\x16\x90\x81\x17\x90\x91U`\x05\x80T`\xFF\x19\x16`\x01\x17\x90U`@Q\x7F\x8A\xC4\xB2\xEBwI\xF7\\[\x99\xB8\x98\xE5G\xFDa]\xD7\xA4$\xE6\x83V\xEA\x19k}\xAEt-l2\x90_\x90\xA2`@Q`\x01\x90\x7F\x8B\xC8_%\xE3\xE93\x97\x8F\t\x94\x08\xB3\xBB>\xB7c\x0Bv\xF7E_. [\xCB\xC0\xA7\x80\xE1~r\x90_\x90\xA2PPPa\x03\x9AV[_\x80a\x02\x1A\x84\x84a\x02DV[\x90P\x80\x15a\x02;W_\x84\x81R`\x01` R`@\x90 a\x029\x90\x84a\x02\xEBV[P[\x90P[\x92\x91PPV[_\x82\x81R` \x81\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x85\x16\x84R\x90\x91R\x81 T`\xFF\x16a\x02\xE4W_\x83\x81R` \x81\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x86\x16\x84R\x90\x91R\x90 \x80T`\xFF\x19\x16`\x01\x17\x90Ua\x02\x9C3\x90V[`\x01`\x01`\xA0\x1B\x03\x16\x82`\x01`\x01`\xA0\x1B\x03\x16\x84\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r`@Q`@Q\x80\x91\x03\x90\xA4P`\x01a\x02>V[P_a\x02>V[_a\x02;\x83`\x01`\x01`\xA0\x1B\x03\x84\x16_\x81\x81R`\x01\x83\x01` R`@\x81 Ta\x02\xE4WP\x81T`\x01\x81\x81\x01\x84U_\x84\x81R` \x80\x82 \x90\x93\x01\x84\x90U\x84T\x84\x82R\x82\x86\x01\x90\x93R`@\x90 \x91\x90\x91Ua\x02>V[\x80Q`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x03UW__\xFD[\x91\x90PV[___``\x84\x86\x03\x12\x15a\x03lW__\xFD[a\x03u\x84a\x03?V[\x92Pa\x03\x83` \x85\x01a\x03?V[\x91Pa\x03\x91`@\x85\x01a\x03?V[\x90P\x92P\x92P\x92V[a\x18\x9D\x80a\x03\xA7_9_\xF3\xFE`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\x01\xC6W_5`\xE0\x1C\x80c\x90\x10\xD0|\x11a\0\xFEW\x80c\xC7\xEC\xAB\x8F\x11a\0\x9EW\x80c\xCF\xB3s_\x11a\0nW\x80c\xCF\xB3s_\x14a\x03\xF7W\x80c\xD5Gt\x1F\x14a\x03\xFFW\x80c\xE3\xD2\xA0q\x14a\x04\x12W\x80c\xEC\x87b\x1C\x14a\x04%W__\xFD[\x80c\xC7\xEC\xAB\x8F\x14a\x03\xA1W\x80c\xCA\x15\xC8s\x14a\x03\xC9W\x80c\xCA\xF5\xF5\x01\x14a\x03\xDCW\x80c\xCB\xEB\xAF\xE0\x14a\x03\xEFW__\xFD[\x80c\xA0^\x0Fm\x11a\0\xD9W\x80c\xA0^\x0Fm\x14a\x03TW\x80c\xA2\x17\xFD\xDF\x14a\x03gW\x80c\xA3$j\xD3\x14a\x03nW\x80c\xA5`]\xA5\x14a\x03\x8EW__\xFD[\x80c\x90\x10\xD0|\x14a\x03\x0EW\x80c\x91\xD1HT\x14a\x039W\x80c\x9C\x7Fd;\x14a\x03LW__\xFD[\x80c6V\x8A\xBE\x11a\x01iW\x80cN\xB1\x80\\\x11a\x01DW\x80cN\xB1\x80\\\x14a\x02\xC2W\x80co\xFB\xF9\x88\x14a\x02\xD5W\x80cvY:9\x14a\x02\xE8W\x80c\x8Du;-\x14a\x02\xFBW__\xFD[\x80c6V\x8A\xBE\x14a\x02}W\x80c?\xA5\x84W\x14a\x02\x90W\x80cA\xB6Ie\x14a\x02\xAFW__\xFD[\x80c'\xB0@\xA1\x11a\x01\xA4W\x80c'\xB0@\xA1\x14a\x02/W\x80c*-\xEE\xE2\x14a\x02DW\x80c,3\xCA\xFB\x14a\x02WW\x80c//\xF1]\x14a\x02jW__\xFD[\x80c\x01\xFF\xC9\xA7\x14a\x01\xCAW\x80c#\x8D\xAF\xE0\x14a\x01\xF2W\x80c$\x8A\x9C\xA3\x14a\x01\xFFW[__\xFD[a\x01\xDDa\x01\xD86`\x04a\x14/V[a\x049V[`@Q\x90\x15\x15\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[`\x05Ta\x01\xDD\x90`\xFF\x16\x81V[a\x02!a\x02\r6`\x04a\x14VV[_\x90\x81R` \x81\x90R`@\x90 `\x01\x01T\x90V[`@Q\x90\x81R` \x01a\x01\xE9V[a\x02Ba\x02=6`\x04a\x14\x88V[a\x04cV[\0[a\x02!a\x02R6`\x04a\x14\x88V[a\x04\xC4V[a\x02Ba\x02e6`\x04a\x14\xE9V[a\x05qV[a\x02Ba\x02x6`\x04a\x15(V[a\x05\xCFV[a\x02Ba\x02\x8B6`\x04a\x15(V[a\x05\xF3V[a\x02!a\x02\x9E6`\x04a\x14\x88V[`\x03` R_\x90\x81R`@\x90 T\x81V[a\x02Ba\x02\xBD6`\x04a\x14\xE9V[a\x06+V[a\x01\xDDa\x02\xD06`\x04a\x14\x88V[a\x07BV[a\x01\xDDa\x02\xE36`\x04a\x14\x88V[a\x07\x8FV[a\x02Ba\x02\xF66`\x04a\x14\xE9V[a\x07\x99V[a\x02Ba\x03\t6`\x04a\x15RV[a\t\x1CV[a\x03!a\x03\x1C6`\x04a\x15\xBEV[a\n\x84V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\x01\xE9V[a\x01\xDDa\x03G6`\x04a\x15(V[a\n\x9BV[a\x02Ba\n\xC3V[a\x02Ba\x03b6`\x04a\x14\xE9V[a\n\xF1V[a\x02!_\x81V[a\x03\x81a\x03|6`\x04a\x14VV[a\x0C8V[`@Qa\x01\xE9\x91\x90a\x15\xDEV[a\x01\xDDa\x03\x9C6`\x04a\x16)V[a\x0CQV[a\x03!a\x03\xAF6`\x04a\x14\x88V[`\x04` R_\x90\x81R`@\x90 T`\x01`\x01`\xA0\x1B\x03\x16\x81V[a\x02!a\x03\xD76`\x04a\x14VV[a\x0C\x9DV[a\x02Ba\x03\xEA6`\x04a\x16}V[a\x0C\xB3V[a\x02Ba\r\xBEV[a\x02Ba\x0E/V[a\x02Ba\x04\r6`\x04a\x15(V[a\x0E\xA5V[`\x02Ta\x03!\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[a\x02!_Q` a\x18(_9_Q\x90_R\x81V[_`\x01`\x01`\xE0\x1B\x03\x19\x82\x16cZ\x05\x18\x0F`\xE0\x1B\x14\x80a\x04]WPa\x04]\x82a\x0E\xC9V[\x92\x91PPV[_Q` a\x18(_9_Q\x90_Ra\x04z\x81a\x0E\xFDV[`\x02\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x84\x16\x90\x81\x17\x90\x91U`@Q\x7F\x8A\xC4\xB2\xEBwI\xF7\\[\x99\xB8\x98\xE5G\xFDa]\xD7\xA4$\xE6\x83V\xEA\x19k}\xAEt-l2\x90_\x90\xA2PPV[`\x02T`@QcY\xAA'A`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\x04\x83\x01R_\x92\x83\x92\x91\x16\x90c\xB3TN\x82\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x05\x0FW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x053\x91\x90a\x17yV[`\x01`\x01`\xA0\x1B\x03\x84\x16_\x90\x81R`\x03` R`@\x90 T\x90\x91P\x80\x82\x11\x15a\x05hWa\x05`\x81\x83a\x17\xA4V[\x94\x93PPPPV[P_\x93\x92PPPV[_Q` a\x18(_9_Q\x90_Ra\x05\x88\x81a\x0E\xFDV[_[\x82\x81\x10\x15a\x05\xC9Wa\x05\xC1\x84\x84\x83\x81\x81\x10a\x05\xA7Wa\x05\xA7a\x17\xB7V[\x90P` \x02\x01` \x81\x01\x90a\x05\xBC\x91\x90a\x14\x88V[a\x0F\nV[`\x01\x01a\x05\x8AV[PPPPV[_\x82\x81R` \x81\x90R`@\x90 `\x01\x01Ta\x05\xE9\x81a\x0E\xFDV[a\x05\xC9\x83\x83a\x0FcV[`\x01`\x01`\xA0\x1B\x03\x81\x163\x14a\x06\x1CW`@Qc3K\xD9\x19`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x06&\x82\x82a\x0F\x96V[PPPV[_Q` a\x18(_9_Q\x90_Ra\x06B\x81a\x0E\xFDV[_[\x82\x81\x10\x15a\x05\xC9W_\x84\x84\x83\x81\x81\x10a\x06_Wa\x06_a\x17\xB7V[\x90P` \x02\x01` \x81\x01\x90a\x06t\x91\x90a\x14\x88V[`\x01`\x01`\xA0\x1B\x03\x80\x82\x16_\x90\x81R`\x04` R`@\x90 T\x91\x92P\x16\x80a\x06\xBFW`@Qc\x168y\x15`\xE3\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16`\x04\x82\x01R`$\x01[`@Q\x80\x91\x03\x90\xFD[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R`\x03` R`@\x81 \x80T\x91a\x06\xE2\x83a\x17\xCBV[\x90\x91UPP`\x01`\x01`\xA0\x1B\x03\x80\x83\x16_\x81\x81R`\x04` R`@\x80\x82 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16\x90UQ\x91\x92\x84\x16\x91\x7F\x91v\n\x10\x01\xF51\xEC+\xEE\x86\x02\xBEU\xAD+\x11YF^\xDF\xF5\xBB\xCDA\xD2\x07\x03t*MB\x91\x90\xA3PP`\x01\x01a\x06DV[_`\x01`\x01`\xA0\x1B\x03\x82\x16a\x07XWP_\x91\x90PV[`\x01`\x01`\xA0\x1B\x03\x80\x83\x16_\x90\x81R`\x04` R`@\x90 T\x16\x80a\x07\x7FWP_\x92\x91PPV[a\x07\x88\x81a\x0F\xC1V[\x93\x92PPPV[_a\x04]\x82a\x0F\xC1V[`\x05T`\xFF\x16a\x07\xBCW`@Qc\xC4&8\xBB`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_[\x81\x81\x10\x15a\x08\xD7W_\x83\x83\x83\x81\x81\x10a\x07\xD9Wa\x07\xD9a\x17\xB7V[\x90P` \x02\x01` \x81\x01\x90a\x07\xEE\x91\x90a\x14\x88V[`\x01`\x01`\xA0\x1B\x03\x80\x82\x16_\x90\x81R`\x04` R`@\x90 T\x91\x92P\x16a\x08\x153\x83a\x10pV[`\x01`\x01`\xA0\x1B\x03\x81\x16a\x08\x99W3_\x90\x81R`\x03` R`@\x81 \x80T\x91a\x08=\x83a\x17\xE0V[\x90\x91UPP`\x01`\x01`\xA0\x1B\x03\x82\x16_\x81\x81R`\x04` R`@\x80\x82 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x163\x90\x81\x17\x90\x91U\x90Q\x90\x91\x7F\n1\xEE\x9DF\xA8(\x88K\x81\0<\x84\x98\x15n\xA6\xAA\x15\xB9\xB5K\xDD\x0E\xF0\xB53\xD9\xEB\xA5~U\x91\xA3a\x08\xCDV[`\x01`\x01`\xA0\x1B\x03\x81\x163\x14a\x08\xCDW`@Qc[S;\xA1`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16`\x04\x82\x01R`$\x01a\x06\xB6V[PP`\x01\x01a\x07\xBEV[Pa\x08\xE13a\x0F\xC1V[a\x08\xFEW`@Qc\x03\xEEoW`\xE2\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@Q`\x01\x903\x90_Q` a\x18H_9_Q\x90_R\x90_\x90\xA3PPV[_Q` a\x18(_9_Q\x90_Ra\t3\x81a\x0E\xFDV[\x83\x82\x14a\tSW`@Qc\xED\x88/q`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_[\x84\x81\x10\x15a\n|W_\x84\x84\x83\x81\x81\x10a\tpWa\tpa\x17\xB7V[\x90P` \x02\x01` \x81\x01\x90a\t\x85\x91\x90a\x14\x88V[\x90P_\x87\x87\x84\x81\x81\x10a\t\x9AWa\t\x9Aa\x17\xB7V[\x90P` \x02\x01` \x81\x01\x90a\t\xAF\x91\x90a\x14\x88V[`\x01`\x01`\xA0\x1B\x03\x83\x81\x16_\x90\x81R`\x04` R`@\x90 T\x91\x92P\x16\x15a\t\xF5W`@Qc[S;\xA1`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16`\x04\x82\x01R`$\x01a\x06\xB6V[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R`\x03` R`@\x81 \x80T\x91a\n\x18\x83a\x17\xE0V[\x90\x91UPP`\x01`\x01`\xA0\x1B\x03\x82\x81\x16_\x81\x81R`\x04` R`@\x80\x82 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16\x94\x86\x16\x94\x85\x17\x90UQ\x91\x92\x91\x7F\x04\xE1\xEA\xA4\xDA\x18\xF7\xE7B\xA4\xED\xBB\xE9\xED\xE3l\xDFu\xF7\x93\xBB\x03\xAB!X\xC0\x87\x7F\x1C\xAF+\x93\x91\x90\xA3PP`\x01\x01a\tUV[PPPPPPV[_\x82\x81R`\x01` R`@\x81 a\x07\x88\x90\x83a\x11\x0FV[_\x91\x82R` \x82\x81R`@\x80\x84 `\x01`\x01`\xA0\x1B\x03\x93\x90\x93\x16\x84R\x91\x90R\x90 T`\xFF\x16\x90V[`\x05T`\xFF\x16a\n\xE6W`@Qc\xC4&8\xBB`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\n\xEF3a\x0F\nV[V[`\x05T`\xFF\x16a\x0B\x14W`@Qc\xC4&8\xBB`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_[\x81\x81\x10\x15a\x0C*W_\x83\x83\x83\x81\x81\x10a\x0B1Wa\x0B1a\x17\xB7V[\x90P` \x02\x01` \x81\x01\x90a\x0BF\x91\x90a\x14\x88V[`\x01`\x01`\xA0\x1B\x03\x80\x82\x16_\x90\x81R`\x04` R`@\x90 T\x91\x92P\x16a\x0Bm3\x83a\x10pV[3`\x01`\x01`\xA0\x1B\x03\x82\x16\x03a\x0B\xEDW3_\x90\x81R`\x03` R`@\x81 \x80T\x91a\x0B\x97\x83a\x17\xCBV[\x90\x91UPP`\x01`\x01`\xA0\x1B\x03\x82\x16_\x81\x81R`\x04` R`@\x80\x82 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16\x90UQ3\x91\x7F\x15\x9A\x8A\xE9H\xFC\xC6\xE7\xF8\xB5I\\\rs\xE9\x15\x98D\n\xF8\xA6(\x17$l\t\xED\xC2\xC2\x8D\xBA\x8A\x91\xA3a\x0C V[`\x01`\x01`\xA0\x1B\x03\x81\x16\x15a\x0C W`@Qc\xBFO\xDDs`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16`\x04\x82\x01R`$\x01a\x06\xB6V[PP`\x01\x01a\x0B\x16V[Pa\x0C43a\x0F\nV[PPV[_\x81\x81R`\x01` R`@\x90 ``\x90a\x04]\x90a\x11\x1AV[_`\x01`\x01`\xA0\x1B\x03\x83\x16\x15\x80a\x0CoWP`\x01`\x01`\xA0\x1B\x03\x82\x16\x15[\x15a\x0C{WP_a\x04]V[P`\x01`\x01`\xA0\x1B\x03\x91\x82\x16_\x90\x81R`\x04` R`@\x90 T\x82\x16\x91\x16\x14\x90V[_\x81\x81R`\x01` R`@\x81 a\x04]\x90a\x11&V[_Q` a\x18(_9_Q\x90_Ra\x0C\xCA\x81a\x0E\xFDV[\x81Q\x83\x14a\x0C\xEBW`@Qc\xED\x88/q`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_[\x83\x81\x10\x15a\r\xB7W\x82\x81\x81Q\x81\x10a\r\x07Wa\r\x07a\x17\xB7V[` \x02` \x01\x01Q\x15a\rdW`\x01\x85\x85\x83\x81\x81\x10a\r(Wa\r(a\x17\xB7V[\x90P` \x02\x01` \x81\x01\x90a\r=\x91\x90a\x14\x88V[`\x01`\x01`\xA0\x1B\x03\x16_Q` a\x18H_9_Q\x90_R`@Q`@Q\x80\x91\x03\x90\xA3a\r\xAFV[_\x85\x85\x83\x81\x81\x10a\rwWa\rwa\x17\xB7V[\x90P` \x02\x01` \x81\x01\x90a\r\x8C\x91\x90a\x14\x88V[`\x01`\x01`\xA0\x1B\x03\x16_Q` a\x18H_9_Q\x90_R`@Q`@Q\x80\x91\x03\x90\xA3[`\x01\x01a\x0C\xEDV[PPPPPV[_Q` a\x18(_9_Q\x90_Ra\r\xD5\x81a\x0E\xFDV[`\x05T`\xFF\x16a\r\xF8W`@Qc\xC4&8\xBB`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x05\x80T`\xFF\x19\x16\x90U`@Q_\x90\x7F\x8B\xC8_%\xE3\xE93\x97\x8F\t\x94\x08\xB3\xBB>\xB7c\x0Bv\xF7E_. [\xCB\xC0\xA7\x80\xE1~r\x90\x82\x90\xA2PV[_Q` a\x18(_9_Q\x90_Ra\x0EF\x81a\x0E\xFDV[`\x05T`\xFF\x16\x15a\x0EjW`@Qc\xED\x1A\x0Cw`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x05\x80T`\xFF\x19\x16`\x01\x90\x81\x17\x90\x91U`@Q\x7F\x8B\xC8_%\xE3\xE93\x97\x8F\t\x94\x08\xB3\xBB>\xB7c\x0Bv\xF7E_. [\xCB\xC0\xA7\x80\xE1~r\x90_\x90\xA2PV[_\x82\x81R` \x81\x90R`@\x90 `\x01\x01Ta\x0E\xBF\x81a\x0E\xFDV[a\x05\xC9\x83\x83a\x0F\x96V[_`\x01`\x01`\xE0\x1B\x03\x19\x82\x16cye\xDB\x0B`\xE0\x1B\x14\x80a\x04]WPc\x01\xFF\xC9\xA7`\xE0\x1B`\x01`\x01`\xE0\x1B\x03\x19\x83\x16\x14a\x04]V[a\x0F\x07\x813a\x11/V[PV[a\x0F\x13\x81a\x0F\xC1V[\x15a\x0F>W`@Q`\x01\x90`\x01`\x01`\xA0\x1B\x03\x83\x16\x90_Q` a\x18H_9_Q\x90_R\x90_\x90\xA3PV[`@Q_\x90`\x01`\x01`\xA0\x1B\x03\x83\x16\x90_Q` a\x18H_9_Q\x90_R\x90\x83\x90\xA3PV[__a\x0Fo\x84\x84a\x11hV[\x90P\x80\x15a\x07\x88W_\x84\x81R`\x01` R`@\x90 a\x0F\x8E\x90\x84a\x11\xF7V[P\x93\x92PPPV[__a\x0F\xA2\x84\x84a\x12\x0BV[\x90P\x80\x15a\x07\x88W_\x84\x81R`\x01` R`@\x90 a\x0F\x8E\x90\x84a\x12tV[`\x02T`@QcY\xAA'A`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\x04\x83\x01R_\x92\x83\x92\x91\x16\x90c\xB3TN\x82\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x10\x0CW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x100\x91\x90a\x17yV[\x90P\x80_\x03a\x10AWP_\x92\x91PPV[`\x01`\x01`\xA0\x1B\x03\x83\x16_\x90\x81R`\x03` R`@\x90 T\x81\x10a\x10hWP`\x01\x92\x91PPV[P_\x92\x91PPV[`\x02T`@Qc6\x16\xB4\x11`\xE2\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x84\x81\x16`\x04\x83\x01R\x83\x81\x16`$\x83\x01R_\x92\x16\x90c\xD8Z\xD0D\x90`D\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x10\xC0W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x10\xE4\x91\x90a\x17\xF8V[\x90P\x80a\x06&W`@Qc\x07AIg`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16`\x04\x82\x01R`$\x01a\x06\xB6V[_a\x07\x88\x83\x83a\x12\x88V[``_a\x07\x88\x83a\x12\xAEV[_a\x04]\x82T\x90V[a\x119\x82\x82a\n\x9BV[a\x0C4W`@Qc\xE2Q}?`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x82\x16`\x04\x82\x01R`$\x81\x01\x83\x90R`D\x01a\x06\xB6V[_a\x11s\x83\x83a\n\x9BV[a\x11\xF0W_\x83\x81R` \x81\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x86\x16\x84R\x90\x91R\x90 \x80T`\xFF\x19\x16`\x01\x17\x90Ua\x11\xA83\x90V[`\x01`\x01`\xA0\x1B\x03\x16\x82`\x01`\x01`\xA0\x1B\x03\x16\x84\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r`@Q`@Q\x80\x91\x03\x90\xA4P`\x01a\x04]V[P_a\x04]V[_a\x07\x88\x83`\x01`\x01`\xA0\x1B\x03\x84\x16a\x13\x07V[_a\x12\x16\x83\x83a\n\x9BV[\x15a\x11\xF0W_\x83\x81R` \x81\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x86\x16\x80\x85R\x92R\x80\x83 \x80T`\xFF\x19\x16\x90UQ3\x92\x86\x91\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B\x91\x90\xA4P`\x01a\x04]V[_a\x07\x88\x83`\x01`\x01`\xA0\x1B\x03\x84\x16a\x13LV[_\x82_\x01\x82\x81T\x81\x10a\x12\x9DWa\x12\x9Da\x17\xB7V[\x90_R` _ \x01T\x90P\x92\x91PPV[``\x81_\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80T\x80\x15a\x12\xFBW` \x02\x82\x01\x91\x90_R` _ \x90[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x12\xE7W[PPPPP\x90P\x91\x90PV[_\x81\x81R`\x01\x83\x01` R`@\x81 Ta\x11\xF0WP\x81T`\x01\x81\x81\x01\x84U_\x84\x81R` \x80\x82 \x90\x93\x01\x84\x90U\x84T\x84\x82R\x82\x86\x01\x90\x93R`@\x90 \x91\x90\x91Ua\x04]V[_\x81\x81R`\x01\x83\x01` R`@\x81 T\x80\x15a\x14&W_a\x13n`\x01\x83a\x17\xA4V[\x85T\x90\x91P_\x90a\x13\x81\x90`\x01\x90a\x17\xA4V[\x90P\x80\x82\x14a\x13\xE0W_\x86_\x01\x82\x81T\x81\x10a\x13\x9FWa\x13\x9Fa\x17\xB7V[\x90_R` _ \x01T\x90P\x80\x87_\x01\x84\x81T\x81\x10a\x13\xBFWa\x13\xBFa\x17\xB7V[_\x91\x82R` \x80\x83 \x90\x91\x01\x92\x90\x92U\x91\x82R`\x01\x88\x01\x90R`@\x90 \x83\x90U[\x85T\x86\x90\x80a\x13\xF1Wa\x13\xF1a\x18\x13V[`\x01\x90\x03\x81\x81\x90_R` _ \x01_\x90U\x90U\x85`\x01\x01_\x86\x81R` \x01\x90\x81R` \x01_ _\x90U`\x01\x93PPPPa\x04]V[_\x91PPa\x04]V[_` \x82\x84\x03\x12\x15a\x14?W__\xFD[\x815`\x01`\x01`\xE0\x1B\x03\x19\x81\x16\x81\x14a\x07\x88W__\xFD[_` \x82\x84\x03\x12\x15a\x14fW__\xFD[P5\x91\x90PV[\x805`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x14\x83W__\xFD[\x91\x90PV[_` \x82\x84\x03\x12\x15a\x14\x98W__\xFD[a\x07\x88\x82a\x14mV[__\x83`\x1F\x84\x01\x12a\x14\xB1W__\xFD[P\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x14\xC8W__\xFD[` \x83\x01\x91P\x83` \x82`\x05\x1B\x85\x01\x01\x11\x15a\x14\xE2W__\xFD[\x92P\x92\x90PV[__` \x83\x85\x03\x12\x15a\x14\xFAW__\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x15\x10W__\xFD[a\x15\x1C\x85\x82\x86\x01a\x14\xA1V[\x90\x96\x90\x95P\x93PPPPV[__`@\x83\x85\x03\x12\x15a\x159W__\xFD[\x825\x91Pa\x15I` \x84\x01a\x14mV[\x90P\x92P\x92\x90PV[____`@\x85\x87\x03\x12\x15a\x15eW__\xFD[\x845g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x15{W__\xFD[a\x15\x87\x87\x82\x88\x01a\x14\xA1V[\x90\x95P\x93PP` \x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x15\xA6W__\xFD[a\x15\xB2\x87\x82\x88\x01a\x14\xA1V[\x95\x98\x94\x97P\x95PPPPV[__`@\x83\x85\x03\x12\x15a\x15\xCFW__\xFD[PP\x805\x92` \x90\x91\x015\x91PV[` \x80\x82R\x82Q\x82\x82\x01\x81\x90R_\x91\x84\x01\x90`@\x84\x01\x90\x83[\x81\x81\x10\x15a\x16\x1EW\x83Q`\x01`\x01`\xA0\x1B\x03\x16\x83R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01a\x15\xF7V[P\x90\x95\x94PPPPPV[__`@\x83\x85\x03\x12\x15a\x16:W__\xFD[a\x16C\x83a\x14mV[\x91Pa\x15I` \x84\x01a\x14mV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x80\x15\x15\x81\x14a\x0F\x07W__\xFD[\x805a\x14\x83\x81a\x16eV[___`@\x84\x86\x03\x12\x15a\x16\x8FW__\xFD[\x835g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x16\xA5W__\xFD[a\x16\xB1\x86\x82\x87\x01a\x14\xA1V[\x90\x94P\x92PP` \x84\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x16\xD0W__\xFD[\x84\x01`\x1F\x81\x01\x86\x13a\x16\xE0W__\xFD[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x16\xFAWa\x16\xFAa\x16QV[\x80`\x05\x1B`@Q`\x1F\x19`?\x83\x01\x16\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15a\x17'Wa\x17'a\x16QV[`@R\x91\x82R` \x81\x84\x01\x81\x01\x92\x90\x81\x01\x89\x84\x11\x15a\x17DW__\xFD[` \x85\x01\x94P[\x83\x85\x10\x15a\x17jWa\x17\\\x85a\x16rV[\x81R` \x94\x85\x01\x94\x01a\x17KV[P\x80\x94PPPPP\x92P\x92P\x92V[_` \x82\x84\x03\x12\x15a\x17\x89W__\xFD[PQ\x91\x90PV[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[\x81\x81\x03\x81\x81\x11\x15a\x04]Wa\x04]a\x17\x90V[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[_\x81a\x17\xD9Wa\x17\xD9a\x17\x90V[P_\x19\x01\x90V[_`\x01\x82\x01a\x17\xF1Wa\x17\xF1a\x17\x90V[P`\x01\x01\x90V[_` \x82\x84\x03\x12\x15a\x18\x08W__\xFD[\x81Qa\x07\x88\x81a\x16eV[cNH{q`\xE0\x1B_R`1`\x04R`$_\xFD\xFE$\x1E\xCF\x16\xD7\x9D\x0F\x8D\xBF\xB9,\xBC\x07\xFE\x17\x84\x04%\x97l\xF0f\x7F\x02/\xE9\x87|\xAA\x83\x1B\x08\xE2\x99O\x8Do`\n\xD4s\xDB\xA8,\n\x89\n\xB7\xAF\xFA\xCB\x86\r3e\xF4t\xBA\xA3\xDC\x04\xA2\xE5W\xA2dipfsX\"\x12 \xDE\x10\x16\xBE\x1F\x1D\xCCsU\x10\0+$\x02\\\x7F\xD52\x8E\x8E\x9A\x8C\x87\xCC\x0B_\x89\xBA\x12#\xC3\xEAdsolcC\0\x08\x1E\x003$\x1E\xCF\x16\xD7\x9D\x0F\x8D\xBF\xB9,\xBC\x07\xFE\x17\x84\x04%\x97l\xF0f\x7F\x02/\xE9\x87|\xAA\x83\x1B\x08",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561000f575f5ffd5b50600436106101c6575f3560e01c80639010d07c116100fe578063c7ecab8f1161009e578063cfb3735f1161006e578063cfb3735f146103f7578063d547741f146103ff578063e3d2a07114610412578063ec87621c14610425575f5ffd5b8063c7ecab8f146103a1578063ca15c873146103c9578063caf5f501146103dc578063cbebafe0146103ef575f5ffd5b8063a05e0f6d116100d9578063a05e0f6d14610354578063a217fddf14610367578063a3246ad31461036e578063a5605da51461038e575f5ffd5b80639010d07c1461030e57806391d14854146103395780639c7f643b1461034c575f5ffd5b806336568abe116101695780634eb1805c116101445780634eb1805c146102c25780636ffbf988146102d557806376593a39146102e85780638d753b2d146102fb575f5ffd5b806336568abe1461027d5780633fa584571461029057806341b64965146102af575f5ffd5b806327b040a1116101a457806327b040a11461022f5780632a2deee2146102445780632c33cafb146102575780632f2ff15d1461026a575f5ffd5b806301ffc9a7146101ca578063238dafe0146101f2578063248a9ca3146101ff575b5f5ffd5b6101dd6101d836600461142f565b610439565b60405190151581526020015b60405180910390f35b6005546101dd9060ff1681565b61022161020d366004611456565b5f9081526020819052604090206001015490565b6040519081526020016101e9565b61024261023d366004611488565b610463565b005b610221610252366004611488565b6104c4565b6102426102653660046114e9565b610571565b610242610278366004611528565b6105cf565b61024261028b366004611528565b6105f3565b61022161029e366004611488565b60036020525f908152604090205481565b6102426102bd3660046114e9565b61062b565b6101dd6102d0366004611488565b610742565b6101dd6102e3366004611488565b61078f565b6102426102f63660046114e9565b610799565b610242610309366004611552565b61091c565b61032161031c3660046115be565b610a84565b6040516001600160a01b0390911681526020016101e9565b6101dd610347366004611528565b610a9b565b610242610ac3565b6102426103623660046114e9565b610af1565b6102215f81565b61038161037c366004611456565b610c38565b6040516101e991906115de565b6101dd61039c366004611629565b610c51565b6103216103af366004611488565b60046020525f90815260409020546001600160a01b031681565b6102216103d7366004611456565b610c9d565b6102426103ea36600461167d565b610cb3565b610242610dbe565b610242610e2f565b61024261040d366004611528565b610ea5565b600254610321906001600160a01b031681565b6102215f5160206118285f395f51905f5281565b5f6001600160e01b03198216635a05180f60e01b148061045d575061045d82610ec9565b92915050565b5f5160206118285f395f51905f5261047a81610efd565b600280546001600160a01b0319166001600160a01b0384169081179091556040517f8ac4b2eb7749f75c5b99b898e547fd615dd7a424e68356ea196b7dae742d6c32905f90a25050565b6002546040516359aa274160e11b81526001600160a01b0383811660048301525f92839291169063b3544e8290602401602060405180830381865afa15801561050f573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906105339190611779565b6001600160a01b0384165f90815260036020526040902054909150808211156105685761056081836117a4565b949350505050565b505f9392505050565b5f5160206118285f395f51905f5261058881610efd565b5f5b828110156105c9576105c18484838181106105a7576105a76117b7565b90506020020160208101906105bc9190611488565b610f0a565b60010161058a565b50505050565b5f828152602081905260409020600101546105e981610efd565b6105c98383610f63565b6001600160a01b038116331461061c5760405163334bd91960e11b815260040160405180910390fd5b6106268282610f96565b505050565b5f5160206118285f395f51905f5261064281610efd565b5f5b828110156105c9575f84848381811061065f5761065f6117b7565b90506020020160208101906106749190611488565b6001600160a01b038082165f9081526004602052604090205491925016806106bf57604051631638791560e31b81526001600160a01b03831660048201526024015b60405180910390fd5b6001600160a01b0381165f9081526003602052604081208054916106e2836117cb565b90915550506001600160a01b038083165f8181526004602052604080822080546001600160a01b03191690555191928416917f91760a1001f531ec2bee8602be55ad2b1159465edff5bbcd41d20703742a4d429190a35050600101610644565b5f6001600160a01b03821661075857505f919050565b6001600160a01b038083165f90815260046020526040902054168061077f57505f92915050565b61078881610fc1565b9392505050565b5f61045d82610fc1565b60055460ff166107bc5760405163c42638bb60e01b815260040160405180910390fd5b5f5b818110156108d7575f8383838181106107d9576107d96117b7565b90506020020160208101906107ee9190611488565b6001600160a01b038082165f90815260046020526040902054919250166108153383611070565b6001600160a01b03811661089957335f90815260036020526040812080549161083d836117e0565b90915550506001600160a01b0382165f8181526004602052604080822080546001600160a01b03191633908117909155905190917f0a31ee9d46a828884b81003c8498156ea6aa15b9b54bdd0ef0b533d9eba57e5591a36108cd565b6001600160a01b03811633146108cd57604051635b533ba160e01b81526001600160a01b03831660048201526024016106b6565b50506001016107be565b506108e133610fc1565b6108fe576040516303ee6f5760e21b815260040160405180910390fd5b60405160019033905f5160206118485f395f51905f52905f90a35050565b5f5160206118285f395f51905f5261093381610efd565b8382146109535760405163ed882f7160e01b815260040160405180910390fd5b5f5b84811015610a7c575f848483818110610970576109706117b7565b90506020020160208101906109859190611488565b90505f87878481811061099a5761099a6117b7565b90506020020160208101906109af9190611488565b6001600160a01b038381165f9081526004602052604090205491925016156109f557604051635b533ba160e01b81526001600160a01b03831660048201526024016106b6565b6001600160a01b0381165f908152600360205260408120805491610a18836117e0565b90915550506001600160a01b038281165f8181526004602052604080822080546001600160a01b0319169486169485179055519192917f04e1eaa4da18f7e742a4edbbe9ede36cdf75f793bb03ab2158c0877f1caf2b939190a35050600101610955565b505050505050565b5f828152600160205260408120610788908361110f565b5f918252602082815260408084206001600160a01b0393909316845291905290205460ff1690565b60055460ff16610ae65760405163c42638bb60e01b815260040160405180910390fd5b610aef33610f0a565b565b60055460ff16610b145760405163c42638bb60e01b815260040160405180910390fd5b5f5b81811015610c2a575f838383818110610b3157610b316117b7565b9050602002016020810190610b469190611488565b6001600160a01b038082165f9081526004602052604090205491925016610b6d3383611070565b336001600160a01b03821603610bed57335f908152600360205260408120805491610b97836117cb565b90915550506001600160a01b0382165f8181526004602052604080822080546001600160a01b03191690555133917f159a8ae948fcc6e7f8b5495c0d73e91598440af8a62817246c09edc2c28dba8a91a3610c20565b6001600160a01b03811615610c205760405163bf4fdd7360e01b81526001600160a01b03831660048201526024016106b6565b5050600101610b16565b50610c3433610f0a565b5050565b5f81815260016020526040902060609061045d9061111a565b5f6001600160a01b0383161580610c6f57506001600160a01b038216155b15610c7b57505f61045d565b506001600160a01b039182165f90815260046020526040902054821691161490565b5f81815260016020526040812061045d90611126565b5f5160206118285f395f51905f52610cca81610efd565b81518314610ceb5760405163ed882f7160e01b815260040160405180910390fd5b5f5b83811015610db757828181518110610d0757610d076117b7565b602002602001015115610d64576001858583818110610d2857610d286117b7565b9050602002016020810190610d3d9190611488565b6001600160a01b03165f5160206118485f395f51905f5260405160405180910390a3610daf565b5f858583818110610d7757610d776117b7565b9050602002016020810190610d8c9190611488565b6001600160a01b03165f5160206118485f395f51905f5260405160405180910390a35b600101610ced565b5050505050565b5f5160206118285f395f51905f52610dd581610efd565b60055460ff16610df85760405163c42638bb60e01b815260040160405180910390fd5b6005805460ff191690556040515f907f8bc85f25e3e933978f099408b3bb3eb7630b76f7455f2e205bcbc0a780e17e72908290a250565b5f5160206118285f395f51905f52610e4681610efd565b60055460ff1615610e6a5760405163ed1a0c7760e01b815260040160405180910390fd5b6005805460ff191660019081179091556040517f8bc85f25e3e933978f099408b3bb3eb7630b76f7455f2e205bcbc0a780e17e72905f90a250565b5f82815260208190526040902060010154610ebf81610efd565b6105c98383610f96565b5f6001600160e01b03198216637965db0b60e01b148061045d57506301ffc9a760e01b6001600160e01b031983161461045d565b610f07813361112f565b50565b610f1381610fc1565b15610f3e576040516001906001600160a01b038316905f5160206118485f395f51905f52905f90a350565b6040515f906001600160a01b038316905f5160206118485f395f51905f52908390a350565b5f5f610f6f8484611168565b90508015610788575f848152600160205260409020610f8e90846111f7565b509392505050565b5f5f610fa2848461120b565b90508015610788575f848152600160205260409020610f8e9084611274565b6002546040516359aa274160e11b81526001600160a01b0383811660048301525f92839291169063b3544e8290602401602060405180830381865afa15801561100c573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906110309190611779565b9050805f0361104157505f92915050565b6001600160a01b0383165f9081526003602052604090205481106110685750600192915050565b505f92915050565b600254604051633616b41160e21b81526001600160a01b03848116600483015283811660248301525f92169063d85ad04490604401602060405180830381865afa1580156110c0573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906110e491906117f8565b90508061062657604051630741496760e01b81526001600160a01b03831660048201526024016106b6565b5f6107888383611288565b60605f610788836112ae565b5f61045d825490565b6111398282610a9b565b610c345760405163e2517d3f60e01b81526001600160a01b0382166004820152602481018390526044016106b6565b5f6111738383610a9b565b6111f0575f838152602081815260408083206001600160a01b03861684529091529020805460ff191660011790556111a83390565b6001600160a01b0316826001600160a01b0316847f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a450600161045d565b505f61045d565b5f610788836001600160a01b038416611307565b5f6112168383610a9b565b156111f0575f838152602081815260408083206001600160a01b0386168085529252808320805460ff1916905551339286917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a450600161045d565b5f610788836001600160a01b03841661134c565b5f825f01828154811061129d5761129d6117b7565b905f5260205f200154905092915050565b6060815f018054806020026020016040519081016040528092919081815260200182805480156112fb57602002820191905f5260205f20905b8154815260200190600101908083116112e7575b50505050509050919050565b5f8181526001830160205260408120546111f057508154600181810184555f84815260208082209093018490558454848252828601909352604090209190915561045d565b5f8181526001830160205260408120548015611426575f61136e6001836117a4565b85549091505f90611381906001906117a4565b90508082146113e0575f865f01828154811061139f5761139f6117b7565b905f5260205f200154905080875f0184815481106113bf576113bf6117b7565b5f918252602080832090910192909255918252600188019052604090208390555b85548690806113f1576113f1611813565b600190038181905f5260205f20015f90559055856001015f8681526020019081526020015f205f90556001935050505061045d565b5f91505061045d565b5f6020828403121561143f575f5ffd5b81356001600160e01b031981168114610788575f5ffd5b5f60208284031215611466575f5ffd5b5035919050565b80356001600160a01b0381168114611483575f5ffd5b919050565b5f60208284031215611498575f5ffd5b6107888261146d565b5f5f83601f8401126114b1575f5ffd5b50813567ffffffffffffffff8111156114c8575f5ffd5b6020830191508360208260051b85010111156114e2575f5ffd5b9250929050565b5f5f602083850312156114fa575f5ffd5b823567ffffffffffffffff811115611510575f5ffd5b61151c858286016114a1565b90969095509350505050565b5f5f60408385031215611539575f5ffd5b823591506115496020840161146d565b90509250929050565b5f5f5f5f60408587031215611565575f5ffd5b843567ffffffffffffffff81111561157b575f5ffd5b611587878288016114a1565b909550935050602085013567ffffffffffffffff8111156115a6575f5ffd5b6115b2878288016114a1565b95989497509550505050565b5f5f604083850312156115cf575f5ffd5b50508035926020909101359150565b602080825282518282018190525f918401906040840190835b8181101561161e5783516001600160a01b03168352602093840193909201916001016115f7565b509095945050505050565b5f5f6040838503121561163a575f5ffd5b6116438361146d565b91506115496020840161146d565b634e487b7160e01b5f52604160045260245ffd5b8015158114610f07575f5ffd5b803561148381611665565b5f5f5f6040848603121561168f575f5ffd5b833567ffffffffffffffff8111156116a5575f5ffd5b6116b1868287016114a1565b909450925050602084013567ffffffffffffffff8111156116d0575f5ffd5b8401601f810186136116e0575f5ffd5b803567ffffffffffffffff8111156116fa576116fa611651565b8060051b604051601f19603f830116810181811067ffffffffffffffff8211171561172757611727611651565b604052918252602081840181019290810189841115611744575f5ffd5b6020850194505b8385101561176a5761175c85611672565b81526020948501940161174b565b50809450505050509250925092565b5f60208284031215611789575f5ffd5b5051919050565b634e487b7160e01b5f52601160045260245ffd5b8181038181111561045d5761045d611790565b634e487b7160e01b5f52603260045260245ffd5b5f816117d9576117d9611790565b505f190190565b5f600182016117f1576117f1611790565b5060010190565b5f60208284031215611808575f5ffd5b815161078881611665565b634e487b7160e01b5f52603160045260245ffdfe241ecf16d79d0f8dbfb92cbc07fe17840425976cf0667f022fe9877caa831b08e2994f8d6f600ad473dba82c0a890ab7affacb860d3365f474baa3dc04a2e557a2646970667358221220de1016be1f1dcc735510002b24025c7fd5328e8e9a8c87cc0b5f89ba1223c3ea64736f6c634300081e0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\x01\xC6W_5`\xE0\x1C\x80c\x90\x10\xD0|\x11a\0\xFEW\x80c\xC7\xEC\xAB\x8F\x11a\0\x9EW\x80c\xCF\xB3s_\x11a\0nW\x80c\xCF\xB3s_\x14a\x03\xF7W\x80c\xD5Gt\x1F\x14a\x03\xFFW\x80c\xE3\xD2\xA0q\x14a\x04\x12W\x80c\xEC\x87b\x1C\x14a\x04%W__\xFD[\x80c\xC7\xEC\xAB\x8F\x14a\x03\xA1W\x80c\xCA\x15\xC8s\x14a\x03\xC9W\x80c\xCA\xF5\xF5\x01\x14a\x03\xDCW\x80c\xCB\xEB\xAF\xE0\x14a\x03\xEFW__\xFD[\x80c\xA0^\x0Fm\x11a\0\xD9W\x80c\xA0^\x0Fm\x14a\x03TW\x80c\xA2\x17\xFD\xDF\x14a\x03gW\x80c\xA3$j\xD3\x14a\x03nW\x80c\xA5`]\xA5\x14a\x03\x8EW__\xFD[\x80c\x90\x10\xD0|\x14a\x03\x0EW\x80c\x91\xD1HT\x14a\x039W\x80c\x9C\x7Fd;\x14a\x03LW__\xFD[\x80c6V\x8A\xBE\x11a\x01iW\x80cN\xB1\x80\\\x11a\x01DW\x80cN\xB1\x80\\\x14a\x02\xC2W\x80co\xFB\xF9\x88\x14a\x02\xD5W\x80cvY:9\x14a\x02\xE8W\x80c\x8Du;-\x14a\x02\xFBW__\xFD[\x80c6V\x8A\xBE\x14a\x02}W\x80c?\xA5\x84W\x14a\x02\x90W\x80cA\xB6Ie\x14a\x02\xAFW__\xFD[\x80c'\xB0@\xA1\x11a\x01\xA4W\x80c'\xB0@\xA1\x14a\x02/W\x80c*-\xEE\xE2\x14a\x02DW\x80c,3\xCA\xFB\x14a\x02WW\x80c//\xF1]\x14a\x02jW__\xFD[\x80c\x01\xFF\xC9\xA7\x14a\x01\xCAW\x80c#\x8D\xAF\xE0\x14a\x01\xF2W\x80c$\x8A\x9C\xA3\x14a\x01\xFFW[__\xFD[a\x01\xDDa\x01\xD86`\x04a\x14/V[a\x049V[`@Q\x90\x15\x15\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[`\x05Ta\x01\xDD\x90`\xFF\x16\x81V[a\x02!a\x02\r6`\x04a\x14VV[_\x90\x81R` \x81\x90R`@\x90 `\x01\x01T\x90V[`@Q\x90\x81R` \x01a\x01\xE9V[a\x02Ba\x02=6`\x04a\x14\x88V[a\x04cV[\0[a\x02!a\x02R6`\x04a\x14\x88V[a\x04\xC4V[a\x02Ba\x02e6`\x04a\x14\xE9V[a\x05qV[a\x02Ba\x02x6`\x04a\x15(V[a\x05\xCFV[a\x02Ba\x02\x8B6`\x04a\x15(V[a\x05\xF3V[a\x02!a\x02\x9E6`\x04a\x14\x88V[`\x03` R_\x90\x81R`@\x90 T\x81V[a\x02Ba\x02\xBD6`\x04a\x14\xE9V[a\x06+V[a\x01\xDDa\x02\xD06`\x04a\x14\x88V[a\x07BV[a\x01\xDDa\x02\xE36`\x04a\x14\x88V[a\x07\x8FV[a\x02Ba\x02\xF66`\x04a\x14\xE9V[a\x07\x99V[a\x02Ba\x03\t6`\x04a\x15RV[a\t\x1CV[a\x03!a\x03\x1C6`\x04a\x15\xBEV[a\n\x84V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\x01\xE9V[a\x01\xDDa\x03G6`\x04a\x15(V[a\n\x9BV[a\x02Ba\n\xC3V[a\x02Ba\x03b6`\x04a\x14\xE9V[a\n\xF1V[a\x02!_\x81V[a\x03\x81a\x03|6`\x04a\x14VV[a\x0C8V[`@Qa\x01\xE9\x91\x90a\x15\xDEV[a\x01\xDDa\x03\x9C6`\x04a\x16)V[a\x0CQV[a\x03!a\x03\xAF6`\x04a\x14\x88V[`\x04` R_\x90\x81R`@\x90 T`\x01`\x01`\xA0\x1B\x03\x16\x81V[a\x02!a\x03\xD76`\x04a\x14VV[a\x0C\x9DV[a\x02Ba\x03\xEA6`\x04a\x16}V[a\x0C\xB3V[a\x02Ba\r\xBEV[a\x02Ba\x0E/V[a\x02Ba\x04\r6`\x04a\x15(V[a\x0E\xA5V[`\x02Ta\x03!\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[a\x02!_Q` a\x18(_9_Q\x90_R\x81V[_`\x01`\x01`\xE0\x1B\x03\x19\x82\x16cZ\x05\x18\x0F`\xE0\x1B\x14\x80a\x04]WPa\x04]\x82a\x0E\xC9V[\x92\x91PPV[_Q` a\x18(_9_Q\x90_Ra\x04z\x81a\x0E\xFDV[`\x02\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x84\x16\x90\x81\x17\x90\x91U`@Q\x7F\x8A\xC4\xB2\xEBwI\xF7\\[\x99\xB8\x98\xE5G\xFDa]\xD7\xA4$\xE6\x83V\xEA\x19k}\xAEt-l2\x90_\x90\xA2PPV[`\x02T`@QcY\xAA'A`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\x04\x83\x01R_\x92\x83\x92\x91\x16\x90c\xB3TN\x82\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x05\x0FW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x053\x91\x90a\x17yV[`\x01`\x01`\xA0\x1B\x03\x84\x16_\x90\x81R`\x03` R`@\x90 T\x90\x91P\x80\x82\x11\x15a\x05hWa\x05`\x81\x83a\x17\xA4V[\x94\x93PPPPV[P_\x93\x92PPPV[_Q` a\x18(_9_Q\x90_Ra\x05\x88\x81a\x0E\xFDV[_[\x82\x81\x10\x15a\x05\xC9Wa\x05\xC1\x84\x84\x83\x81\x81\x10a\x05\xA7Wa\x05\xA7a\x17\xB7V[\x90P` \x02\x01` \x81\x01\x90a\x05\xBC\x91\x90a\x14\x88V[a\x0F\nV[`\x01\x01a\x05\x8AV[PPPPV[_\x82\x81R` \x81\x90R`@\x90 `\x01\x01Ta\x05\xE9\x81a\x0E\xFDV[a\x05\xC9\x83\x83a\x0FcV[`\x01`\x01`\xA0\x1B\x03\x81\x163\x14a\x06\x1CW`@Qc3K\xD9\x19`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x06&\x82\x82a\x0F\x96V[PPPV[_Q` a\x18(_9_Q\x90_Ra\x06B\x81a\x0E\xFDV[_[\x82\x81\x10\x15a\x05\xC9W_\x84\x84\x83\x81\x81\x10a\x06_Wa\x06_a\x17\xB7V[\x90P` \x02\x01` \x81\x01\x90a\x06t\x91\x90a\x14\x88V[`\x01`\x01`\xA0\x1B\x03\x80\x82\x16_\x90\x81R`\x04` R`@\x90 T\x91\x92P\x16\x80a\x06\xBFW`@Qc\x168y\x15`\xE3\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16`\x04\x82\x01R`$\x01[`@Q\x80\x91\x03\x90\xFD[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R`\x03` R`@\x81 \x80T\x91a\x06\xE2\x83a\x17\xCBV[\x90\x91UPP`\x01`\x01`\xA0\x1B\x03\x80\x83\x16_\x81\x81R`\x04` R`@\x80\x82 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16\x90UQ\x91\x92\x84\x16\x91\x7F\x91v\n\x10\x01\xF51\xEC+\xEE\x86\x02\xBEU\xAD+\x11YF^\xDF\xF5\xBB\xCDA\xD2\x07\x03t*MB\x91\x90\xA3PP`\x01\x01a\x06DV[_`\x01`\x01`\xA0\x1B\x03\x82\x16a\x07XWP_\x91\x90PV[`\x01`\x01`\xA0\x1B\x03\x80\x83\x16_\x90\x81R`\x04` R`@\x90 T\x16\x80a\x07\x7FWP_\x92\x91PPV[a\x07\x88\x81a\x0F\xC1V[\x93\x92PPPV[_a\x04]\x82a\x0F\xC1V[`\x05T`\xFF\x16a\x07\xBCW`@Qc\xC4&8\xBB`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_[\x81\x81\x10\x15a\x08\xD7W_\x83\x83\x83\x81\x81\x10a\x07\xD9Wa\x07\xD9a\x17\xB7V[\x90P` \x02\x01` \x81\x01\x90a\x07\xEE\x91\x90a\x14\x88V[`\x01`\x01`\xA0\x1B\x03\x80\x82\x16_\x90\x81R`\x04` R`@\x90 T\x91\x92P\x16a\x08\x153\x83a\x10pV[`\x01`\x01`\xA0\x1B\x03\x81\x16a\x08\x99W3_\x90\x81R`\x03` R`@\x81 \x80T\x91a\x08=\x83a\x17\xE0V[\x90\x91UPP`\x01`\x01`\xA0\x1B\x03\x82\x16_\x81\x81R`\x04` R`@\x80\x82 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x163\x90\x81\x17\x90\x91U\x90Q\x90\x91\x7F\n1\xEE\x9DF\xA8(\x88K\x81\0<\x84\x98\x15n\xA6\xAA\x15\xB9\xB5K\xDD\x0E\xF0\xB53\xD9\xEB\xA5~U\x91\xA3a\x08\xCDV[`\x01`\x01`\xA0\x1B\x03\x81\x163\x14a\x08\xCDW`@Qc[S;\xA1`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16`\x04\x82\x01R`$\x01a\x06\xB6V[PP`\x01\x01a\x07\xBEV[Pa\x08\xE13a\x0F\xC1V[a\x08\xFEW`@Qc\x03\xEEoW`\xE2\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@Q`\x01\x903\x90_Q` a\x18H_9_Q\x90_R\x90_\x90\xA3PPV[_Q` a\x18(_9_Q\x90_Ra\t3\x81a\x0E\xFDV[\x83\x82\x14a\tSW`@Qc\xED\x88/q`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_[\x84\x81\x10\x15a\n|W_\x84\x84\x83\x81\x81\x10a\tpWa\tpa\x17\xB7V[\x90P` \x02\x01` \x81\x01\x90a\t\x85\x91\x90a\x14\x88V[\x90P_\x87\x87\x84\x81\x81\x10a\t\x9AWa\t\x9Aa\x17\xB7V[\x90P` \x02\x01` \x81\x01\x90a\t\xAF\x91\x90a\x14\x88V[`\x01`\x01`\xA0\x1B\x03\x83\x81\x16_\x90\x81R`\x04` R`@\x90 T\x91\x92P\x16\x15a\t\xF5W`@Qc[S;\xA1`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16`\x04\x82\x01R`$\x01a\x06\xB6V[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R`\x03` R`@\x81 \x80T\x91a\n\x18\x83a\x17\xE0V[\x90\x91UPP`\x01`\x01`\xA0\x1B\x03\x82\x81\x16_\x81\x81R`\x04` R`@\x80\x82 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16\x94\x86\x16\x94\x85\x17\x90UQ\x91\x92\x91\x7F\x04\xE1\xEA\xA4\xDA\x18\xF7\xE7B\xA4\xED\xBB\xE9\xED\xE3l\xDFu\xF7\x93\xBB\x03\xAB!X\xC0\x87\x7F\x1C\xAF+\x93\x91\x90\xA3PP`\x01\x01a\tUV[PPPPPPV[_\x82\x81R`\x01` R`@\x81 a\x07\x88\x90\x83a\x11\x0FV[_\x91\x82R` \x82\x81R`@\x80\x84 `\x01`\x01`\xA0\x1B\x03\x93\x90\x93\x16\x84R\x91\x90R\x90 T`\xFF\x16\x90V[`\x05T`\xFF\x16a\n\xE6W`@Qc\xC4&8\xBB`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\n\xEF3a\x0F\nV[V[`\x05T`\xFF\x16a\x0B\x14W`@Qc\xC4&8\xBB`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_[\x81\x81\x10\x15a\x0C*W_\x83\x83\x83\x81\x81\x10a\x0B1Wa\x0B1a\x17\xB7V[\x90P` \x02\x01` \x81\x01\x90a\x0BF\x91\x90a\x14\x88V[`\x01`\x01`\xA0\x1B\x03\x80\x82\x16_\x90\x81R`\x04` R`@\x90 T\x91\x92P\x16a\x0Bm3\x83a\x10pV[3`\x01`\x01`\xA0\x1B\x03\x82\x16\x03a\x0B\xEDW3_\x90\x81R`\x03` R`@\x81 \x80T\x91a\x0B\x97\x83a\x17\xCBV[\x90\x91UPP`\x01`\x01`\xA0\x1B\x03\x82\x16_\x81\x81R`\x04` R`@\x80\x82 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16\x90UQ3\x91\x7F\x15\x9A\x8A\xE9H\xFC\xC6\xE7\xF8\xB5I\\\rs\xE9\x15\x98D\n\xF8\xA6(\x17$l\t\xED\xC2\xC2\x8D\xBA\x8A\x91\xA3a\x0C V[`\x01`\x01`\xA0\x1B\x03\x81\x16\x15a\x0C W`@Qc\xBFO\xDDs`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16`\x04\x82\x01R`$\x01a\x06\xB6V[PP`\x01\x01a\x0B\x16V[Pa\x0C43a\x0F\nV[PPV[_\x81\x81R`\x01` R`@\x90 ``\x90a\x04]\x90a\x11\x1AV[_`\x01`\x01`\xA0\x1B\x03\x83\x16\x15\x80a\x0CoWP`\x01`\x01`\xA0\x1B\x03\x82\x16\x15[\x15a\x0C{WP_a\x04]V[P`\x01`\x01`\xA0\x1B\x03\x91\x82\x16_\x90\x81R`\x04` R`@\x90 T\x82\x16\x91\x16\x14\x90V[_\x81\x81R`\x01` R`@\x81 a\x04]\x90a\x11&V[_Q` a\x18(_9_Q\x90_Ra\x0C\xCA\x81a\x0E\xFDV[\x81Q\x83\x14a\x0C\xEBW`@Qc\xED\x88/q`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_[\x83\x81\x10\x15a\r\xB7W\x82\x81\x81Q\x81\x10a\r\x07Wa\r\x07a\x17\xB7V[` \x02` \x01\x01Q\x15a\rdW`\x01\x85\x85\x83\x81\x81\x10a\r(Wa\r(a\x17\xB7V[\x90P` \x02\x01` \x81\x01\x90a\r=\x91\x90a\x14\x88V[`\x01`\x01`\xA0\x1B\x03\x16_Q` a\x18H_9_Q\x90_R`@Q`@Q\x80\x91\x03\x90\xA3a\r\xAFV[_\x85\x85\x83\x81\x81\x10a\rwWa\rwa\x17\xB7V[\x90P` \x02\x01` \x81\x01\x90a\r\x8C\x91\x90a\x14\x88V[`\x01`\x01`\xA0\x1B\x03\x16_Q` a\x18H_9_Q\x90_R`@Q`@Q\x80\x91\x03\x90\xA3[`\x01\x01a\x0C\xEDV[PPPPPV[_Q` a\x18(_9_Q\x90_Ra\r\xD5\x81a\x0E\xFDV[`\x05T`\xFF\x16a\r\xF8W`@Qc\xC4&8\xBB`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x05\x80T`\xFF\x19\x16\x90U`@Q_\x90\x7F\x8B\xC8_%\xE3\xE93\x97\x8F\t\x94\x08\xB3\xBB>\xB7c\x0Bv\xF7E_. [\xCB\xC0\xA7\x80\xE1~r\x90\x82\x90\xA2PV[_Q` a\x18(_9_Q\x90_Ra\x0EF\x81a\x0E\xFDV[`\x05T`\xFF\x16\x15a\x0EjW`@Qc\xED\x1A\x0Cw`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x05\x80T`\xFF\x19\x16`\x01\x90\x81\x17\x90\x91U`@Q\x7F\x8B\xC8_%\xE3\xE93\x97\x8F\t\x94\x08\xB3\xBB>\xB7c\x0Bv\xF7E_. [\xCB\xC0\xA7\x80\xE1~r\x90_\x90\xA2PV[_\x82\x81R` \x81\x90R`@\x90 `\x01\x01Ta\x0E\xBF\x81a\x0E\xFDV[a\x05\xC9\x83\x83a\x0F\x96V[_`\x01`\x01`\xE0\x1B\x03\x19\x82\x16cye\xDB\x0B`\xE0\x1B\x14\x80a\x04]WPc\x01\xFF\xC9\xA7`\xE0\x1B`\x01`\x01`\xE0\x1B\x03\x19\x83\x16\x14a\x04]V[a\x0F\x07\x813a\x11/V[PV[a\x0F\x13\x81a\x0F\xC1V[\x15a\x0F>W`@Q`\x01\x90`\x01`\x01`\xA0\x1B\x03\x83\x16\x90_Q` a\x18H_9_Q\x90_R\x90_\x90\xA3PV[`@Q_\x90`\x01`\x01`\xA0\x1B\x03\x83\x16\x90_Q` a\x18H_9_Q\x90_R\x90\x83\x90\xA3PV[__a\x0Fo\x84\x84a\x11hV[\x90P\x80\x15a\x07\x88W_\x84\x81R`\x01` R`@\x90 a\x0F\x8E\x90\x84a\x11\xF7V[P\x93\x92PPPV[__a\x0F\xA2\x84\x84a\x12\x0BV[\x90P\x80\x15a\x07\x88W_\x84\x81R`\x01` R`@\x90 a\x0F\x8E\x90\x84a\x12tV[`\x02T`@QcY\xAA'A`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\x04\x83\x01R_\x92\x83\x92\x91\x16\x90c\xB3TN\x82\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x10\x0CW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x100\x91\x90a\x17yV[\x90P\x80_\x03a\x10AWP_\x92\x91PPV[`\x01`\x01`\xA0\x1B\x03\x83\x16_\x90\x81R`\x03` R`@\x90 T\x81\x10a\x10hWP`\x01\x92\x91PPV[P_\x92\x91PPV[`\x02T`@Qc6\x16\xB4\x11`\xE2\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x84\x81\x16`\x04\x83\x01R\x83\x81\x16`$\x83\x01R_\x92\x16\x90c\xD8Z\xD0D\x90`D\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x10\xC0W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x10\xE4\x91\x90a\x17\xF8V[\x90P\x80a\x06&W`@Qc\x07AIg`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16`\x04\x82\x01R`$\x01a\x06\xB6V[_a\x07\x88\x83\x83a\x12\x88V[``_a\x07\x88\x83a\x12\xAEV[_a\x04]\x82T\x90V[a\x119\x82\x82a\n\x9BV[a\x0C4W`@Qc\xE2Q}?`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x82\x16`\x04\x82\x01R`$\x81\x01\x83\x90R`D\x01a\x06\xB6V[_a\x11s\x83\x83a\n\x9BV[a\x11\xF0W_\x83\x81R` \x81\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x86\x16\x84R\x90\x91R\x90 \x80T`\xFF\x19\x16`\x01\x17\x90Ua\x11\xA83\x90V[`\x01`\x01`\xA0\x1B\x03\x16\x82`\x01`\x01`\xA0\x1B\x03\x16\x84\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r`@Q`@Q\x80\x91\x03\x90\xA4P`\x01a\x04]V[P_a\x04]V[_a\x07\x88\x83`\x01`\x01`\xA0\x1B\x03\x84\x16a\x13\x07V[_a\x12\x16\x83\x83a\n\x9BV[\x15a\x11\xF0W_\x83\x81R` \x81\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x86\x16\x80\x85R\x92R\x80\x83 \x80T`\xFF\x19\x16\x90UQ3\x92\x86\x91\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B\x91\x90\xA4P`\x01a\x04]V[_a\x07\x88\x83`\x01`\x01`\xA0\x1B\x03\x84\x16a\x13LV[_\x82_\x01\x82\x81T\x81\x10a\x12\x9DWa\x12\x9Da\x17\xB7V[\x90_R` _ \x01T\x90P\x92\x91PPV[``\x81_\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80T\x80\x15a\x12\xFBW` \x02\x82\x01\x91\x90_R` _ \x90[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x12\xE7W[PPPPP\x90P\x91\x90PV[_\x81\x81R`\x01\x83\x01` R`@\x81 Ta\x11\xF0WP\x81T`\x01\x81\x81\x01\x84U_\x84\x81R` \x80\x82 \x90\x93\x01\x84\x90U\x84T\x84\x82R\x82\x86\x01\x90\x93R`@\x90 \x91\x90\x91Ua\x04]V[_\x81\x81R`\x01\x83\x01` R`@\x81 T\x80\x15a\x14&W_a\x13n`\x01\x83a\x17\xA4V[\x85T\x90\x91P_\x90a\x13\x81\x90`\x01\x90a\x17\xA4V[\x90P\x80\x82\x14a\x13\xE0W_\x86_\x01\x82\x81T\x81\x10a\x13\x9FWa\x13\x9Fa\x17\xB7V[\x90_R` _ \x01T\x90P\x80\x87_\x01\x84\x81T\x81\x10a\x13\xBFWa\x13\xBFa\x17\xB7V[_\x91\x82R` \x80\x83 \x90\x91\x01\x92\x90\x92U\x91\x82R`\x01\x88\x01\x90R`@\x90 \x83\x90U[\x85T\x86\x90\x80a\x13\xF1Wa\x13\xF1a\x18\x13V[`\x01\x90\x03\x81\x81\x90_R` _ \x01_\x90U\x90U\x85`\x01\x01_\x86\x81R` \x01\x90\x81R` \x01_ _\x90U`\x01\x93PPPPa\x04]V[_\x91PPa\x04]V[_` \x82\x84\x03\x12\x15a\x14?W__\xFD[\x815`\x01`\x01`\xE0\x1B\x03\x19\x81\x16\x81\x14a\x07\x88W__\xFD[_` \x82\x84\x03\x12\x15a\x14fW__\xFD[P5\x91\x90PV[\x805`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x14\x83W__\xFD[\x91\x90PV[_` \x82\x84\x03\x12\x15a\x14\x98W__\xFD[a\x07\x88\x82a\x14mV[__\x83`\x1F\x84\x01\x12a\x14\xB1W__\xFD[P\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x14\xC8W__\xFD[` \x83\x01\x91P\x83` \x82`\x05\x1B\x85\x01\x01\x11\x15a\x14\xE2W__\xFD[\x92P\x92\x90PV[__` \x83\x85\x03\x12\x15a\x14\xFAW__\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x15\x10W__\xFD[a\x15\x1C\x85\x82\x86\x01a\x14\xA1V[\x90\x96\x90\x95P\x93PPPPV[__`@\x83\x85\x03\x12\x15a\x159W__\xFD[\x825\x91Pa\x15I` \x84\x01a\x14mV[\x90P\x92P\x92\x90PV[____`@\x85\x87\x03\x12\x15a\x15eW__\xFD[\x845g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x15{W__\xFD[a\x15\x87\x87\x82\x88\x01a\x14\xA1V[\x90\x95P\x93PP` \x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x15\xA6W__\xFD[a\x15\xB2\x87\x82\x88\x01a\x14\xA1V[\x95\x98\x94\x97P\x95PPPPV[__`@\x83\x85\x03\x12\x15a\x15\xCFW__\xFD[PP\x805\x92` \x90\x91\x015\x91PV[` \x80\x82R\x82Q\x82\x82\x01\x81\x90R_\x91\x84\x01\x90`@\x84\x01\x90\x83[\x81\x81\x10\x15a\x16\x1EW\x83Q`\x01`\x01`\xA0\x1B\x03\x16\x83R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01a\x15\xF7V[P\x90\x95\x94PPPPPV[__`@\x83\x85\x03\x12\x15a\x16:W__\xFD[a\x16C\x83a\x14mV[\x91Pa\x15I` \x84\x01a\x14mV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x80\x15\x15\x81\x14a\x0F\x07W__\xFD[\x805a\x14\x83\x81a\x16eV[___`@\x84\x86\x03\x12\x15a\x16\x8FW__\xFD[\x835g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x16\xA5W__\xFD[a\x16\xB1\x86\x82\x87\x01a\x14\xA1V[\x90\x94P\x92PP` \x84\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x16\xD0W__\xFD[\x84\x01`\x1F\x81\x01\x86\x13a\x16\xE0W__\xFD[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x16\xFAWa\x16\xFAa\x16QV[\x80`\x05\x1B`@Q`\x1F\x19`?\x83\x01\x16\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15a\x17'Wa\x17'a\x16QV[`@R\x91\x82R` \x81\x84\x01\x81\x01\x92\x90\x81\x01\x89\x84\x11\x15a\x17DW__\xFD[` \x85\x01\x94P[\x83\x85\x10\x15a\x17jWa\x17\\\x85a\x16rV[\x81R` \x94\x85\x01\x94\x01a\x17KV[P\x80\x94PPPPP\x92P\x92P\x92V[_` \x82\x84\x03\x12\x15a\x17\x89W__\xFD[PQ\x91\x90PV[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[\x81\x81\x03\x81\x81\x11\x15a\x04]Wa\x04]a\x17\x90V[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[_\x81a\x17\xD9Wa\x17\xD9a\x17\x90V[P_\x19\x01\x90V[_`\x01\x82\x01a\x17\xF1Wa\x17\xF1a\x17\x90V[P`\x01\x01\x90V[_` \x82\x84\x03\x12\x15a\x18\x08W__\xFD[\x81Qa\x07\x88\x81a\x16eV[cNH{q`\xE0\x1B_R`1`\x04R`$_\xFD\xFE$\x1E\xCF\x16\xD7\x9D\x0F\x8D\xBF\xB9,\xBC\x07\xFE\x17\x84\x04%\x97l\xF0f\x7F\x02/\xE9\x87|\xAA\x83\x1B\x08\xE2\x99O\x8Do`\n\xD4s\xDB\xA8,\n\x89\n\xB7\xAF\xFA\xCB\x86\r3e\xF4t\xBA\xA3\xDC\x04\xA2\xE5W\xA2dipfsX\"\x12 \xDE\x10\x16\xBE\x1F\x1D\xCCsU\x10\0+$\x02\\\x7F\xD52\x8E\x8E\x9A\x8C\x87\xCC\x0B_\x89\xBA\x12#\xC3\xEAdsolcC\0\x08\x1E\x003",
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AccessControlBadConfirmation()` and selector `0x6697b232`.
```solidity
error AccessControlBadConfirmation();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccessControlBadConfirmation;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccessControlBadConfirmation>
        for UnderlyingRustTuple<'_> {
            fn from(value: AccessControlBadConfirmation) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AccessControlBadConfirmation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccessControlBadConfirmation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccessControlBadConfirmation()";
            const SELECTOR: [u8; 4] = [102u8, 151u8, 178u8, 50u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AccessControlUnauthorizedAccount(address,bytes32)` and selector `0xe2517d3f`.
```solidity
error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccessControlUnauthorizedAccount {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub neededRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccessControlUnauthorizedAccount>
        for UnderlyingRustTuple<'_> {
            fn from(value: AccessControlUnauthorizedAccount) -> Self {
                (value.account, value.neededRole)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AccessControlUnauthorizedAccount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    account: tuple.0,
                    neededRole: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccessControlUnauthorizedAccount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccessControlUnauthorizedAccount(address,bytes32)";
            const SELECTOR: [u8; 4] = [226u8, 81u8, 125u8, 63u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.neededRole),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ArrayLengthNotMatch()` and selector `0xed882f71`.
```solidity
error ArrayLengthNotMatch();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ArrayLengthNotMatch;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ArrayLengthNotMatch> for UnderlyingRustTuple<'_> {
            fn from(value: ArrayLengthNotMatch) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ArrayLengthNotMatch {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ArrayLengthNotMatch {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ArrayLengthNotMatch()";
            const SELECTOR: [u8; 4] = [237u8, 136u8, 47u8, 113u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `CannotOperateForNode(address)` and selector `0x07414967`.
```solidity
error CannotOperateForNode(address nodeAddress);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CannotOperateForNode {
        #[allow(missing_docs)]
        pub nodeAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CannotOperateForNode> for UnderlyingRustTuple<'_> {
            fn from(value: CannotOperateForNode) -> Self {
                (value.nodeAddress,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for CannotOperateForNode {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { nodeAddress: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for CannotOperateForNode {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CannotOperateForNode(address)";
            const SELECTOR: [u8; 4] = [7u8, 65u8, 73u8, 103u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.nodeAddress,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `GloballyDisabledRegistry()` and selector `0xc42638bb`.
```solidity
error GloballyDisabledRegistry();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct GloballyDisabledRegistry;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<GloballyDisabledRegistry>
        for UnderlyingRustTuple<'_> {
            fn from(value: GloballyDisabledRegistry) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for GloballyDisabledRegistry {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for GloballyDisabledRegistry {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "GloballyDisabledRegistry()";
            const SELECTOR: [u8; 4] = [196u8, 38u8, 56u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `GloballyEnabledRegistry()` and selector `0xed1a0c77`.
```solidity
error GloballyEnabledRegistry();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct GloballyEnabledRegistry;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<GloballyEnabledRegistry> for UnderlyingRustTuple<'_> {
            fn from(value: GloballyEnabledRegistry) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for GloballyEnabledRegistry {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for GloballyEnabledRegistry {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "GloballyEnabledRegistry()";
            const SELECTOR: [u8; 4] = [237u8, 26u8, 12u8, 119u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NodeAlreadyRegisterd(address)` and selector `0x5b533ba1`.
```solidity
error NodeAlreadyRegisterd(address nodeAddress);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NodeAlreadyRegisterd {
        #[allow(missing_docs)]
        pub nodeAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NodeAlreadyRegisterd> for UnderlyingRustTuple<'_> {
            fn from(value: NodeAlreadyRegisterd) -> Self {
                (value.nodeAddress,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NodeAlreadyRegisterd {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { nodeAddress: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NodeAlreadyRegisterd {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NodeAlreadyRegisterd(address)";
            const SELECTOR: [u8; 4] = [91u8, 83u8, 59u8, 161u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.nodeAddress,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NodeNotYetRegisterd(address)` and selector `0xb1c3c8a8`.
```solidity
error NodeNotYetRegisterd(address nodeAddress);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NodeNotYetRegisterd {
        #[allow(missing_docs)]
        pub nodeAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NodeNotYetRegisterd> for UnderlyingRustTuple<'_> {
            fn from(value: NodeNotYetRegisterd) -> Self {
                (value.nodeAddress,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NodeNotYetRegisterd {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { nodeAddress: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NodeNotYetRegisterd {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NodeNotYetRegisterd(address)";
            const SELECTOR: [u8; 4] = [177u8, 195u8, 200u8, 168u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.nodeAddress,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NodeRegisterdToOtherAccount(address)` and selector `0xbf4fdd73`.
```solidity
error NodeRegisterdToOtherAccount(address nodeAddress);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NodeRegisterdToOtherAccount {
        #[allow(missing_docs)]
        pub nodeAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NodeRegisterdToOtherAccount>
        for UnderlyingRustTuple<'_> {
            fn from(value: NodeRegisterdToOtherAccount) -> Self {
                (value.nodeAddress,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for NodeRegisterdToOtherAccount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { nodeAddress: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NodeRegisterdToOtherAccount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NodeRegisterdToOtherAccount(address)";
            const SELECTOR: [u8; 4] = [191u8, 79u8, 221u8, 115u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.nodeAddress,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotEnoughAllowanceToRegisterNode()` and selector `0x0fb9bd5c`.
```solidity
error NotEnoughAllowanceToRegisterNode();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotEnoughAllowanceToRegisterNode;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotEnoughAllowanceToRegisterNode>
        for UnderlyingRustTuple<'_> {
            fn from(value: NotEnoughAllowanceToRegisterNode) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for NotEnoughAllowanceToRegisterNode {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotEnoughAllowanceToRegisterNode {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotEnoughAllowanceToRegisterNode()";
            const SELECTOR: [u8; 4] = [15u8, 185u8, 189u8, 92u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ZeroAddress(string)` and selector `0xeac0d389`.
```solidity
error ZeroAddress(string reason);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroAddress {
        #[allow(missing_docs)]
        pub reason: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroAddress> for UnderlyingRustTuple<'_> {
            fn from(value: ZeroAddress) -> Self {
                (value.reason,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroAddress {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { reason: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroAddress {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroAddress(string)";
            const SELECTOR: [u8; 4] = [234u8, 192u8, 211u8, 137u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.reason,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Deregistered(address,address)` and selector `0x159a8ae948fcc6e7f8b5495c0d73e91598440af8a62817246c09edc2c28dba8a`.
```solidity
event Deregistered(address indexed stakingAccount, address indexed nodeAddress);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Deregistered {
        #[allow(missing_docs)]
        pub stakingAccount: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub nodeAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Deregistered {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Deregistered(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                21u8, 154u8, 138u8, 233u8, 72u8, 252u8, 198u8, 231u8, 248u8, 181u8, 73u8,
                92u8, 13u8, 115u8, 233u8, 21u8, 152u8, 68u8, 10u8, 248u8, 166u8, 40u8,
                23u8, 36u8, 108u8, 9u8, 237u8, 194u8, 194u8, 141u8, 186u8, 138u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    stakingAccount: topics.1,
                    nodeAddress: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.stakingAccount.clone(),
                    self.nodeAddress.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.stakingAccount,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.nodeAddress,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Deregistered {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Deregistered> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Deregistered) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `DeregisteredByManager(address,address)` and selector `0x91760a1001f531ec2bee8602be55ad2b1159465edff5bbcd41d20703742a4d42`.
```solidity
event DeregisteredByManager(address indexed stakingAccount, address indexed nodeAddress);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct DeregisteredByManager {
        #[allow(missing_docs)]
        pub stakingAccount: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub nodeAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for DeregisteredByManager {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "DeregisteredByManager(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                145u8, 118u8, 10u8, 16u8, 1u8, 245u8, 49u8, 236u8, 43u8, 238u8, 134u8,
                2u8, 190u8, 85u8, 173u8, 43u8, 17u8, 89u8, 70u8, 94u8, 223u8, 245u8,
                187u8, 205u8, 65u8, 210u8, 7u8, 3u8, 116u8, 42u8, 77u8, 66u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    stakingAccount: topics.1,
                    nodeAddress: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.stakingAccount.clone(),
                    self.nodeAddress.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.stakingAccount,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.nodeAddress,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for DeregisteredByManager {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&DeregisteredByManager> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &DeregisteredByManager) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `EligibilityUpdated(address,bool)` and selector `0xe2994f8d6f600ad473dba82c0a890ab7affacb860d3365f474baa3dc04a2e557`.
```solidity
event EligibilityUpdated(address indexed stakingAccount, bool indexed eligibility);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EligibilityUpdated {
        #[allow(missing_docs)]
        pub stakingAccount: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub eligibility: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EligibilityUpdated {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
            );
            const SIGNATURE: &'static str = "EligibilityUpdated(address,bool)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                226u8, 153u8, 79u8, 141u8, 111u8, 96u8, 10u8, 212u8, 115u8, 219u8, 168u8,
                44u8, 10u8, 137u8, 10u8, 183u8, 175u8, 250u8, 203u8, 134u8, 13u8, 51u8,
                101u8, 244u8, 116u8, 186u8, 163u8, 220u8, 4u8, 162u8, 229u8, 87u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    stakingAccount: topics.1,
                    eligibility: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.stakingAccount.clone(),
                    self.eligibility.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.stakingAccount,
                );
                out[2usize] = <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic(
                    &self.eligibility,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EligibilityUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EligibilityUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EligibilityUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `NetworkRegistryStatusUpdated(bool)` and selector `0x8bc85f25e3e933978f099408b3bb3eb7630b76f7455f2e205bcbc0a780e17e72`.
```solidity
event NetworkRegistryStatusUpdated(bool indexed isEnabled);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct NetworkRegistryStatusUpdated {
        #[allow(missing_docs)]
        pub isEnabled: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for NetworkRegistryStatusUpdated {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bool,
            );
            const SIGNATURE: &'static str = "NetworkRegistryStatusUpdated(bool)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                139u8, 200u8, 95u8, 37u8, 227u8, 233u8, 51u8, 151u8, 143u8, 9u8, 148u8,
                8u8, 179u8, 187u8, 62u8, 183u8, 99u8, 11u8, 118u8, 247u8, 69u8, 95u8,
                46u8, 32u8, 91u8, 203u8, 192u8, 167u8, 128u8, 225u8, 126u8, 114u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { isEnabled: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.isEnabled.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic(
                    &self.isEnabled,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for NetworkRegistryStatusUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&NetworkRegistryStatusUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &NetworkRegistryStatusUpdated,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Registered(address,address)` and selector `0x0a31ee9d46a828884b81003c8498156ea6aa15b9b54bdd0ef0b533d9eba57e55`.
```solidity
event Registered(address indexed stakingAccount, address indexed nodeAddress);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Registered {
        #[allow(missing_docs)]
        pub stakingAccount: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub nodeAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Registered {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Registered(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                10u8, 49u8, 238u8, 157u8, 70u8, 168u8, 40u8, 136u8, 75u8, 129u8, 0u8,
                60u8, 132u8, 152u8, 21u8, 110u8, 166u8, 170u8, 21u8, 185u8, 181u8, 75u8,
                221u8, 14u8, 240u8, 181u8, 51u8, 217u8, 235u8, 165u8, 126u8, 85u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    stakingAccount: topics.1,
                    nodeAddress: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.stakingAccount.clone(),
                    self.nodeAddress.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.stakingAccount,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.nodeAddress,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Registered {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Registered> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Registered) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RegisteredByManager(address,address)` and selector `0x04e1eaa4da18f7e742a4edbbe9ede36cdf75f793bb03ab2158c0877f1caf2b93`.
```solidity
event RegisteredByManager(address indexed stakingAccount, address indexed nodeAddress);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RegisteredByManager {
        #[allow(missing_docs)]
        pub stakingAccount: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub nodeAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RegisteredByManager {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RegisteredByManager(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                4u8, 225u8, 234u8, 164u8, 218u8, 24u8, 247u8, 231u8, 66u8, 164u8, 237u8,
                187u8, 233u8, 237u8, 227u8, 108u8, 223u8, 117u8, 247u8, 147u8, 187u8,
                3u8, 171u8, 33u8, 88u8, 192u8, 135u8, 127u8, 28u8, 175u8, 43u8, 147u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    stakingAccount: topics.1,
                    nodeAddress: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.stakingAccount.clone(),
                    self.nodeAddress.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.stakingAccount,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.nodeAddress,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RegisteredByManager {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RegisteredByManager> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RegisteredByManager) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RequirementUpdated(address)` and selector `0x8ac4b2eb7749f75c5b99b898e547fd615dd7a424e68356ea196b7dae742d6c32`.
```solidity
event RequirementUpdated(address indexed requirementImplementation);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RequirementUpdated {
        #[allow(missing_docs)]
        pub requirementImplementation: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RequirementUpdated {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RequirementUpdated(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                138u8, 196u8, 178u8, 235u8, 119u8, 73u8, 247u8, 92u8, 91u8, 153u8, 184u8,
                152u8, 229u8, 71u8, 253u8, 97u8, 93u8, 215u8, 164u8, 36u8, 230u8, 131u8,
                86u8, 234u8, 25u8, 107u8, 125u8, 174u8, 116u8, 45u8, 108u8, 50u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    requirementImplementation: topics.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.requirementImplementation.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.requirementImplementation,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RequirementUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RequirementUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RequirementUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RoleAdminChanged(bytes32,bytes32,bytes32)` and selector `0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff`.
```solidity
event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleAdminChanged {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub previousAdminRole: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub newAdminRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleAdminChanged {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "RoleAdminChanged(bytes32,bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                189u8, 121u8, 184u8, 111u8, 254u8, 10u8, 184u8, 232u8, 119u8, 97u8, 81u8,
                81u8, 66u8, 23u8, 205u8, 124u8, 172u8, 213u8, 44u8, 144u8, 159u8, 102u8,
                71u8, 92u8, 58u8, 244u8, 78u8, 18u8, 159u8, 11u8, 0u8, 255u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    previousAdminRole: topics.2,
                    newAdminRole: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.previousAdminRole.clone(),
                    self.newAdminRole.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.previousAdminRole);
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.newAdminRole);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleAdminChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleAdminChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleAdminChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RoleGranted(bytes32,address,address)` and selector `0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d`.
```solidity
event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleGranted {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleGranted {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleGranted(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                47u8, 135u8, 136u8, 17u8, 126u8, 126u8, 255u8, 29u8, 130u8, 233u8, 38u8,
                236u8, 121u8, 73u8, 1u8, 209u8, 124u8, 120u8, 2u8, 74u8, 80u8, 39u8, 9u8,
                64u8, 48u8, 69u8, 64u8, 167u8, 51u8, 101u8, 111u8, 13u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleGranted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleGranted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleGranted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RoleRevoked(bytes32,address,address)` and selector `0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b`.
```solidity
event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleRevoked {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleRevoked {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleRevoked(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                246u8, 57u8, 31u8, 92u8, 50u8, 217u8, 198u8, 157u8, 42u8, 71u8, 234u8,
                103u8, 11u8, 68u8, 41u8, 116u8, 181u8, 57u8, 53u8, 209u8, 237u8, 199u8,
                253u8, 100u8, 235u8, 33u8, 224u8, 71u8, 168u8, 57u8, 23u8, 27u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleRevoked {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleRevoked> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleRevoked) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(address _requirementImplementation, address _newOwner, address _manager);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub _requirementImplementation: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _newOwner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _manager: alloy::sol_types::private::Address,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (value._requirementImplementation, value._newOwner, value._manager)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _requirementImplementation: tuple.0,
                        _newOwner: tuple.1,
                        _manager: tuple.2,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._requirementImplementation,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._newOwner,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._manager,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `DEFAULT_ADMIN_ROLE()` and selector `0xa217fddf`.
```solidity
function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLECall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`DEFAULT_ADMIN_ROLE()`](DEFAULT_ADMIN_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DEFAULT_ADMIN_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DEFAULT_ADMIN_ROLE()";
            const SELECTOR: [u8; 4] = [162u8, 23u8, 253u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: DEFAULT_ADMIN_ROLEReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: DEFAULT_ADMIN_ROLEReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `MANAGER_ROLE()` and selector `0xec87621c`.
```solidity
function MANAGER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MANAGER_ROLECall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`MANAGER_ROLE()`](MANAGER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MANAGER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MANAGER_ROLECall> for UnderlyingRustTuple<'_> {
                fn from(value: MANAGER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for MANAGER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MANAGER_ROLEReturn> for UnderlyingRustTuple<'_> {
                fn from(value: MANAGER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for MANAGER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for MANAGER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MANAGER_ROLE()";
            const SELECTOR: [u8; 4] = [236u8, 135u8, 98u8, 28u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: MANAGER_ROLEReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: MANAGER_ROLEReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `countRegisterdNodesPerAccount(address)` and selector `0x3fa58457`.
```solidity
function countRegisterdNodesPerAccount(address) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct countRegisterdNodesPerAccountCall(pub alloy::sol_types::private::Address);
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`countRegisterdNodesPerAccount(address)`](countRegisterdNodesPerAccountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct countRegisterdNodesPerAccountReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<countRegisterdNodesPerAccountCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: countRegisterdNodesPerAccountCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for countRegisterdNodesPerAccountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<countRegisterdNodesPerAccountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: countRegisterdNodesPerAccountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for countRegisterdNodesPerAccountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for countRegisterdNodesPerAccountCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "countRegisterdNodesPerAccount(address)";
            const SELECTOR: [u8; 4] = [63u8, 165u8, 132u8, 87u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.0,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: countRegisterdNodesPerAccountReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: countRegisterdNodesPerAccountReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `disableRegistry()` and selector `0xcbebafe0`.
```solidity
function disableRegistry() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct disableRegistryCall;
    ///Container type for the return parameters of the [`disableRegistry()`](disableRegistryCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct disableRegistryReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<disableRegistryCall> for UnderlyingRustTuple<'_> {
                fn from(value: disableRegistryCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for disableRegistryCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<disableRegistryReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: disableRegistryReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for disableRegistryReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl disableRegistryReturn {
            fn _tokenize(
                &self,
            ) -> <disableRegistryCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for disableRegistryCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = disableRegistryReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "disableRegistry()";
            const SELECTOR: [u8; 4] = [203u8, 235u8, 175u8, 224u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                disableRegistryReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `enableRegistry()` and selector `0xcfb3735f`.
```solidity
function enableRegistry() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct enableRegistryCall;
    ///Container type for the return parameters of the [`enableRegistry()`](enableRegistryCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct enableRegistryReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<enableRegistryCall> for UnderlyingRustTuple<'_> {
                fn from(value: enableRegistryCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for enableRegistryCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<enableRegistryReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: enableRegistryReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for enableRegistryReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl enableRegistryReturn {
            fn _tokenize(
                &self,
            ) -> <enableRegistryCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for enableRegistryCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = enableRegistryReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "enableRegistry()";
            const SELECTOR: [u8; 4] = [207u8, 179u8, 115u8, 95u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                enableRegistryReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `enabled()` and selector `0x238dafe0`.
```solidity
function enabled() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct enabledCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`enabled()`](enabledCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct enabledReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<enabledCall> for UnderlyingRustTuple<'_> {
                fn from(value: enabledCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for enabledCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<enabledReturn> for UnderlyingRustTuple<'_> {
                fn from(value: enabledReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for enabledReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for enabledCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "enabled()";
            const SELECTOR: [u8; 4] = [35u8, 141u8, 175u8, 224u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: enabledReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: enabledReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getRoleAdmin(bytes32)` and selector `0x248a9ca3`.
```solidity
function getRoleAdmin(bytes32 role) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getRoleAdmin(bytes32)`](getRoleAdminCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminCall> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminCall) -> Self {
                    (value.role,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { role: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRoleAdminCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRoleAdmin(bytes32)";
            const SELECTOR: [u8; 4] = [36u8, 138u8, 156u8, 163u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getRoleAdminReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getRoleAdminReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getRoleMember(bytes32,uint256)` and selector `0x9010d07c`.
```solidity
function getRoleMember(bytes32 role, uint256 index) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleMemberCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub index: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getRoleMember(bytes32,uint256)`](getRoleMemberCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleMemberReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleMemberCall> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleMemberCall) -> Self {
                    (value.role, value.index)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleMemberCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        index: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleMemberReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleMemberReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleMemberReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRoleMemberCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRoleMember(bytes32,uint256)";
            const SELECTOR: [u8; 4] = [144u8, 16u8, 208u8, 124u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getRoleMemberReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getRoleMemberReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getRoleMemberCount(bytes32)` and selector `0xca15c873`.
```solidity
function getRoleMemberCount(bytes32 role) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleMemberCountCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getRoleMemberCount(bytes32)`](getRoleMemberCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleMemberCountReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleMemberCountCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getRoleMemberCountCall) -> Self {
                    (value.role,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getRoleMemberCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { role: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleMemberCountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getRoleMemberCountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getRoleMemberCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRoleMemberCountCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRoleMemberCount(bytes32)";
            const SELECTOR: [u8; 4] = [202u8, 21u8, 200u8, 115u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getRoleMemberCountReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getRoleMemberCountReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getRoleMembers(bytes32)` and selector `0xa3246ad3`.
```solidity
function getRoleMembers(bytes32 role) external view returns (address[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleMembersCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getRoleMembers(bytes32)`](getRoleMembersCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleMembersReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleMembersCall> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleMembersCall) -> Self {
                    (value.role,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleMembersCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { role: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleMembersReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getRoleMembersReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getRoleMembersReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRoleMembersCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Vec<
                alloy::sol_types::private::Address,
            >;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRoleMembers(bytes32)";
            const SELECTOR: [u8; 4] = [163u8, 36u8, 106u8, 211u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getRoleMembersReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getRoleMembersReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `grantRole(bytes32,address)` and selector `0x2f2ff15d`.
```solidity
function grantRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`grantRole(bytes32,address)`](grantRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl grantRoleReturn {
            fn _tokenize(
                &self,
            ) -> <grantRoleCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for grantRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = grantRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "grantRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [47u8, 47u8, 241u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                grantRoleReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `hasRole(bytes32,address)` and selector `0x91d14854`.
```solidity
function hasRole(bytes32 role, address account) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`hasRole(bytes32,address)`](hasRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for hasRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "hasRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [145u8, 209u8, 72u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: hasRoleReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: hasRoleReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `isAccountEligible(address)` and selector `0x6ffbf988`.
```solidity
function isAccountEligible(address stakingAccount) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isAccountEligibleCall {
        #[allow(missing_docs)]
        pub stakingAccount: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`isAccountEligible(address)`](isAccountEligibleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isAccountEligibleReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isAccountEligibleCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: isAccountEligibleCall) -> Self {
                    (value.stakingAccount,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isAccountEligibleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { stakingAccount: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isAccountEligibleReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: isAccountEligibleReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isAccountEligibleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isAccountEligibleCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isAccountEligible(address)";
            const SELECTOR: [u8; 4] = [111u8, 251u8, 249u8, 136u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.stakingAccount,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: isAccountEligibleReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: isAccountEligibleReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `isNodeRegisteredAndEligible(address)` and selector `0x4eb1805c`.
```solidity
function isNodeRegisteredAndEligible(address nodeAddress) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isNodeRegisteredAndEligibleCall {
        #[allow(missing_docs)]
        pub nodeAddress: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`isNodeRegisteredAndEligible(address)`](isNodeRegisteredAndEligibleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isNodeRegisteredAndEligibleReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isNodeRegisteredAndEligibleCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: isNodeRegisteredAndEligibleCall) -> Self {
                    (value.nodeAddress,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isNodeRegisteredAndEligibleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { nodeAddress: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isNodeRegisteredAndEligibleReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: isNodeRegisteredAndEligibleReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isNodeRegisteredAndEligibleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isNodeRegisteredAndEligibleCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isNodeRegisteredAndEligible(address)";
            const SELECTOR: [u8; 4] = [78u8, 177u8, 128u8, 92u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.nodeAddress,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: isNodeRegisteredAndEligibleReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: isNodeRegisteredAndEligibleReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `isNodeRegisteredByAccount(address,address)` and selector `0xa5605da5`.
```solidity
function isNodeRegisteredByAccount(address nodeAddress, address account) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isNodeRegisteredByAccountCall {
        #[allow(missing_docs)]
        pub nodeAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`isNodeRegisteredByAccount(address,address)`](isNodeRegisteredByAccountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isNodeRegisteredByAccountReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isNodeRegisteredByAccountCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: isNodeRegisteredByAccountCall) -> Self {
                    (value.nodeAddress, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isNodeRegisteredByAccountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        nodeAddress: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isNodeRegisteredByAccountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: isNodeRegisteredByAccountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isNodeRegisteredByAccountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isNodeRegisteredByAccountCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isNodeRegisteredByAccount(address,address)";
            const SELECTOR: [u8; 4] = [165u8, 96u8, 93u8, 165u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.nodeAddress,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: isNodeRegisteredByAccountReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: isNodeRegisteredByAccountReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `managerDeregister(address[])` and selector `0x41b64965`.
```solidity
function managerDeregister(address[] memory nodeAddresses) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct managerDeregisterCall {
        #[allow(missing_docs)]
        pub nodeAddresses: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
    }
    ///Container type for the return parameters of the [`managerDeregister(address[])`](managerDeregisterCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct managerDeregisterReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<managerDeregisterCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: managerDeregisterCall) -> Self {
                    (value.nodeAddresses,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for managerDeregisterCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { nodeAddresses: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<managerDeregisterReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: managerDeregisterReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for managerDeregisterReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl managerDeregisterReturn {
            fn _tokenize(
                &self,
            ) -> <managerDeregisterCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for managerDeregisterCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = managerDeregisterReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "managerDeregister(address[])";
            const SELECTOR: [u8; 4] = [65u8, 182u8, 73u8, 101u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.nodeAddresses),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                managerDeregisterReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `managerForceSync(address[],bool[])` and selector `0xcaf5f501`.
```solidity
function managerForceSync(address[] memory stakingAccounts, bool[] memory eligibilities) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct managerForceSyncCall {
        #[allow(missing_docs)]
        pub stakingAccounts: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
        #[allow(missing_docs)]
        pub eligibilities: alloy::sol_types::private::Vec<bool>,
    }
    ///Container type for the return parameters of the [`managerForceSync(address[],bool[])`](managerForceSyncCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct managerForceSyncReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
                alloy::sol_types::private::Vec<bool>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<managerForceSyncCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: managerForceSyncCall) -> Self {
                    (value.stakingAccounts, value.eligibilities)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for managerForceSyncCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        stakingAccounts: tuple.0,
                        eligibilities: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<managerForceSyncReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: managerForceSyncReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for managerForceSyncReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl managerForceSyncReturn {
            fn _tokenize(
                &self,
            ) -> <managerForceSyncCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for managerForceSyncCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = managerForceSyncReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "managerForceSync(address[],bool[])";
            const SELECTOR: [u8; 4] = [202u8, 245u8, 245u8, 1u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.stakingAccounts),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bool,
                    > as alloy_sol_types::SolType>::tokenize(&self.eligibilities),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                managerForceSyncReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `managerRegister(address[],address[])` and selector `0x8d753b2d`.
```solidity
function managerRegister(address[] memory stakingAccounts, address[] memory nodeAddresses) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct managerRegisterCall {
        #[allow(missing_docs)]
        pub stakingAccounts: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
        #[allow(missing_docs)]
        pub nodeAddresses: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
    }
    ///Container type for the return parameters of the [`managerRegister(address[],address[])`](managerRegisterCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct managerRegisterReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<managerRegisterCall> for UnderlyingRustTuple<'_> {
                fn from(value: managerRegisterCall) -> Self {
                    (value.stakingAccounts, value.nodeAddresses)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for managerRegisterCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        stakingAccounts: tuple.0,
                        nodeAddresses: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<managerRegisterReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: managerRegisterReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for managerRegisterReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl managerRegisterReturn {
            fn _tokenize(
                &self,
            ) -> <managerRegisterCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for managerRegisterCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = managerRegisterReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "managerRegister(address[],address[])";
            const SELECTOR: [u8; 4] = [141u8, 117u8, 59u8, 45u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.stakingAccounts),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.nodeAddresses),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                managerRegisterReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `managerSync(address[])` and selector `0x2c33cafb`.
```solidity
function managerSync(address[] memory stakingAccounts) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct managerSyncCall {
        #[allow(missing_docs)]
        pub stakingAccounts: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
    }
    ///Container type for the return parameters of the [`managerSync(address[])`](managerSyncCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct managerSyncReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<managerSyncCall> for UnderlyingRustTuple<'_> {
                fn from(value: managerSyncCall) -> Self {
                    (value.stakingAccounts,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for managerSyncCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { stakingAccounts: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<managerSyncReturn> for UnderlyingRustTuple<'_> {
                fn from(value: managerSyncReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for managerSyncReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl managerSyncReturn {
            fn _tokenize(
                &self,
            ) -> <managerSyncCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for managerSyncCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = managerSyncReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "managerSync(address[])";
            const SELECTOR: [u8; 4] = [44u8, 51u8, 202u8, 251u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.stakingAccounts),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                managerSyncReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `maxAdditionalRegistrations(address)` and selector `0x2a2deee2`.
```solidity
function maxAdditionalRegistrations(address stakingAccount) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct maxAdditionalRegistrationsCall {
        #[allow(missing_docs)]
        pub stakingAccount: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`maxAdditionalRegistrations(address)`](maxAdditionalRegistrationsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct maxAdditionalRegistrationsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<maxAdditionalRegistrationsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: maxAdditionalRegistrationsCall) -> Self {
                    (value.stakingAccount,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for maxAdditionalRegistrationsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { stakingAccount: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<maxAdditionalRegistrationsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: maxAdditionalRegistrationsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for maxAdditionalRegistrationsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for maxAdditionalRegistrationsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "maxAdditionalRegistrations(address)";
            const SELECTOR: [u8; 4] = [42u8, 45u8, 238u8, 226u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.stakingAccount,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: maxAdditionalRegistrationsReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: maxAdditionalRegistrationsReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `nodeRegisterdToAccount(address)` and selector `0xc7ecab8f`.
```solidity
function nodeRegisterdToAccount(address) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nodeRegisterdToAccountCall(pub alloy::sol_types::private::Address);
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`nodeRegisterdToAccount(address)`](nodeRegisterdToAccountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nodeRegisterdToAccountReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nodeRegisterdToAccountCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: nodeRegisterdToAccountCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for nodeRegisterdToAccountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nodeRegisterdToAccountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: nodeRegisterdToAccountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for nodeRegisterdToAccountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for nodeRegisterdToAccountCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "nodeRegisterdToAccount(address)";
            const SELECTOR: [u8; 4] = [199u8, 236u8, 171u8, 143u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.0,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: nodeRegisterdToAccountReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: nodeRegisterdToAccountReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `renounceRole(bytes32,address)` and selector `0x36568abe`.
```solidity
function renounceRole(bytes32 role, address callerConfirmation) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub callerConfirmation: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`renounceRole(bytes32,address)`](renounceRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleCall) -> Self {
                    (value.role, value.callerConfirmation)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        callerConfirmation: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl renounceRoleReturn {
            fn _tokenize(
                &self,
            ) -> <renounceRoleCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [54u8, 86u8, 138u8, 190u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.callerConfirmation,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                renounceRoleReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `requirementImplementation()` and selector `0xe3d2a071`.
```solidity
function requirementImplementation() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct requirementImplementationCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`requirementImplementation()`](requirementImplementationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct requirementImplementationReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<requirementImplementationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: requirementImplementationCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for requirementImplementationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<requirementImplementationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: requirementImplementationReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for requirementImplementationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for requirementImplementationCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "requirementImplementation()";
            const SELECTOR: [u8; 4] = [227u8, 210u8, 160u8, 113u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: requirementImplementationReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: requirementImplementationReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `revokeRole(bytes32,address)` and selector `0xd547741f`.
```solidity
function revokeRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`revokeRole(bytes32,address)`](revokeRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl revokeRoleReturn {
            fn _tokenize(
                &self,
            ) -> <revokeRoleCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for revokeRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = revokeRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "revokeRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [213u8, 71u8, 116u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                revokeRoleReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `selfDeregister(address[])` and selector `0xa05e0f6d`.
```solidity
function selfDeregister(address[] memory nodeAddresses) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct selfDeregisterCall {
        #[allow(missing_docs)]
        pub nodeAddresses: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
    }
    ///Container type for the return parameters of the [`selfDeregister(address[])`](selfDeregisterCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct selfDeregisterReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<selfDeregisterCall> for UnderlyingRustTuple<'_> {
                fn from(value: selfDeregisterCall) -> Self {
                    (value.nodeAddresses,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for selfDeregisterCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { nodeAddresses: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<selfDeregisterReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: selfDeregisterReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for selfDeregisterReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl selfDeregisterReturn {
            fn _tokenize(
                &self,
            ) -> <selfDeregisterCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for selfDeregisterCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = selfDeregisterReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "selfDeregister(address[])";
            const SELECTOR: [u8; 4] = [160u8, 94u8, 15u8, 109u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.nodeAddresses),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                selfDeregisterReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `selfRegister(address[])` and selector `0x76593a39`.
```solidity
function selfRegister(address[] memory nodeAddresses) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct selfRegisterCall {
        #[allow(missing_docs)]
        pub nodeAddresses: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
    }
    ///Container type for the return parameters of the [`selfRegister(address[])`](selfRegisterCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct selfRegisterReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<selfRegisterCall> for UnderlyingRustTuple<'_> {
                fn from(value: selfRegisterCall) -> Self {
                    (value.nodeAddresses,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for selfRegisterCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { nodeAddresses: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<selfRegisterReturn> for UnderlyingRustTuple<'_> {
                fn from(value: selfRegisterReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for selfRegisterReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl selfRegisterReturn {
            fn _tokenize(
                &self,
            ) -> <selfRegisterCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for selfRegisterCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = selfRegisterReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "selfRegister(address[])";
            const SELECTOR: [u8; 4] = [118u8, 89u8, 58u8, 57u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.nodeAddresses),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                selfRegisterReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `selfSync()` and selector `0x9c7f643b`.
```solidity
function selfSync() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct selfSyncCall;
    ///Container type for the return parameters of the [`selfSync()`](selfSyncCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct selfSyncReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<selfSyncCall> for UnderlyingRustTuple<'_> {
                fn from(value: selfSyncCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for selfSyncCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<selfSyncReturn> for UnderlyingRustTuple<'_> {
                fn from(value: selfSyncReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for selfSyncReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl selfSyncReturn {
            fn _tokenize(
                &self,
            ) -> <selfSyncCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for selfSyncCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = selfSyncReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "selfSync()";
            const SELECTOR: [u8; 4] = [156u8, 127u8, 100u8, 59u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                selfSyncReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `supportsInterface(bytes4)` and selector `0x01ffc9a7`.
```solidity
function supportsInterface(bytes4 interfaceId) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceCall {
        #[allow(missing_docs)]
        pub interfaceId: alloy::sol_types::private::FixedBytes<4>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`supportsInterface(bytes4)`](supportsInterfaceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<4>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceCall) -> Self {
                    (value.interfaceId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { interfaceId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for supportsInterfaceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "supportsInterface(bytes4)";
            const SELECTOR: [u8; 4] = [1u8, 255u8, 201u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        4,
                    > as alloy_sol_types::SolType>::tokenize(&self.interfaceId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: supportsInterfaceReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: supportsInterfaceReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `updateRequirementImplementation(address)` and selector `0x27b040a1`.
```solidity
function updateRequirementImplementation(address _requirementImplementation) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateRequirementImplementationCall {
        #[allow(missing_docs)]
        pub _requirementImplementation: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`updateRequirementImplementation(address)`](updateRequirementImplementationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateRequirementImplementationReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateRequirementImplementationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateRequirementImplementationCall) -> Self {
                    (value._requirementImplementation,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateRequirementImplementationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _requirementImplementation: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateRequirementImplementationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateRequirementImplementationReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateRequirementImplementationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl updateRequirementImplementationReturn {
            fn _tokenize(
                &self,
            ) -> <updateRequirementImplementationCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateRequirementImplementationCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateRequirementImplementationReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateRequirementImplementation(address)";
            const SELECTOR: [u8; 4] = [39u8, 176u8, 64u8, 161u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._requirementImplementation,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                updateRequirementImplementationReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`HoprNetworkRegistry`](self) function calls.
    #[derive(Clone)]
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    pub enum HoprNetworkRegistryCalls {
        #[allow(missing_docs)]
        DEFAULT_ADMIN_ROLE(DEFAULT_ADMIN_ROLECall),
        #[allow(missing_docs)]
        MANAGER_ROLE(MANAGER_ROLECall),
        #[allow(missing_docs)]
        countRegisterdNodesPerAccount(countRegisterdNodesPerAccountCall),
        #[allow(missing_docs)]
        disableRegistry(disableRegistryCall),
        #[allow(missing_docs)]
        enableRegistry(enableRegistryCall),
        #[allow(missing_docs)]
        enabled(enabledCall),
        #[allow(missing_docs)]
        getRoleAdmin(getRoleAdminCall),
        #[allow(missing_docs)]
        getRoleMember(getRoleMemberCall),
        #[allow(missing_docs)]
        getRoleMemberCount(getRoleMemberCountCall),
        #[allow(missing_docs)]
        getRoleMembers(getRoleMembersCall),
        #[allow(missing_docs)]
        grantRole(grantRoleCall),
        #[allow(missing_docs)]
        hasRole(hasRoleCall),
        #[allow(missing_docs)]
        isAccountEligible(isAccountEligibleCall),
        #[allow(missing_docs)]
        isNodeRegisteredAndEligible(isNodeRegisteredAndEligibleCall),
        #[allow(missing_docs)]
        isNodeRegisteredByAccount(isNodeRegisteredByAccountCall),
        #[allow(missing_docs)]
        managerDeregister(managerDeregisterCall),
        #[allow(missing_docs)]
        managerForceSync(managerForceSyncCall),
        #[allow(missing_docs)]
        managerRegister(managerRegisterCall),
        #[allow(missing_docs)]
        managerSync(managerSyncCall),
        #[allow(missing_docs)]
        maxAdditionalRegistrations(maxAdditionalRegistrationsCall),
        #[allow(missing_docs)]
        nodeRegisterdToAccount(nodeRegisterdToAccountCall),
        #[allow(missing_docs)]
        renounceRole(renounceRoleCall),
        #[allow(missing_docs)]
        requirementImplementation(requirementImplementationCall),
        #[allow(missing_docs)]
        revokeRole(revokeRoleCall),
        #[allow(missing_docs)]
        selfDeregister(selfDeregisterCall),
        #[allow(missing_docs)]
        selfRegister(selfRegisterCall),
        #[allow(missing_docs)]
        selfSync(selfSyncCall),
        #[allow(missing_docs)]
        supportsInterface(supportsInterfaceCall),
        #[allow(missing_docs)]
        updateRequirementImplementation(updateRequirementImplementationCall),
    }
    impl HoprNetworkRegistryCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [1u8, 255u8, 201u8, 167u8],
            [35u8, 141u8, 175u8, 224u8],
            [36u8, 138u8, 156u8, 163u8],
            [39u8, 176u8, 64u8, 161u8],
            [42u8, 45u8, 238u8, 226u8],
            [44u8, 51u8, 202u8, 251u8],
            [47u8, 47u8, 241u8, 93u8],
            [54u8, 86u8, 138u8, 190u8],
            [63u8, 165u8, 132u8, 87u8],
            [65u8, 182u8, 73u8, 101u8],
            [78u8, 177u8, 128u8, 92u8],
            [111u8, 251u8, 249u8, 136u8],
            [118u8, 89u8, 58u8, 57u8],
            [141u8, 117u8, 59u8, 45u8],
            [144u8, 16u8, 208u8, 124u8],
            [145u8, 209u8, 72u8, 84u8],
            [156u8, 127u8, 100u8, 59u8],
            [160u8, 94u8, 15u8, 109u8],
            [162u8, 23u8, 253u8, 223u8],
            [163u8, 36u8, 106u8, 211u8],
            [165u8, 96u8, 93u8, 165u8],
            [199u8, 236u8, 171u8, 143u8],
            [202u8, 21u8, 200u8, 115u8],
            [202u8, 245u8, 245u8, 1u8],
            [203u8, 235u8, 175u8, 224u8],
            [207u8, 179u8, 115u8, 95u8],
            [213u8, 71u8, 116u8, 31u8],
            [227u8, 210u8, 160u8, 113u8],
            [236u8, 135u8, 98u8, 28u8],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(supportsInterface),
            ::core::stringify!(enabled),
            ::core::stringify!(getRoleAdmin),
            ::core::stringify!(updateRequirementImplementation),
            ::core::stringify!(maxAdditionalRegistrations),
            ::core::stringify!(managerSync),
            ::core::stringify!(grantRole),
            ::core::stringify!(renounceRole),
            ::core::stringify!(countRegisterdNodesPerAccount),
            ::core::stringify!(managerDeregister),
            ::core::stringify!(isNodeRegisteredAndEligible),
            ::core::stringify!(isAccountEligible),
            ::core::stringify!(selfRegister),
            ::core::stringify!(managerRegister),
            ::core::stringify!(getRoleMember),
            ::core::stringify!(hasRole),
            ::core::stringify!(selfSync),
            ::core::stringify!(selfDeregister),
            ::core::stringify!(DEFAULT_ADMIN_ROLE),
            ::core::stringify!(getRoleMembers),
            ::core::stringify!(isNodeRegisteredByAccount),
            ::core::stringify!(nodeRegisterdToAccount),
            ::core::stringify!(getRoleMemberCount),
            ::core::stringify!(managerForceSync),
            ::core::stringify!(disableRegistry),
            ::core::stringify!(enableRegistry),
            ::core::stringify!(revokeRole),
            ::core::stringify!(requirementImplementation),
            ::core::stringify!(MANAGER_ROLE),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <supportsInterfaceCall as alloy_sol_types::SolCall>::SIGNATURE,
            <enabledCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getRoleAdminCall as alloy_sol_types::SolCall>::SIGNATURE,
            <updateRequirementImplementationCall as alloy_sol_types::SolCall>::SIGNATURE,
            <maxAdditionalRegistrationsCall as alloy_sol_types::SolCall>::SIGNATURE,
            <managerSyncCall as alloy_sol_types::SolCall>::SIGNATURE,
            <grantRoleCall as alloy_sol_types::SolCall>::SIGNATURE,
            <renounceRoleCall as alloy_sol_types::SolCall>::SIGNATURE,
            <countRegisterdNodesPerAccountCall as alloy_sol_types::SolCall>::SIGNATURE,
            <managerDeregisterCall as alloy_sol_types::SolCall>::SIGNATURE,
            <isNodeRegisteredAndEligibleCall as alloy_sol_types::SolCall>::SIGNATURE,
            <isAccountEligibleCall as alloy_sol_types::SolCall>::SIGNATURE,
            <selfRegisterCall as alloy_sol_types::SolCall>::SIGNATURE,
            <managerRegisterCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getRoleMemberCall as alloy_sol_types::SolCall>::SIGNATURE,
            <hasRoleCall as alloy_sol_types::SolCall>::SIGNATURE,
            <selfSyncCall as alloy_sol_types::SolCall>::SIGNATURE,
            <selfDeregisterCall as alloy_sol_types::SolCall>::SIGNATURE,
            <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::SIGNATURE,
            <getRoleMembersCall as alloy_sol_types::SolCall>::SIGNATURE,
            <isNodeRegisteredByAccountCall as alloy_sol_types::SolCall>::SIGNATURE,
            <nodeRegisterdToAccountCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getRoleMemberCountCall as alloy_sol_types::SolCall>::SIGNATURE,
            <managerForceSyncCall as alloy_sol_types::SolCall>::SIGNATURE,
            <disableRegistryCall as alloy_sol_types::SolCall>::SIGNATURE,
            <enableRegistryCall as alloy_sol_types::SolCall>::SIGNATURE,
            <revokeRoleCall as alloy_sol_types::SolCall>::SIGNATURE,
            <requirementImplementationCall as alloy_sol_types::SolCall>::SIGNATURE,
            <MANAGER_ROLECall as alloy_sol_types::SolCall>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for HoprNetworkRegistryCalls {
        const NAME: &'static str = "HoprNetworkRegistryCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 29usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::DEFAULT_ADMIN_ROLE(_) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::MANAGER_ROLE(_) => {
                    <MANAGER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::countRegisterdNodesPerAccount(_) => {
                    <countRegisterdNodesPerAccountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::disableRegistry(_) => {
                    <disableRegistryCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::enableRegistry(_) => {
                    <enableRegistryCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::enabled(_) => <enabledCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getRoleAdmin(_) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRoleMember(_) => {
                    <getRoleMemberCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRoleMemberCount(_) => {
                    <getRoleMemberCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRoleMembers(_) => {
                    <getRoleMembersCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::grantRole(_) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::hasRole(_) => <hasRoleCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::isAccountEligible(_) => {
                    <isAccountEligibleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isNodeRegisteredAndEligible(_) => {
                    <isNodeRegisteredAndEligibleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isNodeRegisteredByAccount(_) => {
                    <isNodeRegisteredByAccountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::managerDeregister(_) => {
                    <managerDeregisterCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::managerForceSync(_) => {
                    <managerForceSyncCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::managerRegister(_) => {
                    <managerRegisterCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::managerSync(_) => {
                    <managerSyncCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::maxAdditionalRegistrations(_) => {
                    <maxAdditionalRegistrationsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::nodeRegisterdToAccount(_) => {
                    <nodeRegisterdToAccountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::renounceRole(_) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::requirementImplementation(_) => {
                    <requirementImplementationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::revokeRole(_) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::selfDeregister(_) => {
                    <selfDeregisterCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::selfRegister(_) => {
                    <selfRegisterCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::selfSync(_) => <selfSyncCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::supportsInterface(_) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::updateRequirementImplementation(_) => {
                    <updateRequirementImplementationCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls>] = &[
                {
                    fn supportsInterface(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::supportsInterface)
                    }
                    supportsInterface
                },
                {
                    fn enabled(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <enabledCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprNetworkRegistryCalls::enabled)
                    }
                    enabled
                },
                {
                    fn getRoleAdmin(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <getRoleAdminCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::getRoleAdmin)
                    }
                    getRoleAdmin
                },
                {
                    fn updateRequirementImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <updateRequirementImplementationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                HoprNetworkRegistryCalls::updateRequirementImplementation,
                            )
                    }
                    updateRequirementImplementation
                },
                {
                    fn maxAdditionalRegistrations(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <maxAdditionalRegistrationsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::maxAdditionalRegistrations)
                    }
                    maxAdditionalRegistrations
                },
                {
                    fn managerSync(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <managerSyncCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::managerSync)
                    }
                    managerSync
                },
                {
                    fn grantRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <grantRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprNetworkRegistryCalls::grantRole)
                    }
                    grantRole
                },
                {
                    fn renounceRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <renounceRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::renounceRole)
                    }
                    renounceRole
                },
                {
                    fn countRegisterdNodesPerAccount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <countRegisterdNodesPerAccountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::countRegisterdNodesPerAccount)
                    }
                    countRegisterdNodesPerAccount
                },
                {
                    fn managerDeregister(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <managerDeregisterCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::managerDeregister)
                    }
                    managerDeregister
                },
                {
                    fn isNodeRegisteredAndEligible(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <isNodeRegisteredAndEligibleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::isNodeRegisteredAndEligible)
                    }
                    isNodeRegisteredAndEligible
                },
                {
                    fn isAccountEligible(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <isAccountEligibleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::isAccountEligible)
                    }
                    isAccountEligible
                },
                {
                    fn selfRegister(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <selfRegisterCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::selfRegister)
                    }
                    selfRegister
                },
                {
                    fn managerRegister(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <managerRegisterCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::managerRegister)
                    }
                    managerRegister
                },
                {
                    fn getRoleMember(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <getRoleMemberCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::getRoleMember)
                    }
                    getRoleMember
                },
                {
                    fn hasRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <hasRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprNetworkRegistryCalls::hasRole)
                    }
                    hasRole
                },
                {
                    fn selfSync(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <selfSyncCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprNetworkRegistryCalls::selfSync)
                    }
                    selfSync
                },
                {
                    fn selfDeregister(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <selfDeregisterCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::selfDeregister)
                    }
                    selfDeregister
                },
                {
                    fn DEFAULT_ADMIN_ROLE(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::DEFAULT_ADMIN_ROLE)
                    }
                    DEFAULT_ADMIN_ROLE
                },
                {
                    fn getRoleMembers(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <getRoleMembersCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::getRoleMembers)
                    }
                    getRoleMembers
                },
                {
                    fn isNodeRegisteredByAccount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <isNodeRegisteredByAccountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::isNodeRegisteredByAccount)
                    }
                    isNodeRegisteredByAccount
                },
                {
                    fn nodeRegisterdToAccount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <nodeRegisterdToAccountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::nodeRegisterdToAccount)
                    }
                    nodeRegisterdToAccount
                },
                {
                    fn getRoleMemberCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <getRoleMemberCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::getRoleMemberCount)
                    }
                    getRoleMemberCount
                },
                {
                    fn managerForceSync(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <managerForceSyncCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::managerForceSync)
                    }
                    managerForceSync
                },
                {
                    fn disableRegistry(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <disableRegistryCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::disableRegistry)
                    }
                    disableRegistry
                },
                {
                    fn enableRegistry(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <enableRegistryCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::enableRegistry)
                    }
                    enableRegistry
                },
                {
                    fn revokeRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <revokeRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::revokeRole)
                    }
                    revokeRole
                },
                {
                    fn requirementImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <requirementImplementationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::requirementImplementation)
                    }
                    requirementImplementation
                },
                {
                    fn MANAGER_ROLE(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::MANAGER_ROLE)
                    }
                    MANAGER_ROLE
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls>] = &[
                {
                    fn supportsInterface(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::supportsInterface)
                    }
                    supportsInterface
                },
                {
                    fn enabled(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <enabledCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::enabled)
                    }
                    enabled
                },
                {
                    fn getRoleAdmin(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <getRoleAdminCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::getRoleAdmin)
                    }
                    getRoleAdmin
                },
                {
                    fn updateRequirementImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <updateRequirementImplementationCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                HoprNetworkRegistryCalls::updateRequirementImplementation,
                            )
                    }
                    updateRequirementImplementation
                },
                {
                    fn maxAdditionalRegistrations(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <maxAdditionalRegistrationsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::maxAdditionalRegistrations)
                    }
                    maxAdditionalRegistrations
                },
                {
                    fn managerSync(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <managerSyncCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::managerSync)
                    }
                    managerSync
                },
                {
                    fn grantRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <grantRoleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::grantRole)
                    }
                    grantRole
                },
                {
                    fn renounceRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <renounceRoleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::renounceRole)
                    }
                    renounceRole
                },
                {
                    fn countRegisterdNodesPerAccount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <countRegisterdNodesPerAccountCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::countRegisterdNodesPerAccount)
                    }
                    countRegisterdNodesPerAccount
                },
                {
                    fn managerDeregister(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <managerDeregisterCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::managerDeregister)
                    }
                    managerDeregister
                },
                {
                    fn isNodeRegisteredAndEligible(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <isNodeRegisteredAndEligibleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::isNodeRegisteredAndEligible)
                    }
                    isNodeRegisteredAndEligible
                },
                {
                    fn isAccountEligible(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <isAccountEligibleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::isAccountEligible)
                    }
                    isAccountEligible
                },
                {
                    fn selfRegister(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <selfRegisterCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::selfRegister)
                    }
                    selfRegister
                },
                {
                    fn managerRegister(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <managerRegisterCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::managerRegister)
                    }
                    managerRegister
                },
                {
                    fn getRoleMember(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <getRoleMemberCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::getRoleMember)
                    }
                    getRoleMember
                },
                {
                    fn hasRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <hasRoleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::hasRole)
                    }
                    hasRole
                },
                {
                    fn selfSync(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <selfSyncCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::selfSync)
                    }
                    selfSync
                },
                {
                    fn selfDeregister(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <selfDeregisterCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::selfDeregister)
                    }
                    selfDeregister
                },
                {
                    fn DEFAULT_ADMIN_ROLE(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::DEFAULT_ADMIN_ROLE)
                    }
                    DEFAULT_ADMIN_ROLE
                },
                {
                    fn getRoleMembers(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <getRoleMembersCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::getRoleMembers)
                    }
                    getRoleMembers
                },
                {
                    fn isNodeRegisteredByAccount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <isNodeRegisteredByAccountCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::isNodeRegisteredByAccount)
                    }
                    isNodeRegisteredByAccount
                },
                {
                    fn nodeRegisterdToAccount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <nodeRegisterdToAccountCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::nodeRegisterdToAccount)
                    }
                    nodeRegisterdToAccount
                },
                {
                    fn getRoleMemberCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <getRoleMemberCountCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::getRoleMemberCount)
                    }
                    getRoleMemberCount
                },
                {
                    fn managerForceSync(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <managerForceSyncCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::managerForceSync)
                    }
                    managerForceSync
                },
                {
                    fn disableRegistry(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <disableRegistryCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::disableRegistry)
                    }
                    disableRegistry
                },
                {
                    fn enableRegistry(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <enableRegistryCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::enableRegistry)
                    }
                    enableRegistry
                },
                {
                    fn revokeRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <revokeRoleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::revokeRole)
                    }
                    revokeRole
                },
                {
                    fn requirementImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <requirementImplementationCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::requirementImplementation)
                    }
                    requirementImplementation
                },
                {
                    fn MANAGER_ROLE(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::MANAGER_ROLE)
                    }
                    MANAGER_ROLE
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::MANAGER_ROLE(inner) => {
                    <MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::countRegisterdNodesPerAccount(inner) => {
                    <countRegisterdNodesPerAccountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::disableRegistry(inner) => {
                    <disableRegistryCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::enableRegistry(inner) => {
                    <enableRegistryCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::enabled(inner) => {
                    <enabledCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRoleMember(inner) => {
                    <getRoleMemberCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRoleMemberCount(inner) => {
                    <getRoleMemberCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRoleMembers(inner) => {
                    <getRoleMembersCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::isAccountEligible(inner) => {
                    <isAccountEligibleCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::isNodeRegisteredAndEligible(inner) => {
                    <isNodeRegisteredAndEligibleCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::isNodeRegisteredByAccount(inner) => {
                    <isNodeRegisteredByAccountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::managerDeregister(inner) => {
                    <managerDeregisterCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::managerForceSync(inner) => {
                    <managerForceSyncCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::managerRegister(inner) => {
                    <managerRegisterCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::managerSync(inner) => {
                    <managerSyncCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::maxAdditionalRegistrations(inner) => {
                    <maxAdditionalRegistrationsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::nodeRegisterdToAccount(inner) => {
                    <nodeRegisterdToAccountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::requirementImplementation(inner) => {
                    <requirementImplementationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::selfDeregister(inner) => {
                    <selfDeregisterCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::selfRegister(inner) => {
                    <selfRegisterCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::selfSync(inner) => {
                    <selfSyncCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::updateRequirementImplementation(inner) => {
                    <updateRequirementImplementationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::MANAGER_ROLE(inner) => {
                    <MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::countRegisterdNodesPerAccount(inner) => {
                    <countRegisterdNodesPerAccountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::disableRegistry(inner) => {
                    <disableRegistryCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::enableRegistry(inner) => {
                    <enableRegistryCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::enabled(inner) => {
                    <enabledCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRoleMember(inner) => {
                    <getRoleMemberCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRoleMemberCount(inner) => {
                    <getRoleMemberCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRoleMembers(inner) => {
                    <getRoleMembersCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::isAccountEligible(inner) => {
                    <isAccountEligibleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isNodeRegisteredAndEligible(inner) => {
                    <isNodeRegisteredAndEligibleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isNodeRegisteredByAccount(inner) => {
                    <isNodeRegisteredByAccountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::managerDeregister(inner) => {
                    <managerDeregisterCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::managerForceSync(inner) => {
                    <managerForceSyncCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::managerRegister(inner) => {
                    <managerRegisterCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::managerSync(inner) => {
                    <managerSyncCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::maxAdditionalRegistrations(inner) => {
                    <maxAdditionalRegistrationsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::nodeRegisterdToAccount(inner) => {
                    <nodeRegisterdToAccountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::requirementImplementation(inner) => {
                    <requirementImplementationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::selfDeregister(inner) => {
                    <selfDeregisterCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::selfRegister(inner) => {
                    <selfRegisterCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::selfSync(inner) => {
                    <selfSyncCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::updateRequirementImplementation(inner) => {
                    <updateRequirementImplementationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`HoprNetworkRegistry`](self) custom errors.
    #[derive(Clone)]
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum HoprNetworkRegistryErrors {
        #[allow(missing_docs)]
        AccessControlBadConfirmation(AccessControlBadConfirmation),
        #[allow(missing_docs)]
        AccessControlUnauthorizedAccount(AccessControlUnauthorizedAccount),
        #[allow(missing_docs)]
        ArrayLengthNotMatch(ArrayLengthNotMatch),
        #[allow(missing_docs)]
        CannotOperateForNode(CannotOperateForNode),
        #[allow(missing_docs)]
        GloballyDisabledRegistry(GloballyDisabledRegistry),
        #[allow(missing_docs)]
        GloballyEnabledRegistry(GloballyEnabledRegistry),
        #[allow(missing_docs)]
        NodeAlreadyRegisterd(NodeAlreadyRegisterd),
        #[allow(missing_docs)]
        NodeNotYetRegisterd(NodeNotYetRegisterd),
        #[allow(missing_docs)]
        NodeRegisterdToOtherAccount(NodeRegisterdToOtherAccount),
        #[allow(missing_docs)]
        NotEnoughAllowanceToRegisterNode(NotEnoughAllowanceToRegisterNode),
        #[allow(missing_docs)]
        ZeroAddress(ZeroAddress),
    }
    impl HoprNetworkRegistryErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [7u8, 65u8, 73u8, 103u8],
            [15u8, 185u8, 189u8, 92u8],
            [91u8, 83u8, 59u8, 161u8],
            [102u8, 151u8, 178u8, 50u8],
            [177u8, 195u8, 200u8, 168u8],
            [191u8, 79u8, 221u8, 115u8],
            [196u8, 38u8, 56u8, 187u8],
            [226u8, 81u8, 125u8, 63u8],
            [234u8, 192u8, 211u8, 137u8],
            [237u8, 26u8, 12u8, 119u8],
            [237u8, 136u8, 47u8, 113u8],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(CannotOperateForNode),
            ::core::stringify!(NotEnoughAllowanceToRegisterNode),
            ::core::stringify!(NodeAlreadyRegisterd),
            ::core::stringify!(AccessControlBadConfirmation),
            ::core::stringify!(NodeNotYetRegisterd),
            ::core::stringify!(NodeRegisterdToOtherAccount),
            ::core::stringify!(GloballyDisabledRegistry),
            ::core::stringify!(AccessControlUnauthorizedAccount),
            ::core::stringify!(ZeroAddress),
            ::core::stringify!(GloballyEnabledRegistry),
            ::core::stringify!(ArrayLengthNotMatch),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <CannotOperateForNode as alloy_sol_types::SolError>::SIGNATURE,
            <NotEnoughAllowanceToRegisterNode as alloy_sol_types::SolError>::SIGNATURE,
            <NodeAlreadyRegisterd as alloy_sol_types::SolError>::SIGNATURE,
            <AccessControlBadConfirmation as alloy_sol_types::SolError>::SIGNATURE,
            <NodeNotYetRegisterd as alloy_sol_types::SolError>::SIGNATURE,
            <NodeRegisterdToOtherAccount as alloy_sol_types::SolError>::SIGNATURE,
            <GloballyDisabledRegistry as alloy_sol_types::SolError>::SIGNATURE,
            <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::SIGNATURE,
            <ZeroAddress as alloy_sol_types::SolError>::SIGNATURE,
            <GloballyEnabledRegistry as alloy_sol_types::SolError>::SIGNATURE,
            <ArrayLengthNotMatch as alloy_sol_types::SolError>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for HoprNetworkRegistryErrors {
        const NAME: &'static str = "HoprNetworkRegistryErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 11usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AccessControlBadConfirmation(_) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AccessControlUnauthorizedAccount(_) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ArrayLengthNotMatch(_) => {
                    <ArrayLengthNotMatch as alloy_sol_types::SolError>::SELECTOR
                }
                Self::CannotOperateForNode(_) => {
                    <CannotOperateForNode as alloy_sol_types::SolError>::SELECTOR
                }
                Self::GloballyDisabledRegistry(_) => {
                    <GloballyDisabledRegistry as alloy_sol_types::SolError>::SELECTOR
                }
                Self::GloballyEnabledRegistry(_) => {
                    <GloballyEnabledRegistry as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NodeAlreadyRegisterd(_) => {
                    <NodeAlreadyRegisterd as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NodeNotYetRegisterd(_) => {
                    <NodeNotYetRegisterd as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NodeRegisterdToOtherAccount(_) => {
                    <NodeRegisterdToOtherAccount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotEnoughAllowanceToRegisterNode(_) => {
                    <NotEnoughAllowanceToRegisterNode as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroAddress(_) => {
                    <ZeroAddress as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors>] = &[
                {
                    fn CannotOperateForNode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors> {
                        <CannotOperateForNode as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryErrors::CannotOperateForNode)
                    }
                    CannotOperateForNode
                },
                {
                    fn NotEnoughAllowanceToRegisterNode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors> {
                        <NotEnoughAllowanceToRegisterNode as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                HoprNetworkRegistryErrors::NotEnoughAllowanceToRegisterNode,
                            )
                    }
                    NotEnoughAllowanceToRegisterNode
                },
                {
                    fn NodeAlreadyRegisterd(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors> {
                        <NodeAlreadyRegisterd as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryErrors::NodeAlreadyRegisterd)
                    }
                    NodeAlreadyRegisterd
                },
                {
                    fn AccessControlBadConfirmation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors> {
                        <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryErrors::AccessControlBadConfirmation)
                    }
                    AccessControlBadConfirmation
                },
                {
                    fn NodeNotYetRegisterd(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors> {
                        <NodeNotYetRegisterd as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryErrors::NodeNotYetRegisterd)
                    }
                    NodeNotYetRegisterd
                },
                {
                    fn NodeRegisterdToOtherAccount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors> {
                        <NodeRegisterdToOtherAccount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryErrors::NodeRegisterdToOtherAccount)
                    }
                    NodeRegisterdToOtherAccount
                },
                {
                    fn GloballyDisabledRegistry(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors> {
                        <GloballyDisabledRegistry as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryErrors::GloballyDisabledRegistry)
                    }
                    GloballyDisabledRegistry
                },
                {
                    fn AccessControlUnauthorizedAccount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors> {
                        <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                HoprNetworkRegistryErrors::AccessControlUnauthorizedAccount,
                            )
                    }
                    AccessControlUnauthorizedAccount
                },
                {
                    fn ZeroAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors> {
                        <ZeroAddress as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(HoprNetworkRegistryErrors::ZeroAddress)
                    }
                    ZeroAddress
                },
                {
                    fn GloballyEnabledRegistry(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors> {
                        <GloballyEnabledRegistry as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryErrors::GloballyEnabledRegistry)
                    }
                    GloballyEnabledRegistry
                },
                {
                    fn ArrayLengthNotMatch(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors> {
                        <ArrayLengthNotMatch as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryErrors::ArrayLengthNotMatch)
                    }
                    ArrayLengthNotMatch
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors>] = &[
                {
                    fn CannotOperateForNode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors> {
                        <CannotOperateForNode as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryErrors::CannotOperateForNode)
                    }
                    CannotOperateForNode
                },
                {
                    fn NotEnoughAllowanceToRegisterNode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors> {
                        <NotEnoughAllowanceToRegisterNode as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                HoprNetworkRegistryErrors::NotEnoughAllowanceToRegisterNode,
                            )
                    }
                    NotEnoughAllowanceToRegisterNode
                },
                {
                    fn NodeAlreadyRegisterd(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors> {
                        <NodeAlreadyRegisterd as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryErrors::NodeAlreadyRegisterd)
                    }
                    NodeAlreadyRegisterd
                },
                {
                    fn AccessControlBadConfirmation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors> {
                        <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryErrors::AccessControlBadConfirmation)
                    }
                    AccessControlBadConfirmation
                },
                {
                    fn NodeNotYetRegisterd(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors> {
                        <NodeNotYetRegisterd as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryErrors::NodeNotYetRegisterd)
                    }
                    NodeNotYetRegisterd
                },
                {
                    fn NodeRegisterdToOtherAccount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors> {
                        <NodeRegisterdToOtherAccount as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryErrors::NodeRegisterdToOtherAccount)
                    }
                    NodeRegisterdToOtherAccount
                },
                {
                    fn GloballyDisabledRegistry(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors> {
                        <GloballyDisabledRegistry as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryErrors::GloballyDisabledRegistry)
                    }
                    GloballyDisabledRegistry
                },
                {
                    fn AccessControlUnauthorizedAccount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors> {
                        <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                HoprNetworkRegistryErrors::AccessControlUnauthorizedAccount,
                            )
                    }
                    AccessControlUnauthorizedAccount
                },
                {
                    fn ZeroAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors> {
                        <ZeroAddress as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryErrors::ZeroAddress)
                    }
                    ZeroAddress
                },
                {
                    fn GloballyEnabledRegistry(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors> {
                        <GloballyEnabledRegistry as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryErrors::GloballyEnabledRegistry)
                    }
                    GloballyEnabledRegistry
                },
                {
                    fn ArrayLengthNotMatch(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors> {
                        <ArrayLengthNotMatch as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryErrors::ArrayLengthNotMatch)
                    }
                    ArrayLengthNotMatch
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AccessControlBadConfirmation(inner) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AccessControlUnauthorizedAccount(inner) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ArrayLengthNotMatch(inner) => {
                    <ArrayLengthNotMatch as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CannotOperateForNode(inner) => {
                    <CannotOperateForNode as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::GloballyDisabledRegistry(inner) => {
                    <GloballyDisabledRegistry as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::GloballyEnabledRegistry(inner) => {
                    <GloballyEnabledRegistry as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NodeAlreadyRegisterd(inner) => {
                    <NodeAlreadyRegisterd as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NodeNotYetRegisterd(inner) => {
                    <NodeNotYetRegisterd as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NodeRegisterdToOtherAccount(inner) => {
                    <NodeRegisterdToOtherAccount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotEnoughAllowanceToRegisterNode(inner) => {
                    <NotEnoughAllowanceToRegisterNode as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ZeroAddress(inner) => {
                    <ZeroAddress as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AccessControlBadConfirmation(inner) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AccessControlUnauthorizedAccount(inner) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ArrayLengthNotMatch(inner) => {
                    <ArrayLengthNotMatch as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CannotOperateForNode(inner) => {
                    <CannotOperateForNode as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::GloballyDisabledRegistry(inner) => {
                    <GloballyDisabledRegistry as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::GloballyEnabledRegistry(inner) => {
                    <GloballyEnabledRegistry as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NodeAlreadyRegisterd(inner) => {
                    <NodeAlreadyRegisterd as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NodeNotYetRegisterd(inner) => {
                    <NodeNotYetRegisterd as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NodeRegisterdToOtherAccount(inner) => {
                    <NodeRegisterdToOtherAccount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotEnoughAllowanceToRegisterNode(inner) => {
                    <NotEnoughAllowanceToRegisterNode as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZeroAddress(inner) => {
                    <ZeroAddress as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`HoprNetworkRegistry`](self) events.
    #[derive(Clone)]
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum HoprNetworkRegistryEvents {
        #[allow(missing_docs)]
        Deregistered(Deregistered),
        #[allow(missing_docs)]
        DeregisteredByManager(DeregisteredByManager),
        #[allow(missing_docs)]
        EligibilityUpdated(EligibilityUpdated),
        #[allow(missing_docs)]
        NetworkRegistryStatusUpdated(NetworkRegistryStatusUpdated),
        #[allow(missing_docs)]
        Registered(Registered),
        #[allow(missing_docs)]
        RegisteredByManager(RegisteredByManager),
        #[allow(missing_docs)]
        RequirementUpdated(RequirementUpdated),
        #[allow(missing_docs)]
        RoleAdminChanged(RoleAdminChanged),
        #[allow(missing_docs)]
        RoleGranted(RoleGranted),
        #[allow(missing_docs)]
        RoleRevoked(RoleRevoked),
    }
    impl HoprNetworkRegistryEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                4u8, 225u8, 234u8, 164u8, 218u8, 24u8, 247u8, 231u8, 66u8, 164u8, 237u8,
                187u8, 233u8, 237u8, 227u8, 108u8, 223u8, 117u8, 247u8, 147u8, 187u8,
                3u8, 171u8, 33u8, 88u8, 192u8, 135u8, 127u8, 28u8, 175u8, 43u8, 147u8,
            ],
            [
                10u8, 49u8, 238u8, 157u8, 70u8, 168u8, 40u8, 136u8, 75u8, 129u8, 0u8,
                60u8, 132u8, 152u8, 21u8, 110u8, 166u8, 170u8, 21u8, 185u8, 181u8, 75u8,
                221u8, 14u8, 240u8, 181u8, 51u8, 217u8, 235u8, 165u8, 126u8, 85u8,
            ],
            [
                21u8, 154u8, 138u8, 233u8, 72u8, 252u8, 198u8, 231u8, 248u8, 181u8, 73u8,
                92u8, 13u8, 115u8, 233u8, 21u8, 152u8, 68u8, 10u8, 248u8, 166u8, 40u8,
                23u8, 36u8, 108u8, 9u8, 237u8, 194u8, 194u8, 141u8, 186u8, 138u8,
            ],
            [
                47u8, 135u8, 136u8, 17u8, 126u8, 126u8, 255u8, 29u8, 130u8, 233u8, 38u8,
                236u8, 121u8, 73u8, 1u8, 209u8, 124u8, 120u8, 2u8, 74u8, 80u8, 39u8, 9u8,
                64u8, 48u8, 69u8, 64u8, 167u8, 51u8, 101u8, 111u8, 13u8,
            ],
            [
                138u8, 196u8, 178u8, 235u8, 119u8, 73u8, 247u8, 92u8, 91u8, 153u8, 184u8,
                152u8, 229u8, 71u8, 253u8, 97u8, 93u8, 215u8, 164u8, 36u8, 230u8, 131u8,
                86u8, 234u8, 25u8, 107u8, 125u8, 174u8, 116u8, 45u8, 108u8, 50u8,
            ],
            [
                139u8, 200u8, 95u8, 37u8, 227u8, 233u8, 51u8, 151u8, 143u8, 9u8, 148u8,
                8u8, 179u8, 187u8, 62u8, 183u8, 99u8, 11u8, 118u8, 247u8, 69u8, 95u8,
                46u8, 32u8, 91u8, 203u8, 192u8, 167u8, 128u8, 225u8, 126u8, 114u8,
            ],
            [
                145u8, 118u8, 10u8, 16u8, 1u8, 245u8, 49u8, 236u8, 43u8, 238u8, 134u8,
                2u8, 190u8, 85u8, 173u8, 43u8, 17u8, 89u8, 70u8, 94u8, 223u8, 245u8,
                187u8, 205u8, 65u8, 210u8, 7u8, 3u8, 116u8, 42u8, 77u8, 66u8,
            ],
            [
                189u8, 121u8, 184u8, 111u8, 254u8, 10u8, 184u8, 232u8, 119u8, 97u8, 81u8,
                81u8, 66u8, 23u8, 205u8, 124u8, 172u8, 213u8, 44u8, 144u8, 159u8, 102u8,
                71u8, 92u8, 58u8, 244u8, 78u8, 18u8, 159u8, 11u8, 0u8, 255u8,
            ],
            [
                226u8, 153u8, 79u8, 141u8, 111u8, 96u8, 10u8, 212u8, 115u8, 219u8, 168u8,
                44u8, 10u8, 137u8, 10u8, 183u8, 175u8, 250u8, 203u8, 134u8, 13u8, 51u8,
                101u8, 244u8, 116u8, 186u8, 163u8, 220u8, 4u8, 162u8, 229u8, 87u8,
            ],
            [
                246u8, 57u8, 31u8, 92u8, 50u8, 217u8, 198u8, 157u8, 42u8, 71u8, 234u8,
                103u8, 11u8, 68u8, 41u8, 116u8, 181u8, 57u8, 53u8, 209u8, 237u8, 199u8,
                253u8, 100u8, 235u8, 33u8, 224u8, 71u8, 168u8, 57u8, 23u8, 27u8,
            ],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(RegisteredByManager),
            ::core::stringify!(Registered),
            ::core::stringify!(Deregistered),
            ::core::stringify!(RoleGranted),
            ::core::stringify!(RequirementUpdated),
            ::core::stringify!(NetworkRegistryStatusUpdated),
            ::core::stringify!(DeregisteredByManager),
            ::core::stringify!(RoleAdminChanged),
            ::core::stringify!(EligibilityUpdated),
            ::core::stringify!(RoleRevoked),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <RegisteredByManager as alloy_sol_types::SolEvent>::SIGNATURE,
            <Registered as alloy_sol_types::SolEvent>::SIGNATURE,
            <Deregistered as alloy_sol_types::SolEvent>::SIGNATURE,
            <RoleGranted as alloy_sol_types::SolEvent>::SIGNATURE,
            <RequirementUpdated as alloy_sol_types::SolEvent>::SIGNATURE,
            <NetworkRegistryStatusUpdated as alloy_sol_types::SolEvent>::SIGNATURE,
            <DeregisteredByManager as alloy_sol_types::SolEvent>::SIGNATURE,
            <RoleAdminChanged as alloy_sol_types::SolEvent>::SIGNATURE,
            <EligibilityUpdated as alloy_sol_types::SolEvent>::SIGNATURE,
            <RoleRevoked as alloy_sol_types::SolEvent>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 32usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 32usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for HoprNetworkRegistryEvents {
        const NAME: &'static str = "HoprNetworkRegistryEvents";
        const COUNT: usize = 10usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<Deregistered as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Deregistered as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::Deregistered)
                }
                Some(
                    <DeregisteredByManager as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <DeregisteredByManager as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::DeregisteredByManager)
                }
                Some(
                    <EligibilityUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <EligibilityUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::EligibilityUpdated)
                }
                Some(
                    <NetworkRegistryStatusUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <NetworkRegistryStatusUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::NetworkRegistryStatusUpdated)
                }
                Some(<Registered as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Registered as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::Registered)
                }
                Some(
                    <RegisteredByManager as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <RegisteredByManager as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RegisteredByManager)
                }
                Some(
                    <RequirementUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <RequirementUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RequirementUpdated)
                }
                Some(<RoleAdminChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleAdminChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RoleAdminChanged)
                }
                Some(<RoleGranted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleGranted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RoleGranted)
                }
                Some(<RoleRevoked as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleRevoked as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RoleRevoked)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for HoprNetworkRegistryEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Deregistered(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::DeregisteredByManager(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EligibilityUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::NetworkRegistryStatusUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Registered(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RegisteredByManager(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RequirementUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Deregistered(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::DeregisteredByManager(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EligibilityUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::NetworkRegistryStatusUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Registered(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RegisteredByManager(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RequirementUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`HoprNetworkRegistry`](self) contract instance.

See the [wrapper's documentation](`HoprNetworkRegistryInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        __provider: P,
    ) -> HoprNetworkRegistryInstance<P, N> {
        HoprNetworkRegistryInstance::<P, N>::new(address, __provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        __provider: P,
        _requirementImplementation: alloy::sol_types::private::Address,
        _newOwner: alloy::sol_types::private::Address,
        _manager: alloy::sol_types::private::Address,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<HoprNetworkRegistryInstance<P, N>>,
    > {
        HoprNetworkRegistryInstance::<
            P,
            N,
        >::deploy(__provider, _requirementImplementation, _newOwner, _manager)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        __provider: P,
        _requirementImplementation: alloy::sol_types::private::Address,
        _newOwner: alloy::sol_types::private::Address,
        _manager: alloy::sol_types::private::Address,
    ) -> alloy_contract::RawCallBuilder<P, N> {
        HoprNetworkRegistryInstance::<
            P,
            N,
        >::deploy_builder(__provider, _requirementImplementation, _newOwner, _manager)
    }
    /**A [`HoprNetworkRegistry`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`HoprNetworkRegistry`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct HoprNetworkRegistryInstance<P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for HoprNetworkRegistryInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("HoprNetworkRegistryInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > HoprNetworkRegistryInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`HoprNetworkRegistry`](self) contract instance.

See the [wrapper's documentation](`HoprNetworkRegistryInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            __provider: P,
        ) -> Self {
            Self {
                address,
                provider: __provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            __provider: P,
            _requirementImplementation: alloy::sol_types::private::Address,
            _newOwner: alloy::sol_types::private::Address,
            _manager: alloy::sol_types::private::Address,
        ) -> alloy_contract::Result<HoprNetworkRegistryInstance<P, N>> {
            let call_builder = Self::deploy_builder(
                __provider,
                _requirementImplementation,
                _newOwner,
                _manager,
            );
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            __provider: P,
            _requirementImplementation: alloy::sol_types::private::Address,
            _newOwner: alloy::sol_types::private::Address,
            _manager: alloy::sol_types::private::Address,
        ) -> alloy_contract::RawCallBuilder<P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                __provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall {
                            _requirementImplementation,
                            _newOwner,
                            _manager,
                        },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> HoprNetworkRegistryInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> HoprNetworkRegistryInstance<P, N> {
            HoprNetworkRegistryInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > HoprNetworkRegistryInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`DEFAULT_ADMIN_ROLE`] function.
        pub fn DEFAULT_ADMIN_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, DEFAULT_ADMIN_ROLECall, N> {
            self.call_builder(&DEFAULT_ADMIN_ROLECall)
        }
        ///Creates a new call builder for the [`MANAGER_ROLE`] function.
        pub fn MANAGER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, MANAGER_ROLECall, N> {
            self.call_builder(&MANAGER_ROLECall)
        }
        ///Creates a new call builder for the [`countRegisterdNodesPerAccount`] function.
        pub fn countRegisterdNodesPerAccount(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, countRegisterdNodesPerAccountCall, N> {
            self.call_builder(&countRegisterdNodesPerAccountCall(_0))
        }
        ///Creates a new call builder for the [`disableRegistry`] function.
        pub fn disableRegistry(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, disableRegistryCall, N> {
            self.call_builder(&disableRegistryCall)
        }
        ///Creates a new call builder for the [`enableRegistry`] function.
        pub fn enableRegistry(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, enableRegistryCall, N> {
            self.call_builder(&enableRegistryCall)
        }
        ///Creates a new call builder for the [`enabled`] function.
        pub fn enabled(&self) -> alloy_contract::SolCallBuilder<&P, enabledCall, N> {
            self.call_builder(&enabledCall)
        }
        ///Creates a new call builder for the [`getRoleAdmin`] function.
        pub fn getRoleAdmin(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, getRoleAdminCall, N> {
            self.call_builder(&getRoleAdminCall { role })
        }
        ///Creates a new call builder for the [`getRoleMember`] function.
        pub fn getRoleMember(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            index: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getRoleMemberCall, N> {
            self.call_builder(&getRoleMemberCall { role, index })
        }
        ///Creates a new call builder for the [`getRoleMemberCount`] function.
        pub fn getRoleMemberCount(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, getRoleMemberCountCall, N> {
            self.call_builder(&getRoleMemberCountCall { role })
        }
        ///Creates a new call builder for the [`getRoleMembers`] function.
        pub fn getRoleMembers(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, getRoleMembersCall, N> {
            self.call_builder(&getRoleMembersCall { role })
        }
        ///Creates a new call builder for the [`grantRole`] function.
        pub fn grantRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, grantRoleCall, N> {
            self.call_builder(&grantRoleCall { role, account })
        }
        ///Creates a new call builder for the [`hasRole`] function.
        pub fn hasRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, hasRoleCall, N> {
            self.call_builder(&hasRoleCall { role, account })
        }
        ///Creates a new call builder for the [`isAccountEligible`] function.
        pub fn isAccountEligible(
            &self,
            stakingAccount: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, isAccountEligibleCall, N> {
            self.call_builder(
                &isAccountEligibleCall {
                    stakingAccount,
                },
            )
        }
        ///Creates a new call builder for the [`isNodeRegisteredAndEligible`] function.
        pub fn isNodeRegisteredAndEligible(
            &self,
            nodeAddress: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, isNodeRegisteredAndEligibleCall, N> {
            self.call_builder(
                &isNodeRegisteredAndEligibleCall {
                    nodeAddress,
                },
            )
        }
        ///Creates a new call builder for the [`isNodeRegisteredByAccount`] function.
        pub fn isNodeRegisteredByAccount(
            &self,
            nodeAddress: alloy::sol_types::private::Address,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, isNodeRegisteredByAccountCall, N> {
            self.call_builder(
                &isNodeRegisteredByAccountCall {
                    nodeAddress,
                    account,
                },
            )
        }
        ///Creates a new call builder for the [`managerDeregister`] function.
        pub fn managerDeregister(
            &self,
            nodeAddresses: alloy::sol_types::private::Vec<
                alloy::sol_types::private::Address,
            >,
        ) -> alloy_contract::SolCallBuilder<&P, managerDeregisterCall, N> {
            self.call_builder(
                &managerDeregisterCall {
                    nodeAddresses,
                },
            )
        }
        ///Creates a new call builder for the [`managerForceSync`] function.
        pub fn managerForceSync(
            &self,
            stakingAccounts: alloy::sol_types::private::Vec<
                alloy::sol_types::private::Address,
            >,
            eligibilities: alloy::sol_types::private::Vec<bool>,
        ) -> alloy_contract::SolCallBuilder<&P, managerForceSyncCall, N> {
            self.call_builder(
                &managerForceSyncCall {
                    stakingAccounts,
                    eligibilities,
                },
            )
        }
        ///Creates a new call builder for the [`managerRegister`] function.
        pub fn managerRegister(
            &self,
            stakingAccounts: alloy::sol_types::private::Vec<
                alloy::sol_types::private::Address,
            >,
            nodeAddresses: alloy::sol_types::private::Vec<
                alloy::sol_types::private::Address,
            >,
        ) -> alloy_contract::SolCallBuilder<&P, managerRegisterCall, N> {
            self.call_builder(
                &managerRegisterCall {
                    stakingAccounts,
                    nodeAddresses,
                },
            )
        }
        ///Creates a new call builder for the [`managerSync`] function.
        pub fn managerSync(
            &self,
            stakingAccounts: alloy::sol_types::private::Vec<
                alloy::sol_types::private::Address,
            >,
        ) -> alloy_contract::SolCallBuilder<&P, managerSyncCall, N> {
            self.call_builder(&managerSyncCall { stakingAccounts })
        }
        ///Creates a new call builder for the [`maxAdditionalRegistrations`] function.
        pub fn maxAdditionalRegistrations(
            &self,
            stakingAccount: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, maxAdditionalRegistrationsCall, N> {
            self.call_builder(
                &maxAdditionalRegistrationsCall {
                    stakingAccount,
                },
            )
        }
        ///Creates a new call builder for the [`nodeRegisterdToAccount`] function.
        pub fn nodeRegisterdToAccount(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, nodeRegisterdToAccountCall, N> {
            self.call_builder(&nodeRegisterdToAccountCall(_0))
        }
        ///Creates a new call builder for the [`renounceRole`] function.
        pub fn renounceRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            callerConfirmation: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, renounceRoleCall, N> {
            self.call_builder(
                &renounceRoleCall {
                    role,
                    callerConfirmation,
                },
            )
        }
        ///Creates a new call builder for the [`requirementImplementation`] function.
        pub fn requirementImplementation(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, requirementImplementationCall, N> {
            self.call_builder(&requirementImplementationCall)
        }
        ///Creates a new call builder for the [`revokeRole`] function.
        pub fn revokeRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, revokeRoleCall, N> {
            self.call_builder(&revokeRoleCall { role, account })
        }
        ///Creates a new call builder for the [`selfDeregister`] function.
        pub fn selfDeregister(
            &self,
            nodeAddresses: alloy::sol_types::private::Vec<
                alloy::sol_types::private::Address,
            >,
        ) -> alloy_contract::SolCallBuilder<&P, selfDeregisterCall, N> {
            self.call_builder(
                &selfDeregisterCall {
                    nodeAddresses,
                },
            )
        }
        ///Creates a new call builder for the [`selfRegister`] function.
        pub fn selfRegister(
            &self,
            nodeAddresses: alloy::sol_types::private::Vec<
                alloy::sol_types::private::Address,
            >,
        ) -> alloy_contract::SolCallBuilder<&P, selfRegisterCall, N> {
            self.call_builder(&selfRegisterCall { nodeAddresses })
        }
        ///Creates a new call builder for the [`selfSync`] function.
        pub fn selfSync(&self) -> alloy_contract::SolCallBuilder<&P, selfSyncCall, N> {
            self.call_builder(&selfSyncCall)
        }
        ///Creates a new call builder for the [`supportsInterface`] function.
        pub fn supportsInterface(
            &self,
            interfaceId: alloy::sol_types::private::FixedBytes<4>,
        ) -> alloy_contract::SolCallBuilder<&P, supportsInterfaceCall, N> {
            self.call_builder(
                &supportsInterfaceCall {
                    interfaceId,
                },
            )
        }
        ///Creates a new call builder for the [`updateRequirementImplementation`] function.
        pub fn updateRequirementImplementation(
            &self,
            _requirementImplementation: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, updateRequirementImplementationCall, N> {
            self.call_builder(
                &updateRequirementImplementationCall {
                    _requirementImplementation,
                },
            )
        }
    }
    /// Event filters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > HoprNetworkRegistryInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`Deregistered`] event.
        pub fn Deregistered_filter(&self) -> alloy_contract::Event<&P, Deregistered, N> {
            self.event_filter::<Deregistered>()
        }
        ///Creates a new event filter for the [`DeregisteredByManager`] event.
        pub fn DeregisteredByManager_filter(
            &self,
        ) -> alloy_contract::Event<&P, DeregisteredByManager, N> {
            self.event_filter::<DeregisteredByManager>()
        }
        ///Creates a new event filter for the [`EligibilityUpdated`] event.
        pub fn EligibilityUpdated_filter(
            &self,
        ) -> alloy_contract::Event<&P, EligibilityUpdated, N> {
            self.event_filter::<EligibilityUpdated>()
        }
        ///Creates a new event filter for the [`NetworkRegistryStatusUpdated`] event.
        pub fn NetworkRegistryStatusUpdated_filter(
            &self,
        ) -> alloy_contract::Event<&P, NetworkRegistryStatusUpdated, N> {
            self.event_filter::<NetworkRegistryStatusUpdated>()
        }
        ///Creates a new event filter for the [`Registered`] event.
        pub fn Registered_filter(&self) -> alloy_contract::Event<&P, Registered, N> {
            self.event_filter::<Registered>()
        }
        ///Creates a new event filter for the [`RegisteredByManager`] event.
        pub fn RegisteredByManager_filter(
            &self,
        ) -> alloy_contract::Event<&P, RegisteredByManager, N> {
            self.event_filter::<RegisteredByManager>()
        }
        ///Creates a new event filter for the [`RequirementUpdated`] event.
        pub fn RequirementUpdated_filter(
            &self,
        ) -> alloy_contract::Event<&P, RequirementUpdated, N> {
            self.event_filter::<RequirementUpdated>()
        }
        ///Creates a new event filter for the [`RoleAdminChanged`] event.
        pub fn RoleAdminChanged_filter(
            &self,
        ) -> alloy_contract::Event<&P, RoleAdminChanged, N> {
            self.event_filter::<RoleAdminChanged>()
        }
        ///Creates a new event filter for the [`RoleGranted`] event.
        pub fn RoleGranted_filter(&self) -> alloy_contract::Event<&P, RoleGranted, N> {
            self.event_filter::<RoleGranted>()
        }
        ///Creates a new event filter for the [`RoleRevoked`] event.
        pub fn RoleRevoked_filter(&self) -> alloy_contract::Event<&P, RoleRevoked, N> {
            self.event_filter::<RoleRevoked>()
        }
    }
}
