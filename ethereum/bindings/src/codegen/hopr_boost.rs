/**

Generated by the following Solidity interface...
```solidity
interface HoprBoost {
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
    event BoostMinted(uint256 indexed boostTypeIndex, uint256 indexed boostNumerator, uint256 indexed redeemDeadline);
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
    event SetCreated(uint256 indexed typeIndex);
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    constructor(address newAdmin, string baseTokenURI);

    function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
    function MINTER_ROLE() external view returns (bytes32);
    function approve(address to, uint256 tokenId) external;
    function balanceOf(address owner) external view returns (uint256);
    function batchMint(address[] memory to, string memory boostType, string memory boostRank, uint256 boostNumerator, uint256 redeemDeadline) external;
    function boostOf(uint256 tokenId) external view returns (uint256, uint256);
    function getApproved(uint256 tokenId) external view returns (address);
    function getRoleAdmin(bytes32 role) external view returns (bytes32);
    function getRoleMember(bytes32 role, uint256 index) external view returns (address);
    function getRoleMemberCount(bytes32 role) external view returns (uint256);
    function grantRole(bytes32 role, address account) external;
    function hasRole(bytes32 role, address account) external view returns (bool);
    function isApprovedForAll(address owner, address operator) external view returns (bool);
    function mint(address to, string memory boostType, string memory boostRank, uint256 boostNumerator, uint256 redeemDeadline) external;
    function name() external view returns (string memory);
    function ownerOf(uint256 tokenId) external view returns (address);
    function reclaimErc20Tokens(address tokenAddress) external;
    function reclaimErc721Tokens(address tokenAddress, uint256 tokenId) external;
    function renounceRole(bytes32 role, address account) external;
    function revokeRole(bytes32 role, address account) external;
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) external;
    function setApprovalForAll(address operator, bool approved) external;
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
    function symbol() external view returns (string memory);
    function tokenByIndex(uint256 index) external view returns (uint256);
    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);
    function tokenURI(uint256 tokenId) external view returns (string memory);
    function totalSupply() external view returns (uint256);
    function transferFrom(address from, address to, uint256 tokenId) external;
    function typeAt(uint256 typeIndex) external view returns (string memory);
    function typeIndexOf(uint256 tokenId) external view returns (uint256);
    function typeOf(uint256 tokenId) external view returns (string memory);
    function updateBaseURI(string memory baseTokenURI) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "newAdmin",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "baseTokenURI",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "DEFAULT_ADMIN_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "MINTER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "approve",
    "inputs": [
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "tokenId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "balanceOf",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "batchMint",
    "inputs": [
      {
        "name": "to",
        "type": "address[]",
        "internalType": "address[]"
      },
      {
        "name": "boostType",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "boostRank",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "boostNumerator",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "redeemDeadline",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "boostOf",
    "inputs": [
      {
        "name": "tokenId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getApproved",
    "inputs": [
      {
        "name": "tokenId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRoleAdmin",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRoleMember",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "index",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRoleMemberCount",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "grantRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "hasRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isApprovedForAll",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "mint",
    "inputs": [
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "boostType",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "boostRank",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "boostNumerator",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "redeemDeadline",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "name",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "ownerOf",
    "inputs": [
      {
        "name": "tokenId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "reclaimErc20Tokens",
    "inputs": [
      {
        "name": "tokenAddress",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "reclaimErc721Tokens",
    "inputs": [
      {
        "name": "tokenAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "tokenId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "renounceRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "revokeRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "safeTransferFrom",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "tokenId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "safeTransferFrom",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "tokenId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "_data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setApprovalForAll",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "approved",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "supportsInterface",
    "inputs": [
      {
        "name": "interfaceId",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "symbol",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "tokenByIndex",
    "inputs": [
      {
        "name": "index",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "tokenOfOwnerByIndex",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "index",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "tokenURI",
    "inputs": [
      {
        "name": "tokenId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "totalSupply",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "transferFrom",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "tokenId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "typeAt",
    "inputs": [
      {
        "name": "typeIndex",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "typeIndexOf",
    "inputs": [
      {
        "name": "tokenId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "typeOf",
    "inputs": [
      {
        "name": "tokenId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "updateBaseURI",
    "inputs": [
      {
        "name": "baseTokenURI",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "Approval",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "approved",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "tokenId",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ApprovalForAll",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "approved",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BoostMinted",
    "inputs": [
      {
        "name": "boostTypeIndex",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "boostNumerator",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "redeemDeadline",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleAdminChanged",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "previousAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "newAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleGranted",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleRevoked",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SetCreated",
    "inputs": [
      {
        "name": "typeIndex",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Transfer",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "tokenId",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod HoprBoost {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x608060405234801561000f575f5ffd5b5060405161330938038061330983398101604081905261002e91610224565b6040518060400160405280600e81526020016d1213d41488109bdbdcdd0813919560921b8152506040518060400160405280600a8152602001691213d41488109bdbdcdd60b21b81525081600290816100879190610376565b5060036100948282610376565b50506001600d5550600e6100a88282610376565b506100b35f836100e4565b6100dd7f9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6836100e4565b5050610430565b6100ee828261010a565b5f82815260016020526040902061010590826101a7565b505050565b5f828152602081815260408083206001600160a01b038516845290915290205460ff166101a3575f828152602081815260408083206001600160a01b03851684529091529020805460ff191660011790556101623390565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45b5050565b5f6101bb836001600160a01b0384166101c4565b90505b92915050565b5f81815260018301602052604081205461020957508154600181810184555f8481526020808220909301849055845484825282860190935260409020919091556101be565b505f6101be565b634e487b7160e01b5f52604160045260245ffd5b5f5f60408385031215610235575f5ffd5b82516001600160a01b038116811461024b575f5ffd5b60208401519092506001600160401b03811115610266575f5ffd5b8301601f81018513610276575f5ffd5b80516001600160401b0381111561028f5761028f610210565b604051601f8201601f19908116603f011681016001600160401b03811182821017156102bd576102bd610210565b6040528181528282016020018710156102d4575f5ffd5b8160208401602083015e5f602083830101528093505050509250929050565b600181811c9082168061030757607f821691505b60208210810361032557634e487b7160e01b5f52602260045260245ffd5b50919050565b601f82111561010557805f5260205f20601f840160051c810160208510156103505750805b601f840160051c820191505b8181101561036f575f815560010161035c565b5050505050565b81516001600160401b0381111561038f5761038f610210565b6103a38161039d84546102f3565b8461032b565b6020601f8211600181146103d5575f83156103be5750848201515b5f19600385901b1c1916600184901b17845561036f565b5f84815260208120601f198516915b8281101561040457878501518255602094850194600190920191016103e4565b508482101561042157868401515f19600387901b60f8161c191681555b50505050600190811b01905550565b612ecc8061043d5f395ff3fe608060405234801561000f575f5ffd5b50600436106101fd575f3560e01c806370a0823111610114578063a22cb465116100a9578063c87b56dd11610079578063c87b56dd1461048a578063ca15c8731461049d578063d5391393146104b0578063d547741f146104d7578063e985e9c5146104ea575f5ffd5b8063a22cb4651461043e578063b5185a8814610451578063b88d4fde14610464578063c588ff8b14610477575f5ffd5b8063931688cb116100e4578063931688cb146104095780639365c5331461041c57806395d89b411461042f578063a217fddf14610437575f5ffd5b806370a082311461038f578063896cddf4146103a25780639010d07c146103e357806391d14854146103f6575f5ffd5b80632f2ff15d1161019557806348c64e411161016557806348c64e41146103245780634f6ccce714610337578063562317c51461034a5780636067bc15146103695780636352211e1461037c575f5ffd5b80632f2ff15d146102d85780632f745c59146102eb57806336568abe146102fe57806342842e0e14610311575f5ffd5b806318160ddd116101d057806318160ddd1461027e57806323b872dd14610290578063248a9ca3146102a357806329867dac146102c5575f5ffd5b806301ffc9a71461020157806306fdde0314610229578063081812fc1461023e578063095ea7b314610269575b5f5ffd5b61021461020f3660046125c8565b610525565b60405190151581526020015b60405180910390f35b61023161054f565b6040516102209190612611565b61025161024c366004612623565b6105df565b6040516001600160a01b039091168152602001610220565b61027c610277366004612655565b61066a565b005b600b545b604051908152602001610220565b61027c61029e36600461267d565b61077e565b6102826102b1366004612623565b5f9081526020819052604090206001015490565b61027c6102d336600461275e565b6107af565b61027c6102e63660046127e1565b61085f565b6102826102f9366004612655565b610884565b61027c61030c3660046127e1565b610918565b61027c61031f36600461267d565b610996565b61027c610332366004612655565b6109b0565b610282610345366004612623565b610a84565b610282610358366004612623565b5f9081526013602052604090205490565b61027c61037736600461280b565b610b14565b61025161038a366004612623565b610bfa565b61028261039d36600461280b565b610c70565b6103ce6103b0366004612623565b5f908152601160209081526040808320546012909252909120549091565b60408051928352602083019190915201610220565b6102516103f1366004612824565b610cf5565b6102146104043660046127e1565b610d13565b61027c610417366004612844565b610d3b565b61027c61042a3660046128b9565b610d52565b610231610eb1565b6102825f81565b61027c61044c36600461299e565b610ec0565b61023161045f366004612623565b610ecb565b61027c6104723660046129d3565b610ed8565b610231610485366004612623565b610f10565b610231610498366004612623565b610f2d565b6102826104ab366004612623565b610f38565b6102827f9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a681565b61027c6104e53660046127e1565b610f4e565b6102146104f8366004612a49565b6001600160a01b039182165f90815260076020908152604080832093909416825291909152205460ff1690565b5f6001600160e01b03198216630d639add60e11b1480610549575061054982610f73565b92915050565b60606002805461055e90612a71565b80601f016020809104026020016040519081016040528092919081815260200182805461058a90612a71565b80156105d55780601f106105ac576101008083540402835291602001916105d5565b820191905f5260205f20905b8154815290600101906020018083116105b857829003601f168201915b5050505050905090565b5f6105e982610f97565b61064f5760405162461bcd60e51b815260206004820152602c60248201527f4552433732313a20617070726f76656420717565727920666f72206e6f6e657860448201526b34b9ba32b73a103a37b5b2b760a11b60648201526084015b60405180910390fd5b505f908152600660205260409020546001600160a01b031690565b5f61067482610bfa565b9050806001600160a01b0316836001600160a01b0316036106e15760405162461bcd60e51b815260206004820152602160248201527f4552433732313a20617070726f76616c20746f2063757272656e74206f776e656044820152603960f91b6064820152608401610646565b336001600160a01b03821614806106fd57506106fd81336104f8565b61076f5760405162461bcd60e51b815260206004820152603860248201527f4552433732313a20617070726f76652063616c6c6572206973206e6f74206f7760448201527f6e6572206e6f7220617070726f76656420666f7220616c6c00000000000000006064820152608401610646565b6107798383610fb3565b505050565b6107883382611020565b6107a45760405162461bcd60e51b815260040161064690612aa9565b610779838383611107565b7f9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a66107da81336112ae565b6107e5600f86611312565b505f6107f2600f876113bb565b90505f8686604051602001610808929190612b11565b604051602081830303815290604052905061082688868685856113e5565b8385837f735e5eb5afdd72cc64657ded7e5de390af3708afb5b9a80b0e5c911a0499d98f60405160405180910390a45050505050505050565b5f8281526020819052604090206001015461087a81336112ae565b6107798383611434565b5f61088e83610c70565b82106108f05760405162461bcd60e51b815260206004820152602b60248201527f455243373231456e756d657261626c653a206f776e657220696e646578206f7560448201526a74206f6620626f756e647360a81b6064820152608401610646565b506001600160a01b03919091165f908152600960209081526040808320938352929052205490565b6001600160a01b03811633146109885760405162461bcd60e51b815260206004820152602f60248201527f416363657373436f6e74726f6c3a2063616e206f6e6c792072656e6f756e636560448201526e103937b632b9903337b91039b2b63360891b6064820152608401610646565b6109928282611455565b5050565b61077983838360405180602001604052805f815250610ed8565b5f6109bb81336112ae565b6002600d5403610a0d5760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152606401610646565b6002600d55604080516323b872dd60e01b81523060048201523360248201526044810184905290516001600160a01b038516916323b872dd916064808301925f92919082900301818387803b158015610a64575f5ffd5b505af1158015610a76573d5f5f3e3d5ffd5b50506001600d555050505050565b5f610a8e600b5490565b8210610af15760405162461bcd60e51b815260206004820152602c60248201527f455243373231456e756d657261626c653a20676c6f62616c20696e646578206f60448201526b7574206f6620626f756e647360a01b6064820152608401610646565b600b8281548110610b0457610b04612b39565b905f5260205f2001549050919050565b5f610b1f81336112ae565b6002600d5403610b715760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152606401610646565b6002600d55610bf1336040516370a0823160e01b81523060048201526001600160a01b038516906370a0823190602401602060405180830381865afa158015610bbc573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610be09190612b4d565b6001600160a01b0385169190611476565b50506001600d55565b5f818152600460205260408120546001600160a01b0316806105495760405162461bcd60e51b815260206004820152602960248201527f4552433732313a206f776e657220717565727920666f72206e6f6e657869737460448201526832b73a103a37b5b2b760b91b6064820152608401610646565b5f6001600160a01b038216610cda5760405162461bcd60e51b815260206004820152602a60248201527f4552433732313a2062616c616e636520717565727920666f7220746865207a65604482015269726f206164647265737360b01b6064820152608401610646565b506001600160a01b03165f9081526005602052604090205490565b5f828152600160205260408120610d0c90836114c8565b9392505050565b5f918252602082815260408084206001600160a01b0393909316845291905290205460ff1690565b5f610d4681336112ae565b600e6107798382612baf565b7f9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6610d7d81336112ae565b610dbf87878080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250600f939250506113129050565b505f610e0388888080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250600f939250506113bb9050565b90505f88888888604051602001610e1d9493929190612c69565b60408051601f1981840301815291905290505f5b8a811015610e7457610e6c8c8c83818110610e4e57610e4e612b39565b9050602002016020810190610e63919061280b565b878786866113e5565b600101610e31565b508385837f735e5eb5afdd72cc64657ded7e5de390af3708afb5b9a80b0e5c911a0499d98f60405160405180910390a45050505050505050505050565b60606003805461055e90612a71565b6109923383836114d3565b6060610549600f836115a0565b610ee23383611020565b610efe5760405162461bcd60e51b815260040161064690612aa9565b610f0a84848484611655565b50505050565b5f8181526013602052604090205460609061054990600f906115a0565b606061054982611688565b5f818152600160205260408120610549906117e4565b5f82815260208190526040902060010154610f6981336112ae565b6107798383611455565b5f6001600160e01b0319821663780e9d6360e01b14806105495750610549826117ed565b5f908152600460205260409020546001600160a01b0316151590565b5f81815260066020526040902080546001600160a01b0319166001600160a01b0384169081179091558190610fe782610bfa565b6001600160a01b03167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92560405160405180910390a45050565b5f61102a82610f97565b61108b5760405162461bcd60e51b815260206004820152602c60248201527f4552433732313a206f70657261746f7220717565727920666f72206e6f6e657860448201526b34b9ba32b73a103a37b5b2b760a11b6064820152608401610646565b5f61109583610bfa565b9050806001600160a01b0316846001600160a01b031614806110d05750836001600160a01b03166110c5846105df565b6001600160a01b0316145b806110ff57506001600160a01b038082165f9081526007602090815260408083209388168352929052205460ff165b949350505050565b826001600160a01b031661111a82610bfa565b6001600160a01b0316146111825760405162461bcd60e51b815260206004820152602960248201527f4552433732313a207472616e73666572206f6620746f6b656e2074686174206960448201526839903737ba1037bbb760b91b6064820152608401610646565b6001600160a01b0382166111e45760405162461bcd60e51b8152602060048201526024808201527f4552433732313a207472616e7366657220746f20746865207a65726f206164646044820152637265737360e01b6064820152608401610646565b6111ef83838361182c565b6111f95f82610fb3565b6001600160a01b0383165f908152600560205260408120805460019290611221908490612ca6565b90915550506001600160a01b0382165f90815260056020526040812080546001929061124e908490612cb9565b90915550505f8181526004602052604080822080546001600160a01b0319166001600160a01b0386811691821790925591518493918716917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef91a4505050565b6112b88282610d13565b610992576112d0816001600160a01b03166014611837565b6112db836020611837565b6040516020016112ec929190612ccc565b60408051601f198184030181529082905262461bcd60e51b825261064691600401612611565b5f61131d83836119cc565b6113b45782546001810184555f848152602090200161133c8382612baf565b5082546040516001850190611352908590612d21565b90815260200160405180910390208190555082600101826040516113769190612d21565b90815260405190819003602001812054907f11497a834951095469930ec62e1641f0dcf3617d9cd7579b6da76e54df3000a7905f90a2506001610549565b505f610549565b5f82600101826040516113ce9190612d21565b908152602001604051809103902054905092915050565b5f6113ef600b5490565b90506113fb86826119f8565b5f818152601160209081526040808320889055601282528083208790556013909152902083905561142c8183611b34565b505050505050565b61143e8282611bb7565b5f8281526001602052604090206107799082611c3a565b61145f8282611c4e565b5f8281526001602052604090206107799082611cb2565b604080516001600160a01b038416602482015260448082018490528251808303909101815260649091019091526020810180516001600160e01b031663a9059cbb60e01b179052610779908490611cc6565b5f610d0c8383611d97565b816001600160a01b0316836001600160a01b0316036115345760405162461bcd60e51b815260206004820152601960248201527f4552433732313a20617070726f766520746f2063616c6c6572000000000000006044820152606401610646565b6001600160a01b038381165f81815260076020908152604080832094871680845294825291829020805460ff191686151590811790915591519182527f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a3505050565b6060826115ae600184612ca6565b815481106115be576115be612b39565b905f5260205f200180546115d190612a71565b80601f01602080910402602001604051908101604052809291908181526020018280546115fd90612a71565b80156116485780601f1061161f57610100808354040283529160200191611648565b820191905f5260205f20905b81548152906001019060200180831161162b57829003601f168201915b5050505050905092915050565b611660848484611107565b61166c84848484611dbd565b610f0a5760405162461bcd60e51b815260040161064690612d2c565b606061169382610f97565b6116f95760405162461bcd60e51b815260206004820152603160248201527f45524337323155524953746f726167653a2055524920717565727920666f72206044820152703737b732bc34b9ba32b73a103a37b5b2b760791b6064820152608401610646565b5f828152600860205260408120805461171190612a71565b80601f016020809104026020016040519081016040528092919081815260200182805461173d90612a71565b80156117885780601f1061175f57610100808354040283529160200191611788565b820191905f5260205f20905b81548152906001019060200180831161176b57829003601f168201915b505050505090505f611798611eba565b905080515f036117a9575092915050565b8151156117db5780826040516020016117c3929190612d7e565b60405160208183030381529060405292505050919050565b6110ff84611ec9565b5f610549825490565b5f6001600160e01b031982166380ac58cd60e01b148061181d57506001600160e01b03198216635b5e139f60e01b145b80610549575061054982611f90565b610779838383611fb4565b60605f611845836002612d92565b611850906002612cb9565b6001600160401b03811115611867576118676126b7565b6040519080825280601f01601f191660200182016040528015611891576020820181803683370190505b509050600360fc1b815f815181106118ab576118ab612b39565b60200101906001600160f81b03191690815f1a905350600f60fb1b816001815181106118d9576118d9612b39565b60200101906001600160f81b03191690815f1a9053505f6118fb846002612d92565b611906906001612cb9565b90505b600181111561197d576f181899199a1a9b1b9c1cb0b131b232b360811b85600f166010811061193a5761193a612b39565b1a60f81b82828151811061195057611950612b39565b60200101906001600160f81b03191690815f1a90535060049490941c9361197681612da9565b9050611909565b508315610d0c5760405162461bcd60e51b815260206004820181905260248201527f537472696e67733a20686578206c656e67746820696e73756666696369656e746044820152606401610646565b5f82600101826040516119df9190612d21565b9081526040519081900360200190205415159392505050565b6001600160a01b038216611a4e5760405162461bcd60e51b815260206004820181905260248201527f4552433732313a206d696e7420746f20746865207a65726f20616464726573736044820152606401610646565b611a5781610f97565b15611aa45760405162461bcd60e51b815260206004820152601c60248201527f4552433732313a20746f6b656e20616c7265616479206d696e746564000000006044820152606401610646565b611aaf5f838361182c565b6001600160a01b0382165f908152600560205260408120805460019290611ad7908490612cb9565b90915550505f8181526004602052604080822080546001600160a01b0319166001600160a01b03861690811790915590518392907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef908290a45050565b611b3d82610f97565b611ba05760405162461bcd60e51b815260206004820152602e60248201527f45524337323155524953746f726167653a2055524920736574206f66206e6f6e60448201526d32bc34b9ba32b73a103a37b5b2b760911b6064820152608401610646565b5f8281526008602052604090206107798282612baf565b611bc18282610d13565b610992575f828152602081815260408083206001600160a01b03851684529091529020805460ff19166001179055611bf63390565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45050565b5f610d0c836001600160a01b03841661206b565b611c588282610d13565b15610992575f828152602081815260408083206001600160a01b0385168085529252808320805460ff1916905551339285917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a45050565b5f610d0c836001600160a01b0384166120b0565b5f611d1a826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166121939092919063ffffffff16565b8051909150156107795780806020019051810190611d389190612dbe565b6107795760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b6064820152608401610646565b5f825f018281548110611dac57611dac612b39565b905f5260205f200154905092915050565b5f6001600160a01b0384163b15611eaf57604051630a85bd0160e11b81526001600160a01b0385169063150b7a0290611e00903390899088908890600401612dd9565b6020604051808303815f875af1925050508015611e3a575060408051601f3d908101601f19168201909252611e3791810190612e15565b60015b611e95573d808015611e67576040519150601f19603f3d011682016040523d82523d5f602084013e611e6c565b606091505b5080515f03611e8d5760405162461bcd60e51b815260040161064690612d2c565b805181602001fd5b6001600160e01b031916630a85bd0160e11b1490506110ff565b506001949350505050565b6060600e805461055e90612a71565b6060611ed482610f97565b611f385760405162461bcd60e51b815260206004820152602f60248201527f4552433732314d657461646174613a2055524920717565727920666f72206e6f60448201526e3732bc34b9ba32b73a103a37b5b2b760891b6064820152608401610646565b5f611f41611eba565b90505f815111611f5f5760405180602001604052805f815250610d0c565b80611f69846121a1565b604051602001611f7a929190612d7e565b6040516020818303038152906040529392505050565b5f6001600160e01b03198216635a05180f60e01b148061054957506105498261229d565b6001600160a01b03831661200e5761200981600b80545f838152600c60205260408120829055600182018355919091527f0175b7a638427703f0dbe7bb9bbf987a2551717b34e79f33b5b1008d1fa01db90155565b612031565b816001600160a01b0316836001600160a01b0316146120315761203183826122d1565b6001600160a01b038216612048576107798161236a565b826001600160a01b0316826001600160a01b031614610779576107798282612411565b5f8181526001830160205260408120546113b457508154600181810184555f848152602080822090930184905584548482528286019093526040902091909155610549565b5f818152600183016020526040812054801561218a575f6120d2600183612ca6565b85549091505f906120e590600190612ca6565b9050818114612144575f865f01828154811061210357612103612b39565b905f5260205f200154905080875f01848154811061212357612123612b39565b5f918252602080832090910192909255918252600188019052604090208390555b855486908061215557612155612e30565b600190038181905f5260205f20015f90559055856001015f8681526020019081526020015f205f905560019350505050610549565b5f915050610549565b60606110ff84845f85612453565b6060815f036121c75750506040805180820190915260018152600360fc1b602082015290565b815f5b81156121f057806121da81612e44565b91506121e99050600a83612e70565b91506121ca565b5f816001600160401b03811115612209576122096126b7565b6040519080825280601f01601f191660200182016040528015612233576020820181803683370190505b5090505b84156110ff57612248600183612ca6565b9150612255600a86612e83565b612260906030612cb9565b60f81b81838151811061227557612275612b39565b60200101906001600160f81b03191690815f1a905350612296600a86612e70565b9450612237565b5f6001600160e01b03198216637965db0b60e01b148061054957506301ffc9a760e01b6001600160e01b0319831614610549565b5f60016122dd84610c70565b6122e79190612ca6565b5f838152600a6020526040902054909150808214612338576001600160a01b0384165f9081526009602090815260408083208584528252808320548484528184208190558352600a90915290208190555b505f918252600a602090815260408084208490556001600160a01b039094168352600981528383209183525290812055565b600b545f9061237b90600190612ca6565b5f838152600c6020526040812054600b80549394509092849081106123a2576123a2612b39565b905f5260205f200154905080600b83815481106123c1576123c1612b39565b5f918252602080832090910192909255828152600c9091526040808220849055858252812055600b8054806123f8576123f8612e30565b600190038181905f5260205f20015f9055905550505050565b5f61241b83610c70565b6001600160a01b039093165f9081526009602090815260408083208684528252808320859055938252600a9052919091209190915550565b6060824710156124b45760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b6064820152608401610646565b843b6125025760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610646565b5f5f866001600160a01b0316858760405161251d9190612d21565b5f6040518083038185875af1925050503d805f8114612557576040519150601f19603f3d011682016040523d82523d5f602084013e61255c565b606091505b509150915061256c828286612577565b979650505050505050565b60608315612586575081610d0c565b8251156125965782518084602001fd5b8160405162461bcd60e51b81526004016106469190612611565b6001600160e01b0319811681146125c5575f5ffd5b50565b5f602082840312156125d8575f5ffd5b8135610d0c816125b0565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b602081525f610d0c60208301846125e3565b5f60208284031215612633575f5ffd5b5035919050565b80356001600160a01b0381168114612650575f5ffd5b919050565b5f5f60408385031215612666575f5ffd5b61266f8361263a565b946020939093013593505050565b5f5f5f6060848603121561268f575f5ffd5b6126988461263a565b92506126a66020850161263a565b929592945050506040919091013590565b634e487b7160e01b5f52604160045260245ffd5b5f5f6001600160401b038411156126e4576126e46126b7565b50604051601f19601f85018116603f011681018181106001600160401b0382111715612712576127126126b7565b604052838152905080828401851015612729575f5ffd5b838360208301375f60208583010152509392505050565b5f82601f83011261274f575f5ffd5b610d0c838335602085016126cb565b5f5f5f5f5f60a08688031215612772575f5ffd5b61277b8661263a565b945060208601356001600160401b03811115612795575f5ffd5b6127a188828901612740565b94505060408601356001600160401b038111156127bc575f5ffd5b6127c888828901612740565b9598949750949560608101359550608001359392505050565b5f5f604083850312156127f2575f5ffd5b823591506128026020840161263a565b90509250929050565b5f6020828403121561281b575f5ffd5b610d0c8261263a565b5f5f60408385031215612835575f5ffd5b50508035926020909101359150565b5f60208284031215612854575f5ffd5b81356001600160401b03811115612869575f5ffd5b6110ff84828501612740565b5f5f83601f840112612885575f5ffd5b5081356001600160401b0381111561289b575f5ffd5b6020830191508360208285010111156128b2575f5ffd5b9250929050565b5f5f5f5f5f5f5f5f60a0898b0312156128d0575f5ffd5b88356001600160401b038111156128e5575f5ffd5b8901601f81018b136128f5575f5ffd5b80356001600160401b0381111561290a575f5ffd5b8b60208260051b840101111561291e575f5ffd5b6020918201995097508901356001600160401b0381111561293d575f5ffd5b6129498b828c01612875565b90975095505060408901356001600160401b03811115612967575f5ffd5b6129738b828c01612875565b999c989b509699959896976060870135966080013595509350505050565b80151581146125c5575f5ffd5b5f5f604083850312156129af575f5ffd5b6129b88361263a565b915060208301356129c881612991565b809150509250929050565b5f5f5f5f608085870312156129e6575f5ffd5b6129ef8561263a565b93506129fd6020860161263a565b92506040850135915060608501356001600160401b03811115612a1e575f5ffd5b8501601f81018713612a2e575f5ffd5b612a3d878235602084016126cb565b91505092959194509250565b5f5f60408385031215612a5a575f5ffd5b612a638361263a565b91506128026020840161263a565b600181811c90821680612a8557607f821691505b602082108103612aa357634e487b7160e01b5f52602260045260245ffd5b50919050565b60208082526031908201527f4552433732313a207472616e736665722063616c6c6572206973206e6f74206f6040820152701ddb995c881b9bdc88185c1c1c9bdd9959607a1b606082015260800190565b5f81518060208401855e5f93019283525090919050565b5f612b1c8285612afa565b602f60f81b8152612b306001820185612afa565b95945050505050565b634e487b7160e01b5f52603260045260245ffd5b5f60208284031215612b5d575f5ffd5b5051919050565b601f82111561077957805f5260205f20601f840160051c81016020851015612b895750805b601f840160051c820191505b81811015612ba8575f8155600101612b95565b5050505050565b81516001600160401b03811115612bc857612bc86126b7565b612bdc81612bd68454612a71565b84612b64565b6020601f821160018114612c0e575f8315612bf75750848201515b5f19600385901b1c1916600184901b178455612ba8565b5f84815260208120601f198516915b82811015612c3d5787850151825560209485019460019092019101612c1d565b5084821015612c5a57868401515f19600387901b60f8161c191681555b50505050600190811b01905550565b838582375f848201602f60f81b8152838560018301375f93016001019283525090949350505050565b634e487b7160e01b5f52601160045260245ffd5b8181038181111561054957610549612c92565b8082018082111561054957610549612c92565b7f416363657373436f6e74726f6c3a206163636f756e742000000000000000000081525f612cfd6017830185612afa565b7001034b99036b4b9b9b4b733903937b6329607d1b8152612b306011820185612afa565b5f610d0c8284612afa565b60208082526032908201527f4552433732313a207472616e7366657220746f206e6f6e20455243373231526560408201527131b2b4bb32b91034b6b83632b6b2b73a32b960711b606082015260800190565b5f6110ff612d8c8386612afa565b84612afa565b808202811582820484141761054957610549612c92565b5f81612db757612db7612c92565b505f190190565b5f60208284031215612dce575f5ffd5b8151610d0c81612991565b6001600160a01b03858116825284166020820152604081018390526080606082018190525f90612e0b908301846125e3565b9695505050505050565b5f60208284031215612e25575f5ffd5b8151610d0c816125b0565b634e487b7160e01b5f52603160045260245ffd5b5f60018201612e5557612e55612c92565b5060010190565b634e487b7160e01b5f52601260045260245ffd5b5f82612e7e57612e7e612e5c565b500490565b5f82612e9157612e91612e5c565b50069056fea2646970667358221220128d49eb2d344a9e2914c081651a3b2d1952cbd72d65fe8ccb7e6c7edd3fc31264736f6c634300081e0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`@Qa3\t8\x03\x80a3\t\x839\x81\x01`@\x81\x90Ra\0.\x91a\x02$V[`@Q\x80`@\x01`@R\x80`\x0E\x81R` \x01m\x12\x13\xD4\x14\x88\x10\x9B\xDB\xDC\xDD\x08\x13\x91\x95`\x92\x1B\x81RP`@Q\x80`@\x01`@R\x80`\n\x81R` \x01i\x12\x13\xD4\x14\x88\x10\x9B\xDB\xDC\xDD`\xB2\x1B\x81RP\x81`\x02\x90\x81a\0\x87\x91\x90a\x03vV[P`\x03a\0\x94\x82\x82a\x03vV[PP`\x01`\rUP`\x0Ea\0\xA8\x82\x82a\x03vV[Pa\0\xB3_\x83a\0\xE4V[a\0\xDD\x7F\x9F-\xF0\xFE\xD2\xC7vH\xDEX`\xA4\xCCP\x8C\xD0\x81\x8C\x85\xB8\xB8\xA1\xABL\xEE\xEF\x8D\x98\x1C\x89V\xA6\x83a\0\xE4V[PPa\x040V[a\0\xEE\x82\x82a\x01\nV[_\x82\x81R`\x01` R`@\x90 a\x01\x05\x90\x82a\x01\xA7V[PPPV[_\x82\x81R` \x81\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x85\x16\x84R\x90\x91R\x90 T`\xFF\x16a\x01\xA3W_\x82\x81R` \x81\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x85\x16\x84R\x90\x91R\x90 \x80T`\xFF\x19\x16`\x01\x17\x90Ua\x01b3\x90V[`\x01`\x01`\xA0\x1B\x03\x16\x81`\x01`\x01`\xA0\x1B\x03\x16\x83\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r`@Q`@Q\x80\x91\x03\x90\xA4[PPV[_a\x01\xBB\x83`\x01`\x01`\xA0\x1B\x03\x84\x16a\x01\xC4V[\x90P[\x92\x91PPV[_\x81\x81R`\x01\x83\x01` R`@\x81 Ta\x02\tWP\x81T`\x01\x81\x81\x01\x84U_\x84\x81R` \x80\x82 \x90\x93\x01\x84\x90U\x84T\x84\x82R\x82\x86\x01\x90\x93R`@\x90 \x91\x90\x91Ua\x01\xBEV[P_a\x01\xBEV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[__`@\x83\x85\x03\x12\x15a\x025W__\xFD[\x82Q`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x02KW__\xFD[` \x84\x01Q\x90\x92P`\x01`\x01`@\x1B\x03\x81\x11\x15a\x02fW__\xFD[\x83\x01`\x1F\x81\x01\x85\x13a\x02vW__\xFD[\x80Q`\x01`\x01`@\x1B\x03\x81\x11\x15a\x02\x8FWa\x02\x8Fa\x02\x10V[`@Q`\x1F\x82\x01`\x1F\x19\x90\x81\x16`?\x01\x16\x81\x01`\x01`\x01`@\x1B\x03\x81\x11\x82\x82\x10\x17\x15a\x02\xBDWa\x02\xBDa\x02\x10V[`@R\x81\x81R\x82\x82\x01` \x01\x87\x10\x15a\x02\xD4W__\xFD[\x81` \x84\x01` \x83\x01^_` \x83\x83\x01\x01R\x80\x93PPPP\x92P\x92\x90PV[`\x01\x81\x81\x1C\x90\x82\x16\x80a\x03\x07W`\x7F\x82\x16\x91P[` \x82\x10\x81\x03a\x03%WcNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[P\x91\x90PV[`\x1F\x82\x11\x15a\x01\x05W\x80_R` _ `\x1F\x84\x01`\x05\x1C\x81\x01` \x85\x10\x15a\x03PWP\x80[`\x1F\x84\x01`\x05\x1C\x82\x01\x91P[\x81\x81\x10\x15a\x03oW_\x81U`\x01\x01a\x03\\V[PPPPPV[\x81Q`\x01`\x01`@\x1B\x03\x81\x11\x15a\x03\x8FWa\x03\x8Fa\x02\x10V[a\x03\xA3\x81a\x03\x9D\x84Ta\x02\xF3V[\x84a\x03+V[` `\x1F\x82\x11`\x01\x81\x14a\x03\xD5W_\x83\x15a\x03\xBEWP\x84\x82\x01Q[_\x19`\x03\x85\x90\x1B\x1C\x19\x16`\x01\x84\x90\x1B\x17\x84Ua\x03oV[_\x84\x81R` \x81 `\x1F\x19\x85\x16\x91[\x82\x81\x10\x15a\x04\x04W\x87\x85\x01Q\x82U` \x94\x85\x01\x94`\x01\x90\x92\x01\x91\x01a\x03\xE4V[P\x84\x82\x10\x15a\x04!W\x86\x84\x01Q_\x19`\x03\x87\x90\x1B`\xF8\x16\x1C\x19\x16\x81U[PPPP`\x01\x90\x81\x1B\x01\x90UPV[a.\xCC\x80a\x04=_9_\xF3\xFE`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\x01\xFDW_5`\xE0\x1C\x80cp\xA0\x821\x11a\x01\x14W\x80c\xA2,\xB4e\x11a\0\xA9W\x80c\xC8{V\xDD\x11a\0yW\x80c\xC8{V\xDD\x14a\x04\x8AW\x80c\xCA\x15\xC8s\x14a\x04\x9DW\x80c\xD59\x13\x93\x14a\x04\xB0W\x80c\xD5Gt\x1F\x14a\x04\xD7W\x80c\xE9\x85\xE9\xC5\x14a\x04\xEAW__\xFD[\x80c\xA2,\xB4e\x14a\x04>W\x80c\xB5\x18Z\x88\x14a\x04QW\x80c\xB8\x8DO\xDE\x14a\x04dW\x80c\xC5\x88\xFF\x8B\x14a\x04wW__\xFD[\x80c\x93\x16\x88\xCB\x11a\0\xE4W\x80c\x93\x16\x88\xCB\x14a\x04\tW\x80c\x93e\xC53\x14a\x04\x1CW\x80c\x95\xD8\x9BA\x14a\x04/W\x80c\xA2\x17\xFD\xDF\x14a\x047W__\xFD[\x80cp\xA0\x821\x14a\x03\x8FW\x80c\x89l\xDD\xF4\x14a\x03\xA2W\x80c\x90\x10\xD0|\x14a\x03\xE3W\x80c\x91\xD1HT\x14a\x03\xF6W__\xFD[\x80c//\xF1]\x11a\x01\x95W\x80cH\xC6NA\x11a\x01eW\x80cH\xC6NA\x14a\x03$W\x80cOl\xCC\xE7\x14a\x037W\x80cV#\x17\xC5\x14a\x03JW\x80c`g\xBC\x15\x14a\x03iW\x80ccR!\x1E\x14a\x03|W__\xFD[\x80c//\xF1]\x14a\x02\xD8W\x80c/t\\Y\x14a\x02\xEBW\x80c6V\x8A\xBE\x14a\x02\xFEW\x80cB\x84.\x0E\x14a\x03\x11W__\xFD[\x80c\x18\x16\r\xDD\x11a\x01\xD0W\x80c\x18\x16\r\xDD\x14a\x02~W\x80c#\xB8r\xDD\x14a\x02\x90W\x80c$\x8A\x9C\xA3\x14a\x02\xA3W\x80c)\x86}\xAC\x14a\x02\xC5W__\xFD[\x80c\x01\xFF\xC9\xA7\x14a\x02\x01W\x80c\x06\xFD\xDE\x03\x14a\x02)W\x80c\x08\x18\x12\xFC\x14a\x02>W\x80c\t^\xA7\xB3\x14a\x02iW[__\xFD[a\x02\x14a\x02\x0F6`\x04a%\xC8V[a\x05%V[`@Q\x90\x15\x15\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\x021a\x05OV[`@Qa\x02 \x91\x90a&\x11V[a\x02Qa\x02L6`\x04a&#V[a\x05\xDFV[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\x02 V[a\x02|a\x02w6`\x04a&UV[a\x06jV[\0[`\x0BT[`@Q\x90\x81R` \x01a\x02 V[a\x02|a\x02\x9E6`\x04a&}V[a\x07~V[a\x02\x82a\x02\xB16`\x04a&#V[_\x90\x81R` \x81\x90R`@\x90 `\x01\x01T\x90V[a\x02|a\x02\xD36`\x04a'^V[a\x07\xAFV[a\x02|a\x02\xE66`\x04a'\xE1V[a\x08_V[a\x02\x82a\x02\xF96`\x04a&UV[a\x08\x84V[a\x02|a\x03\x0C6`\x04a'\xE1V[a\t\x18V[a\x02|a\x03\x1F6`\x04a&}V[a\t\x96V[a\x02|a\x0326`\x04a&UV[a\t\xB0V[a\x02\x82a\x03E6`\x04a&#V[a\n\x84V[a\x02\x82a\x03X6`\x04a&#V[_\x90\x81R`\x13` R`@\x90 T\x90V[a\x02|a\x03w6`\x04a(\x0BV[a\x0B\x14V[a\x02Qa\x03\x8A6`\x04a&#V[a\x0B\xFAV[a\x02\x82a\x03\x9D6`\x04a(\x0BV[a\x0CpV[a\x03\xCEa\x03\xB06`\x04a&#V[_\x90\x81R`\x11` \x90\x81R`@\x80\x83 T`\x12\x90\x92R\x90\x91 T\x90\x91V[`@\x80Q\x92\x83R` \x83\x01\x91\x90\x91R\x01a\x02 V[a\x02Qa\x03\xF16`\x04a($V[a\x0C\xF5V[a\x02\x14a\x04\x046`\x04a'\xE1V[a\r\x13V[a\x02|a\x04\x176`\x04a(DV[a\r;V[a\x02|a\x04*6`\x04a(\xB9V[a\rRV[a\x021a\x0E\xB1V[a\x02\x82_\x81V[a\x02|a\x04L6`\x04a)\x9EV[a\x0E\xC0V[a\x021a\x04_6`\x04a&#V[a\x0E\xCBV[a\x02|a\x04r6`\x04a)\xD3V[a\x0E\xD8V[a\x021a\x04\x856`\x04a&#V[a\x0F\x10V[a\x021a\x04\x986`\x04a&#V[a\x0F-V[a\x02\x82a\x04\xAB6`\x04a&#V[a\x0F8V[a\x02\x82\x7F\x9F-\xF0\xFE\xD2\xC7vH\xDEX`\xA4\xCCP\x8C\xD0\x81\x8C\x85\xB8\xB8\xA1\xABL\xEE\xEF\x8D\x98\x1C\x89V\xA6\x81V[a\x02|a\x04\xE56`\x04a'\xE1V[a\x0FNV[a\x02\x14a\x04\xF86`\x04a*IV[`\x01`\x01`\xA0\x1B\x03\x91\x82\x16_\x90\x81R`\x07` \x90\x81R`@\x80\x83 \x93\x90\x94\x16\x82R\x91\x90\x91R T`\xFF\x16\x90V[_`\x01`\x01`\xE0\x1B\x03\x19\x82\x16c\rc\x9A\xDD`\xE1\x1B\x14\x80a\x05IWPa\x05I\x82a\x0FsV[\x92\x91PPV[```\x02\x80Ta\x05^\x90a*qV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x05\x8A\x90a*qV[\x80\x15a\x05\xD5W\x80`\x1F\x10a\x05\xACWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x05\xD5V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x05\xB8W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x90P\x90V[_a\x05\xE9\x82a\x0F\x97V[a\x06OW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`,`$\x82\x01R\x7FERC721: approved query for nonex`D\x82\x01Rk4\xB9\xBA2\xB7:\x10:7\xB5\xB2\xB7`\xA1\x1B`d\x82\x01R`\x84\x01[`@Q\x80\x91\x03\x90\xFD[P_\x90\x81R`\x06` R`@\x90 T`\x01`\x01`\xA0\x1B\x03\x16\x90V[_a\x06t\x82a\x0B\xFAV[\x90P\x80`\x01`\x01`\xA0\x1B\x03\x16\x83`\x01`\x01`\xA0\x1B\x03\x16\x03a\x06\xE1W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`!`$\x82\x01R\x7FERC721: approval to current owne`D\x82\x01R`9`\xF9\x1B`d\x82\x01R`\x84\x01a\x06FV[3`\x01`\x01`\xA0\x1B\x03\x82\x16\x14\x80a\x06\xFDWPa\x06\xFD\x813a\x04\xF8V[a\x07oW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`8`$\x82\x01R\x7FERC721: approve caller is not ow`D\x82\x01R\x7Fner nor approved for all\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06FV[a\x07y\x83\x83a\x0F\xB3V[PPPV[a\x07\x883\x82a\x10 V[a\x07\xA4W`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x06F\x90a*\xA9V[a\x07y\x83\x83\x83a\x11\x07V[\x7F\x9F-\xF0\xFE\xD2\xC7vH\xDEX`\xA4\xCCP\x8C\xD0\x81\x8C\x85\xB8\xB8\xA1\xABL\xEE\xEF\x8D\x98\x1C\x89V\xA6a\x07\xDA\x813a\x12\xAEV[a\x07\xE5`\x0F\x86a\x13\x12V[P_a\x07\xF2`\x0F\x87a\x13\xBBV[\x90P_\x86\x86`@Q` \x01a\x08\x08\x92\x91\x90a+\x11V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x90Pa\x08&\x88\x86\x86\x85\x85a\x13\xE5V[\x83\x85\x83\x7Fs^^\xB5\xAF\xDDr\xCCde}\xED~]\xE3\x90\xAF7\x08\xAF\xB5\xB9\xA8\x0B\x0E\\\x91\x1A\x04\x99\xD9\x8F`@Q`@Q\x80\x91\x03\x90\xA4PPPPPPPPV[_\x82\x81R` \x81\x90R`@\x90 `\x01\x01Ta\x08z\x813a\x12\xAEV[a\x07y\x83\x83a\x144V[_a\x08\x8E\x83a\x0CpV[\x82\x10a\x08\xF0W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`+`$\x82\x01R\x7FERC721Enumerable: owner index ou`D\x82\x01Rjt of bounds`\xA8\x1B`d\x82\x01R`\x84\x01a\x06FV[P`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16_\x90\x81R`\t` \x90\x81R`@\x80\x83 \x93\x83R\x92\x90R T\x90V[`\x01`\x01`\xA0\x1B\x03\x81\x163\x14a\t\x88W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`/`$\x82\x01R\x7FAccessControl: can only renounce`D\x82\x01Rn\x1097\xB62\xB9\x9037\xB9\x109\xB2\xB63`\x89\x1B`d\x82\x01R`\x84\x01a\x06FV[a\t\x92\x82\x82a\x14UV[PPV[a\x07y\x83\x83\x83`@Q\x80` \x01`@R\x80_\x81RPa\x0E\xD8V[_a\t\xBB\x813a\x12\xAEV[`\x02`\rT\x03a\n\rW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1F`$\x82\x01R\x7FReentrancyGuard: reentrant call\0`D\x82\x01R`d\x01a\x06FV[`\x02`\rU`@\x80Qc#\xB8r\xDD`\xE0\x1B\x81R0`\x04\x82\x01R3`$\x82\x01R`D\x81\x01\x84\x90R\x90Q`\x01`\x01`\xA0\x1B\x03\x85\x16\x91c#\xB8r\xDD\x91`d\x80\x83\x01\x92_\x92\x91\x90\x82\x90\x03\x01\x81\x83\x87\x80;\x15\x80\x15a\ndW__\xFD[PZ\xF1\x15\x80\x15a\nvW=__>=_\xFD[PP`\x01`\rUPPPPPV[_a\n\x8E`\x0BT\x90V[\x82\x10a\n\xF1W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`,`$\x82\x01R\x7FERC721Enumerable: global index o`D\x82\x01Rkut of bounds`\xA0\x1B`d\x82\x01R`\x84\x01a\x06FV[`\x0B\x82\x81T\x81\x10a\x0B\x04Wa\x0B\x04a+9V[\x90_R` _ \x01T\x90P\x91\x90PV[_a\x0B\x1F\x813a\x12\xAEV[`\x02`\rT\x03a\x0BqW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1F`$\x82\x01R\x7FReentrancyGuard: reentrant call\0`D\x82\x01R`d\x01a\x06FV[`\x02`\rUa\x0B\xF13`@Qcp\xA0\x821`\xE0\x1B\x81R0`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x85\x16\x90cp\xA0\x821\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0B\xBCW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0B\xE0\x91\x90a+MV[`\x01`\x01`\xA0\x1B\x03\x85\x16\x91\x90a\x14vV[PP`\x01`\rUV[_\x81\x81R`\x04` R`@\x81 T`\x01`\x01`\xA0\x1B\x03\x16\x80a\x05IW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`)`$\x82\x01R\x7FERC721: owner query for nonexist`D\x82\x01Rh2\xB7:\x10:7\xB5\xB2\xB7`\xB9\x1B`d\x82\x01R`\x84\x01a\x06FV[_`\x01`\x01`\xA0\x1B\x03\x82\x16a\x0C\xDAW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`*`$\x82\x01R\x7FERC721: balance query for the ze`D\x82\x01Riro address`\xB0\x1B`d\x82\x01R`\x84\x01a\x06FV[P`\x01`\x01`\xA0\x1B\x03\x16_\x90\x81R`\x05` R`@\x90 T\x90V[_\x82\x81R`\x01` R`@\x81 a\r\x0C\x90\x83a\x14\xC8V[\x93\x92PPPV[_\x91\x82R` \x82\x81R`@\x80\x84 `\x01`\x01`\xA0\x1B\x03\x93\x90\x93\x16\x84R\x91\x90R\x90 T`\xFF\x16\x90V[_a\rF\x813a\x12\xAEV[`\x0Ea\x07y\x83\x82a+\xAFV[\x7F\x9F-\xF0\xFE\xD2\xC7vH\xDEX`\xA4\xCCP\x8C\xD0\x81\x8C\x85\xB8\xB8\xA1\xABL\xEE\xEF\x8D\x98\x1C\x89V\xA6a\r}\x813a\x12\xAEV[a\r\xBF\x87\x87\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x91\x90\x91RP`\x0F\x93\x92PPa\x13\x12\x90PV[P_a\x0E\x03\x88\x88\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x91\x90\x91RP`\x0F\x93\x92PPa\x13\xBB\x90PV[\x90P_\x88\x88\x88\x88`@Q` \x01a\x0E\x1D\x94\x93\x92\x91\x90a,iV[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R\x90P_[\x8A\x81\x10\x15a\x0EtWa\x0El\x8C\x8C\x83\x81\x81\x10a\x0ENWa\x0ENa+9V[\x90P` \x02\x01` \x81\x01\x90a\x0Ec\x91\x90a(\x0BV[\x87\x87\x86\x86a\x13\xE5V[`\x01\x01a\x0E1V[P\x83\x85\x83\x7Fs^^\xB5\xAF\xDDr\xCCde}\xED~]\xE3\x90\xAF7\x08\xAF\xB5\xB9\xA8\x0B\x0E\\\x91\x1A\x04\x99\xD9\x8F`@Q`@Q\x80\x91\x03\x90\xA4PPPPPPPPPPPV[```\x03\x80Ta\x05^\x90a*qV[a\t\x923\x83\x83a\x14\xD3V[``a\x05I`\x0F\x83a\x15\xA0V[a\x0E\xE23\x83a\x10 V[a\x0E\xFEW`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x06F\x90a*\xA9V[a\x0F\n\x84\x84\x84\x84a\x16UV[PPPPV[_\x81\x81R`\x13` R`@\x90 T``\x90a\x05I\x90`\x0F\x90a\x15\xA0V[``a\x05I\x82a\x16\x88V[_\x81\x81R`\x01` R`@\x81 a\x05I\x90a\x17\xE4V[_\x82\x81R` \x81\x90R`@\x90 `\x01\x01Ta\x0Fi\x813a\x12\xAEV[a\x07y\x83\x83a\x14UV[_`\x01`\x01`\xE0\x1B\x03\x19\x82\x16cx\x0E\x9Dc`\xE0\x1B\x14\x80a\x05IWPa\x05I\x82a\x17\xEDV[_\x90\x81R`\x04` R`@\x90 T`\x01`\x01`\xA0\x1B\x03\x16\x15\x15\x90V[_\x81\x81R`\x06` R`@\x90 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x84\x16\x90\x81\x17\x90\x91U\x81\x90a\x0F\xE7\x82a\x0B\xFAV[`\x01`\x01`\xA0\x1B\x03\x16\x7F\x8C[\xE1\xE5\xEB\xEC}[\xD1OqB}\x1E\x84\xF3\xDD\x03\x14\xC0\xF7\xB2)\x1E[ \n\xC8\xC7\xC3\xB9%`@Q`@Q\x80\x91\x03\x90\xA4PPV[_a\x10*\x82a\x0F\x97V[a\x10\x8BW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`,`$\x82\x01R\x7FERC721: operator query for nonex`D\x82\x01Rk4\xB9\xBA2\xB7:\x10:7\xB5\xB2\xB7`\xA1\x1B`d\x82\x01R`\x84\x01a\x06FV[_a\x10\x95\x83a\x0B\xFAV[\x90P\x80`\x01`\x01`\xA0\x1B\x03\x16\x84`\x01`\x01`\xA0\x1B\x03\x16\x14\x80a\x10\xD0WP\x83`\x01`\x01`\xA0\x1B\x03\x16a\x10\xC5\x84a\x05\xDFV[`\x01`\x01`\xA0\x1B\x03\x16\x14[\x80a\x10\xFFWP`\x01`\x01`\xA0\x1B\x03\x80\x82\x16_\x90\x81R`\x07` \x90\x81R`@\x80\x83 \x93\x88\x16\x83R\x92\x90R T`\xFF\x16[\x94\x93PPPPV[\x82`\x01`\x01`\xA0\x1B\x03\x16a\x11\x1A\x82a\x0B\xFAV[`\x01`\x01`\xA0\x1B\x03\x16\x14a\x11\x82W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`)`$\x82\x01R\x7FERC721: transfer of token that i`D\x82\x01Rh9\x9077\xBA\x107\xBB\xB7`\xB9\x1B`d\x82\x01R`\x84\x01a\x06FV[`\x01`\x01`\xA0\x1B\x03\x82\x16a\x11\xE4W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`$\x80\x82\x01R\x7FERC721: transfer to the zero add`D\x82\x01Rcress`\xE0\x1B`d\x82\x01R`\x84\x01a\x06FV[a\x11\xEF\x83\x83\x83a\x18,V[a\x11\xF9_\x82a\x0F\xB3V[`\x01`\x01`\xA0\x1B\x03\x83\x16_\x90\x81R`\x05` R`@\x81 \x80T`\x01\x92\x90a\x12!\x90\x84\x90a,\xA6V[\x90\x91UPP`\x01`\x01`\xA0\x1B\x03\x82\x16_\x90\x81R`\x05` R`@\x81 \x80T`\x01\x92\x90a\x12N\x90\x84\x90a,\xB9V[\x90\x91UPP_\x81\x81R`\x04` R`@\x80\x82 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x86\x81\x16\x91\x82\x17\x90\x92U\x91Q\x84\x93\x91\x87\x16\x91\x7F\xDD\xF2R\xAD\x1B\xE2\xC8\x9Bi\xC2\xB0h\xFC7\x8D\xAA\x95+\xA7\xF1c\xC4\xA1\x16(\xF5ZM\xF5#\xB3\xEF\x91\xA4PPPV[a\x12\xB8\x82\x82a\r\x13V[a\t\x92Wa\x12\xD0\x81`\x01`\x01`\xA0\x1B\x03\x16`\x14a\x187V[a\x12\xDB\x83` a\x187V[`@Q` \x01a\x12\xEC\x92\x91\x90a,\xCCV[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90RbF\x1B\xCD`\xE5\x1B\x82Ra\x06F\x91`\x04\x01a&\x11V[_a\x13\x1D\x83\x83a\x19\xCCV[a\x13\xB4W\x82T`\x01\x81\x01\x84U_\x84\x81R` \x90 \x01a\x13<\x83\x82a+\xAFV[P\x82T`@Q`\x01\x85\x01\x90a\x13R\x90\x85\x90a-!V[\x90\x81R` \x01`@Q\x80\x91\x03\x90 \x81\x90UP\x82`\x01\x01\x82`@Qa\x13v\x91\x90a-!V[\x90\x81R`@Q\x90\x81\x90\x03` \x01\x81 T\x90\x7F\x11Iz\x83IQ\tTi\x93\x0E\xC6.\x16A\xF0\xDC\xF3a}\x9C\xD7W\x9Bm\xA7nT\xDF0\0\xA7\x90_\x90\xA2P`\x01a\x05IV[P_a\x05IV[_\x82`\x01\x01\x82`@Qa\x13\xCE\x91\x90a-!V[\x90\x81R` \x01`@Q\x80\x91\x03\x90 T\x90P\x92\x91PPV[_a\x13\xEF`\x0BT\x90V[\x90Pa\x13\xFB\x86\x82a\x19\xF8V[_\x81\x81R`\x11` \x90\x81R`@\x80\x83 \x88\x90U`\x12\x82R\x80\x83 \x87\x90U`\x13\x90\x91R\x90 \x83\x90Ua\x14,\x81\x83a\x1B4V[PPPPPPV[a\x14>\x82\x82a\x1B\xB7V[_\x82\x81R`\x01` R`@\x90 a\x07y\x90\x82a\x1C:V[a\x14_\x82\x82a\x1CNV[_\x82\x81R`\x01` R`@\x90 a\x07y\x90\x82a\x1C\xB2V[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x84\x16`$\x82\x01R`D\x80\x82\x01\x84\x90R\x82Q\x80\x83\x03\x90\x91\x01\x81R`d\x90\x91\x01\x90\x91R` \x81\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16c\xA9\x05\x9C\xBB`\xE0\x1B\x17\x90Ra\x07y\x90\x84\x90a\x1C\xC6V[_a\r\x0C\x83\x83a\x1D\x97V[\x81`\x01`\x01`\xA0\x1B\x03\x16\x83`\x01`\x01`\xA0\x1B\x03\x16\x03a\x154W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x19`$\x82\x01R\x7FERC721: approve to caller\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06FV[`\x01`\x01`\xA0\x1B\x03\x83\x81\x16_\x81\x81R`\x07` \x90\x81R`@\x80\x83 \x94\x87\x16\x80\x84R\x94\x82R\x91\x82\x90 \x80T`\xFF\x19\x16\x86\x15\x15\x90\x81\x17\x90\x91U\x91Q\x91\x82R\x7F\x170~\xAB9\xABa\x07\xE8\x89\x98E\xAD=Y\xBD\x96S\xF2\0\xF2 \x92\x04\x89\xCA+Y7il1\x91\x01`@Q\x80\x91\x03\x90\xA3PPPV[``\x82a\x15\xAE`\x01\x84a,\xA6V[\x81T\x81\x10a\x15\xBEWa\x15\xBEa+9V[\x90_R` _ \x01\x80Ta\x15\xD1\x90a*qV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x15\xFD\x90a*qV[\x80\x15a\x16HW\x80`\x1F\x10a\x16\x1FWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x16HV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x16+W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x90P\x92\x91PPV[a\x16`\x84\x84\x84a\x11\x07V[a\x16l\x84\x84\x84\x84a\x1D\xBDV[a\x0F\nW`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x06F\x90a-,V[``a\x16\x93\x82a\x0F\x97V[a\x16\xF9W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`1`$\x82\x01R\x7FERC721URIStorage: URI query for `D\x82\x01Rp77\xB72\xBC4\xB9\xBA2\xB7:\x10:7\xB5\xB2\xB7`y\x1B`d\x82\x01R`\x84\x01a\x06FV[_\x82\x81R`\x08` R`@\x81 \x80Ta\x17\x11\x90a*qV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x17=\x90a*qV[\x80\x15a\x17\x88W\x80`\x1F\x10a\x17_Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x17\x88V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x17kW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x90P_a\x17\x98a\x1E\xBAV[\x90P\x80Q_\x03a\x17\xA9WP\x92\x91PPV[\x81Q\x15a\x17\xDBW\x80\x82`@Q` \x01a\x17\xC3\x92\x91\x90a-~V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x92PPP\x91\x90PV[a\x10\xFF\x84a\x1E\xC9V[_a\x05I\x82T\x90V[_`\x01`\x01`\xE0\x1B\x03\x19\x82\x16c\x80\xACX\xCD`\xE0\x1B\x14\x80a\x18\x1DWP`\x01`\x01`\xE0\x1B\x03\x19\x82\x16c[^\x13\x9F`\xE0\x1B\x14[\x80a\x05IWPa\x05I\x82a\x1F\x90V[a\x07y\x83\x83\x83a\x1F\xB4V[``_a\x18E\x83`\x02a-\x92V[a\x18P\x90`\x02a,\xB9V[`\x01`\x01`@\x1B\x03\x81\x11\x15a\x18gWa\x18ga&\xB7V[`@Q\x90\x80\x82R\x80`\x1F\x01`\x1F\x19\x16` \x01\x82\x01`@R\x80\x15a\x18\x91W` \x82\x01\x81\x806\x837\x01\x90P[P\x90P`\x03`\xFC\x1B\x81_\x81Q\x81\x10a\x18\xABWa\x18\xABa+9V[` \x01\x01\x90`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x81_\x1A\x90SP`\x0F`\xFB\x1B\x81`\x01\x81Q\x81\x10a\x18\xD9Wa\x18\xD9a+9V[` \x01\x01\x90`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x81_\x1A\x90SP_a\x18\xFB\x84`\x02a-\x92V[a\x19\x06\x90`\x01a,\xB9V[\x90P[`\x01\x81\x11\x15a\x19}Wo\x18\x18\x99\x19\x9A\x1A\x9B\x1B\x9C\x1C\xB0\xB11\xB22\xB3`\x81\x1B\x85`\x0F\x16`\x10\x81\x10a\x19:Wa\x19:a+9V[\x1A`\xF8\x1B\x82\x82\x81Q\x81\x10a\x19PWa\x19Pa+9V[` \x01\x01\x90`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x81_\x1A\x90SP`\x04\x94\x90\x94\x1C\x93a\x19v\x81a-\xA9V[\x90Pa\x19\tV[P\x83\x15a\r\x0CW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7FStrings: hex length insufficient`D\x82\x01R`d\x01a\x06FV[_\x82`\x01\x01\x82`@Qa\x19\xDF\x91\x90a-!V[\x90\x81R`@Q\x90\x81\x90\x03` \x01\x90 T\x15\x15\x93\x92PPPV[`\x01`\x01`\xA0\x1B\x03\x82\x16a\x1ANW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7FERC721: mint to the zero address`D\x82\x01R`d\x01a\x06FV[a\x1AW\x81a\x0F\x97V[\x15a\x1A\xA4W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7FERC721: token already minted\0\0\0\0`D\x82\x01R`d\x01a\x06FV[a\x1A\xAF_\x83\x83a\x18,V[`\x01`\x01`\xA0\x1B\x03\x82\x16_\x90\x81R`\x05` R`@\x81 \x80T`\x01\x92\x90a\x1A\xD7\x90\x84\x90a,\xB9V[\x90\x91UPP_\x81\x81R`\x04` R`@\x80\x82 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x86\x16\x90\x81\x17\x90\x91U\x90Q\x83\x92\x90\x7F\xDD\xF2R\xAD\x1B\xE2\xC8\x9Bi\xC2\xB0h\xFC7\x8D\xAA\x95+\xA7\xF1c\xC4\xA1\x16(\xF5ZM\xF5#\xB3\xEF\x90\x82\x90\xA4PPV[a\x1B=\x82a\x0F\x97V[a\x1B\xA0W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`.`$\x82\x01R\x7FERC721URIStorage: URI set of non`D\x82\x01Rm2\xBC4\xB9\xBA2\xB7:\x10:7\xB5\xB2\xB7`\x91\x1B`d\x82\x01R`\x84\x01a\x06FV[_\x82\x81R`\x08` R`@\x90 a\x07y\x82\x82a+\xAFV[a\x1B\xC1\x82\x82a\r\x13V[a\t\x92W_\x82\x81R` \x81\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x85\x16\x84R\x90\x91R\x90 \x80T`\xFF\x19\x16`\x01\x17\x90Ua\x1B\xF63\x90V[`\x01`\x01`\xA0\x1B\x03\x16\x81`\x01`\x01`\xA0\x1B\x03\x16\x83\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r`@Q`@Q\x80\x91\x03\x90\xA4PPV[_a\r\x0C\x83`\x01`\x01`\xA0\x1B\x03\x84\x16a kV[a\x1CX\x82\x82a\r\x13V[\x15a\t\x92W_\x82\x81R` \x81\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x85\x16\x80\x85R\x92R\x80\x83 \x80T`\xFF\x19\x16\x90UQ3\x92\x85\x91\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B\x91\x90\xA4PPV[_a\r\x0C\x83`\x01`\x01`\xA0\x1B\x03\x84\x16a \xB0V[_a\x1D\x1A\x82`@Q\x80`@\x01`@R\x80` \x81R` \x01\x7FSafeERC20: low-level call failed\x81RP\x85`\x01`\x01`\xA0\x1B\x03\x16a!\x93\x90\x92\x91\x90c\xFF\xFF\xFF\xFF\x16V[\x80Q\x90\x91P\x15a\x07yW\x80\x80` \x01\x90Q\x81\x01\x90a\x1D8\x91\x90a-\xBEV[a\x07yW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`*`$\x82\x01R\x7FSafeERC20: ERC20 operation did n`D\x82\x01Ri\x1B\xDD\x08\x1C\xDDX\xD8\xD9YY`\xB2\x1B`d\x82\x01R`\x84\x01a\x06FV[_\x82_\x01\x82\x81T\x81\x10a\x1D\xACWa\x1D\xACa+9V[\x90_R` _ \x01T\x90P\x92\x91PPV[_`\x01`\x01`\xA0\x1B\x03\x84\x16;\x15a\x1E\xAFW`@Qc\n\x85\xBD\x01`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x85\x16\x90c\x15\x0Bz\x02\x90a\x1E\0\x903\x90\x89\x90\x88\x90\x88\x90`\x04\x01a-\xD9V[` `@Q\x80\x83\x03\x81_\x87Z\xF1\x92PPP\x80\x15a\x1E:WP`@\x80Q`\x1F=\x90\x81\x01`\x1F\x19\x16\x82\x01\x90\x92Ra\x1E7\x91\x81\x01\x90a.\x15V[`\x01[a\x1E\x95W=\x80\x80\x15a\x1EgW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\x1ElV[``\x91P[P\x80Q_\x03a\x1E\x8DW`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x06F\x90a-,V[\x80Q\x81` \x01\xFD[`\x01`\x01`\xE0\x1B\x03\x19\x16c\n\x85\xBD\x01`\xE1\x1B\x14\x90Pa\x10\xFFV[P`\x01\x94\x93PPPPV[```\x0E\x80Ta\x05^\x90a*qV[``a\x1E\xD4\x82a\x0F\x97V[a\x1F8W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`/`$\x82\x01R\x7FERC721Metadata: URI query for no`D\x82\x01Rn72\xBC4\xB9\xBA2\xB7:\x10:7\xB5\xB2\xB7`\x89\x1B`d\x82\x01R`\x84\x01a\x06FV[_a\x1FAa\x1E\xBAV[\x90P_\x81Q\x11a\x1F_W`@Q\x80` \x01`@R\x80_\x81RPa\r\x0CV[\x80a\x1Fi\x84a!\xA1V[`@Q` \x01a\x1Fz\x92\x91\x90a-~V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x93\x92PPPV[_`\x01`\x01`\xE0\x1B\x03\x19\x82\x16cZ\x05\x18\x0F`\xE0\x1B\x14\x80a\x05IWPa\x05I\x82a\"\x9DV[`\x01`\x01`\xA0\x1B\x03\x83\x16a \x0EWa \t\x81`\x0B\x80T_\x83\x81R`\x0C` R`@\x81 \x82\x90U`\x01\x82\x01\x83U\x91\x90\x91R\x7F\x01u\xB7\xA68Bw\x03\xF0\xDB\xE7\xBB\x9B\xBF\x98z%Qq{4\xE7\x9F3\xB5\xB1\0\x8D\x1F\xA0\x1D\xB9\x01UV[a 1V[\x81`\x01`\x01`\xA0\x1B\x03\x16\x83`\x01`\x01`\xA0\x1B\x03\x16\x14a 1Wa 1\x83\x82a\"\xD1V[`\x01`\x01`\xA0\x1B\x03\x82\x16a HWa\x07y\x81a#jV[\x82`\x01`\x01`\xA0\x1B\x03\x16\x82`\x01`\x01`\xA0\x1B\x03\x16\x14a\x07yWa\x07y\x82\x82a$\x11V[_\x81\x81R`\x01\x83\x01` R`@\x81 Ta\x13\xB4WP\x81T`\x01\x81\x81\x01\x84U_\x84\x81R` \x80\x82 \x90\x93\x01\x84\x90U\x84T\x84\x82R\x82\x86\x01\x90\x93R`@\x90 \x91\x90\x91Ua\x05IV[_\x81\x81R`\x01\x83\x01` R`@\x81 T\x80\x15a!\x8AW_a \xD2`\x01\x83a,\xA6V[\x85T\x90\x91P_\x90a \xE5\x90`\x01\x90a,\xA6V[\x90P\x81\x81\x14a!DW_\x86_\x01\x82\x81T\x81\x10a!\x03Wa!\x03a+9V[\x90_R` _ \x01T\x90P\x80\x87_\x01\x84\x81T\x81\x10a!#Wa!#a+9V[_\x91\x82R` \x80\x83 \x90\x91\x01\x92\x90\x92U\x91\x82R`\x01\x88\x01\x90R`@\x90 \x83\x90U[\x85T\x86\x90\x80a!UWa!Ua.0V[`\x01\x90\x03\x81\x81\x90_R` _ \x01_\x90U\x90U\x85`\x01\x01_\x86\x81R` \x01\x90\x81R` \x01_ _\x90U`\x01\x93PPPPa\x05IV[_\x91PPa\x05IV[``a\x10\xFF\x84\x84_\x85a$SV[``\x81_\x03a!\xC7WPP`@\x80Q\x80\x82\x01\x90\x91R`\x01\x81R`\x03`\xFC\x1B` \x82\x01R\x90V[\x81_[\x81\x15a!\xF0W\x80a!\xDA\x81a.DV[\x91Pa!\xE9\x90P`\n\x83a.pV[\x91Pa!\xCAV[_\x81`\x01`\x01`@\x1B\x03\x81\x11\x15a\"\tWa\"\ta&\xB7V[`@Q\x90\x80\x82R\x80`\x1F\x01`\x1F\x19\x16` \x01\x82\x01`@R\x80\x15a\"3W` \x82\x01\x81\x806\x837\x01\x90P[P\x90P[\x84\x15a\x10\xFFWa\"H`\x01\x83a,\xA6V[\x91Pa\"U`\n\x86a.\x83V[a\"`\x90`0a,\xB9V[`\xF8\x1B\x81\x83\x81Q\x81\x10a\"uWa\"ua+9V[` \x01\x01\x90`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x81_\x1A\x90SPa\"\x96`\n\x86a.pV[\x94Pa\"7V[_`\x01`\x01`\xE0\x1B\x03\x19\x82\x16cye\xDB\x0B`\xE0\x1B\x14\x80a\x05IWPc\x01\xFF\xC9\xA7`\xE0\x1B`\x01`\x01`\xE0\x1B\x03\x19\x83\x16\x14a\x05IV[_`\x01a\"\xDD\x84a\x0CpV[a\"\xE7\x91\x90a,\xA6V[_\x83\x81R`\n` R`@\x90 T\x90\x91P\x80\x82\x14a#8W`\x01`\x01`\xA0\x1B\x03\x84\x16_\x90\x81R`\t` \x90\x81R`@\x80\x83 \x85\x84R\x82R\x80\x83 T\x84\x84R\x81\x84 \x81\x90U\x83R`\n\x90\x91R\x90 \x81\x90U[P_\x91\x82R`\n` \x90\x81R`@\x80\x84 \x84\x90U`\x01`\x01`\xA0\x1B\x03\x90\x94\x16\x83R`\t\x81R\x83\x83 \x91\x83RR\x90\x81 UV[`\x0BT_\x90a#{\x90`\x01\x90a,\xA6V[_\x83\x81R`\x0C` R`@\x81 T`\x0B\x80T\x93\x94P\x90\x92\x84\x90\x81\x10a#\xA2Wa#\xA2a+9V[\x90_R` _ \x01T\x90P\x80`\x0B\x83\x81T\x81\x10a#\xC1Wa#\xC1a+9V[_\x91\x82R` \x80\x83 \x90\x91\x01\x92\x90\x92U\x82\x81R`\x0C\x90\x91R`@\x80\x82 \x84\x90U\x85\x82R\x81 U`\x0B\x80T\x80a#\xF8Wa#\xF8a.0V[`\x01\x90\x03\x81\x81\x90_R` _ \x01_\x90U\x90UPPPPV[_a$\x1B\x83a\x0CpV[`\x01`\x01`\xA0\x1B\x03\x90\x93\x16_\x90\x81R`\t` \x90\x81R`@\x80\x83 \x86\x84R\x82R\x80\x83 \x85\x90U\x93\x82R`\n\x90R\x91\x90\x91 \x91\x90\x91UPV[``\x82G\x10\x15a$\xB4W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FAddress: insufficient balance fo`D\x82\x01Re\x1C\x88\x18\xD8[\x1B`\xD2\x1B`d\x82\x01R`\x84\x01a\x06FV[\x84;a%\x02W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1D`$\x82\x01R\x7FAddress: call to non-contract\0\0\0`D\x82\x01R`d\x01a\x06FV[__\x86`\x01`\x01`\xA0\x1B\x03\x16\x85\x87`@Qa%\x1D\x91\x90a-!V[_`@Q\x80\x83\x03\x81\x85\x87Z\xF1\x92PPP=\x80_\x81\x14a%WW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a%\\V[``\x91P[P\x91P\x91Pa%l\x82\x82\x86a%wV[\x97\x96PPPPPPPV[``\x83\x15a%\x86WP\x81a\r\x0CV[\x82Q\x15a%\x96W\x82Q\x80\x84` \x01\xFD[\x81`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x06F\x91\x90a&\x11V[`\x01`\x01`\xE0\x1B\x03\x19\x81\x16\x81\x14a%\xC5W__\xFD[PV[_` \x82\x84\x03\x12\x15a%\xD8W__\xFD[\x815a\r\x0C\x81a%\xB0V[_\x81Q\x80\x84R\x80` \x84\x01` \x86\x01^_` \x82\x86\x01\x01R` `\x1F\x19`\x1F\x83\x01\x16\x85\x01\x01\x91PP\x92\x91PPV[` \x81R_a\r\x0C` \x83\x01\x84a%\xE3V[_` \x82\x84\x03\x12\x15a&3W__\xFD[P5\x91\x90PV[\x805`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a&PW__\xFD[\x91\x90PV[__`@\x83\x85\x03\x12\x15a&fW__\xFD[a&o\x83a&:V[\x94` \x93\x90\x93\x015\x93PPPV[___``\x84\x86\x03\x12\x15a&\x8FW__\xFD[a&\x98\x84a&:V[\x92Pa&\xA6` \x85\x01a&:V[\x92\x95\x92\x94PPP`@\x91\x90\x91\x015\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[__`\x01`\x01`@\x1B\x03\x84\x11\x15a&\xE4Wa&\xE4a&\xB7V[P`@Q`\x1F\x19`\x1F\x85\x01\x81\x16`?\x01\x16\x81\x01\x81\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17\x15a'\x12Wa'\x12a&\xB7V[`@R\x83\x81R\x90P\x80\x82\x84\x01\x85\x10\x15a')W__\xFD[\x83\x83` \x83\x017_` \x85\x83\x01\x01RP\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a'OW__\xFD[a\r\x0C\x83\x835` \x85\x01a&\xCBV[_____`\xA0\x86\x88\x03\x12\x15a'rW__\xFD[a'{\x86a&:V[\x94P` \x86\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a'\x95W__\xFD[a'\xA1\x88\x82\x89\x01a'@V[\x94PP`@\x86\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a'\xBCW__\xFD[a'\xC8\x88\x82\x89\x01a'@V[\x95\x98\x94\x97P\x94\x95``\x81\x015\x95P`\x80\x015\x93\x92PPPV[__`@\x83\x85\x03\x12\x15a'\xF2W__\xFD[\x825\x91Pa(\x02` \x84\x01a&:V[\x90P\x92P\x92\x90PV[_` \x82\x84\x03\x12\x15a(\x1BW__\xFD[a\r\x0C\x82a&:V[__`@\x83\x85\x03\x12\x15a(5W__\xFD[PP\x805\x92` \x90\x91\x015\x91PV[_` \x82\x84\x03\x12\x15a(TW__\xFD[\x815`\x01`\x01`@\x1B\x03\x81\x11\x15a(iW__\xFD[a\x10\xFF\x84\x82\x85\x01a'@V[__\x83`\x1F\x84\x01\x12a(\x85W__\xFD[P\x815`\x01`\x01`@\x1B\x03\x81\x11\x15a(\x9BW__\xFD[` \x83\x01\x91P\x83` \x82\x85\x01\x01\x11\x15a(\xB2W__\xFD[\x92P\x92\x90PV[________`\xA0\x89\x8B\x03\x12\x15a(\xD0W__\xFD[\x885`\x01`\x01`@\x1B\x03\x81\x11\x15a(\xE5W__\xFD[\x89\x01`\x1F\x81\x01\x8B\x13a(\xF5W__\xFD[\x805`\x01`\x01`@\x1B\x03\x81\x11\x15a)\nW__\xFD[\x8B` \x82`\x05\x1B\x84\x01\x01\x11\x15a)\x1EW__\xFD[` \x91\x82\x01\x99P\x97P\x89\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a)=W__\xFD[a)I\x8B\x82\x8C\x01a(uV[\x90\x97P\x95PP`@\x89\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a)gW__\xFD[a)s\x8B\x82\x8C\x01a(uV[\x99\x9C\x98\x9BP\x96\x99\x95\x98\x96\x97``\x87\x015\x96`\x80\x015\x95P\x93PPPPV[\x80\x15\x15\x81\x14a%\xC5W__\xFD[__`@\x83\x85\x03\x12\x15a)\xAFW__\xFD[a)\xB8\x83a&:V[\x91P` \x83\x015a)\xC8\x81a)\x91V[\x80\x91PP\x92P\x92\x90PV[____`\x80\x85\x87\x03\x12\x15a)\xE6W__\xFD[a)\xEF\x85a&:V[\x93Pa)\xFD` \x86\x01a&:V[\x92P`@\x85\x015\x91P``\x85\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a*\x1EW__\xFD[\x85\x01`\x1F\x81\x01\x87\x13a*.W__\xFD[a*=\x87\x825` \x84\x01a&\xCBV[\x91PP\x92\x95\x91\x94P\x92PV[__`@\x83\x85\x03\x12\x15a*ZW__\xFD[a*c\x83a&:V[\x91Pa(\x02` \x84\x01a&:V[`\x01\x81\x81\x1C\x90\x82\x16\x80a*\x85W`\x7F\x82\x16\x91P[` \x82\x10\x81\x03a*\xA3WcNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[P\x91\x90PV[` \x80\x82R`1\x90\x82\x01R\x7FERC721: transfer caller is not o`@\x82\x01Rp\x1D\xDB\x99\\\x88\x1B\x9B\xDC\x88\x18\\\x1C\x1C\x9B\xDD\x99Y`z\x1B``\x82\x01R`\x80\x01\x90V[_\x81Q\x80` \x84\x01\x85^_\x93\x01\x92\x83RP\x90\x91\x90PV[_a+\x1C\x82\x85a*\xFAV[`/`\xF8\x1B\x81Ra+0`\x01\x82\x01\x85a*\xFAV[\x95\x94PPPPPV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[_` \x82\x84\x03\x12\x15a+]W__\xFD[PQ\x91\x90PV[`\x1F\x82\x11\x15a\x07yW\x80_R` _ `\x1F\x84\x01`\x05\x1C\x81\x01` \x85\x10\x15a+\x89WP\x80[`\x1F\x84\x01`\x05\x1C\x82\x01\x91P[\x81\x81\x10\x15a+\xA8W_\x81U`\x01\x01a+\x95V[PPPPPV[\x81Q`\x01`\x01`@\x1B\x03\x81\x11\x15a+\xC8Wa+\xC8a&\xB7V[a+\xDC\x81a+\xD6\x84Ta*qV[\x84a+dV[` `\x1F\x82\x11`\x01\x81\x14a,\x0EW_\x83\x15a+\xF7WP\x84\x82\x01Q[_\x19`\x03\x85\x90\x1B\x1C\x19\x16`\x01\x84\x90\x1B\x17\x84Ua+\xA8V[_\x84\x81R` \x81 `\x1F\x19\x85\x16\x91[\x82\x81\x10\x15a,=W\x87\x85\x01Q\x82U` \x94\x85\x01\x94`\x01\x90\x92\x01\x91\x01a,\x1DV[P\x84\x82\x10\x15a,ZW\x86\x84\x01Q_\x19`\x03\x87\x90\x1B`\xF8\x16\x1C\x19\x16\x81U[PPPP`\x01\x90\x81\x1B\x01\x90UPV[\x83\x85\x827_\x84\x82\x01`/`\xF8\x1B\x81R\x83\x85`\x01\x83\x017_\x93\x01`\x01\x01\x92\x83RP\x90\x94\x93PPPPV[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[\x81\x81\x03\x81\x81\x11\x15a\x05IWa\x05Ia,\x92V[\x80\x82\x01\x80\x82\x11\x15a\x05IWa\x05Ia,\x92V[\x7FAccessControl: account \0\0\0\0\0\0\0\0\0\x81R_a,\xFD`\x17\x83\x01\x85a*\xFAV[p\x01\x03K\x99\x03kK\x9B\x9BKs9\x03\x93{c)`}\x1B\x81Ra+0`\x11\x82\x01\x85a*\xFAV[_a\r\x0C\x82\x84a*\xFAV[` \x80\x82R`2\x90\x82\x01R\x7FERC721: transfer to non ERC721Re`@\x82\x01Rq1\xB2\xB4\xBB2\xB9\x104\xB6\xB862\xB6\xB2\xB7:2\xB9`q\x1B``\x82\x01R`\x80\x01\x90V[_a\x10\xFFa-\x8C\x83\x86a*\xFAV[\x84a*\xFAV[\x80\x82\x02\x81\x15\x82\x82\x04\x84\x14\x17a\x05IWa\x05Ia,\x92V[_\x81a-\xB7Wa-\xB7a,\x92V[P_\x19\x01\x90V[_` \x82\x84\x03\x12\x15a-\xCEW__\xFD[\x81Qa\r\x0C\x81a)\x91V[`\x01`\x01`\xA0\x1B\x03\x85\x81\x16\x82R\x84\x16` \x82\x01R`@\x81\x01\x83\x90R`\x80``\x82\x01\x81\x90R_\x90a.\x0B\x90\x83\x01\x84a%\xE3V[\x96\x95PPPPPPV[_` \x82\x84\x03\x12\x15a.%W__\xFD[\x81Qa\r\x0C\x81a%\xB0V[cNH{q`\xE0\x1B_R`1`\x04R`$_\xFD[_`\x01\x82\x01a.UWa.Ua,\x92V[P`\x01\x01\x90V[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[_\x82a.~Wa.~a.\\V[P\x04\x90V[_\x82a.\x91Wa.\x91a.\\V[P\x06\x90V\xFE\xA2dipfsX\"\x12 \x12\x8DI\xEB-4J\x9E)\x14\xC0\x81e\x1A;-\x19R\xCB\xD7-e\xFE\x8C\xCB~l~\xDD?\xC3\x12dsolcC\0\x08\x1E\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561000f575f5ffd5b50600436106101fd575f3560e01c806370a0823111610114578063a22cb465116100a9578063c87b56dd11610079578063c87b56dd1461048a578063ca15c8731461049d578063d5391393146104b0578063d547741f146104d7578063e985e9c5146104ea575f5ffd5b8063a22cb4651461043e578063b5185a8814610451578063b88d4fde14610464578063c588ff8b14610477575f5ffd5b8063931688cb116100e4578063931688cb146104095780639365c5331461041c57806395d89b411461042f578063a217fddf14610437575f5ffd5b806370a082311461038f578063896cddf4146103a25780639010d07c146103e357806391d14854146103f6575f5ffd5b80632f2ff15d1161019557806348c64e411161016557806348c64e41146103245780634f6ccce714610337578063562317c51461034a5780636067bc15146103695780636352211e1461037c575f5ffd5b80632f2ff15d146102d85780632f745c59146102eb57806336568abe146102fe57806342842e0e14610311575f5ffd5b806318160ddd116101d057806318160ddd1461027e57806323b872dd14610290578063248a9ca3146102a357806329867dac146102c5575f5ffd5b806301ffc9a71461020157806306fdde0314610229578063081812fc1461023e578063095ea7b314610269575b5f5ffd5b61021461020f3660046125c8565b610525565b60405190151581526020015b60405180910390f35b61023161054f565b6040516102209190612611565b61025161024c366004612623565b6105df565b6040516001600160a01b039091168152602001610220565b61027c610277366004612655565b61066a565b005b600b545b604051908152602001610220565b61027c61029e36600461267d565b61077e565b6102826102b1366004612623565b5f9081526020819052604090206001015490565b61027c6102d336600461275e565b6107af565b61027c6102e63660046127e1565b61085f565b6102826102f9366004612655565b610884565b61027c61030c3660046127e1565b610918565b61027c61031f36600461267d565b610996565b61027c610332366004612655565b6109b0565b610282610345366004612623565b610a84565b610282610358366004612623565b5f9081526013602052604090205490565b61027c61037736600461280b565b610b14565b61025161038a366004612623565b610bfa565b61028261039d36600461280b565b610c70565b6103ce6103b0366004612623565b5f908152601160209081526040808320546012909252909120549091565b60408051928352602083019190915201610220565b6102516103f1366004612824565b610cf5565b6102146104043660046127e1565b610d13565b61027c610417366004612844565b610d3b565b61027c61042a3660046128b9565b610d52565b610231610eb1565b6102825f81565b61027c61044c36600461299e565b610ec0565b61023161045f366004612623565b610ecb565b61027c6104723660046129d3565b610ed8565b610231610485366004612623565b610f10565b610231610498366004612623565b610f2d565b6102826104ab366004612623565b610f38565b6102827f9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a681565b61027c6104e53660046127e1565b610f4e565b6102146104f8366004612a49565b6001600160a01b039182165f90815260076020908152604080832093909416825291909152205460ff1690565b5f6001600160e01b03198216630d639add60e11b1480610549575061054982610f73565b92915050565b60606002805461055e90612a71565b80601f016020809104026020016040519081016040528092919081815260200182805461058a90612a71565b80156105d55780601f106105ac576101008083540402835291602001916105d5565b820191905f5260205f20905b8154815290600101906020018083116105b857829003601f168201915b5050505050905090565b5f6105e982610f97565b61064f5760405162461bcd60e51b815260206004820152602c60248201527f4552433732313a20617070726f76656420717565727920666f72206e6f6e657860448201526b34b9ba32b73a103a37b5b2b760a11b60648201526084015b60405180910390fd5b505f908152600660205260409020546001600160a01b031690565b5f61067482610bfa565b9050806001600160a01b0316836001600160a01b0316036106e15760405162461bcd60e51b815260206004820152602160248201527f4552433732313a20617070726f76616c20746f2063757272656e74206f776e656044820152603960f91b6064820152608401610646565b336001600160a01b03821614806106fd57506106fd81336104f8565b61076f5760405162461bcd60e51b815260206004820152603860248201527f4552433732313a20617070726f76652063616c6c6572206973206e6f74206f7760448201527f6e6572206e6f7220617070726f76656420666f7220616c6c00000000000000006064820152608401610646565b6107798383610fb3565b505050565b6107883382611020565b6107a45760405162461bcd60e51b815260040161064690612aa9565b610779838383611107565b7f9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a66107da81336112ae565b6107e5600f86611312565b505f6107f2600f876113bb565b90505f8686604051602001610808929190612b11565b604051602081830303815290604052905061082688868685856113e5565b8385837f735e5eb5afdd72cc64657ded7e5de390af3708afb5b9a80b0e5c911a0499d98f60405160405180910390a45050505050505050565b5f8281526020819052604090206001015461087a81336112ae565b6107798383611434565b5f61088e83610c70565b82106108f05760405162461bcd60e51b815260206004820152602b60248201527f455243373231456e756d657261626c653a206f776e657220696e646578206f7560448201526a74206f6620626f756e647360a81b6064820152608401610646565b506001600160a01b03919091165f908152600960209081526040808320938352929052205490565b6001600160a01b03811633146109885760405162461bcd60e51b815260206004820152602f60248201527f416363657373436f6e74726f6c3a2063616e206f6e6c792072656e6f756e636560448201526e103937b632b9903337b91039b2b63360891b6064820152608401610646565b6109928282611455565b5050565b61077983838360405180602001604052805f815250610ed8565b5f6109bb81336112ae565b6002600d5403610a0d5760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152606401610646565b6002600d55604080516323b872dd60e01b81523060048201523360248201526044810184905290516001600160a01b038516916323b872dd916064808301925f92919082900301818387803b158015610a64575f5ffd5b505af1158015610a76573d5f5f3e3d5ffd5b50506001600d555050505050565b5f610a8e600b5490565b8210610af15760405162461bcd60e51b815260206004820152602c60248201527f455243373231456e756d657261626c653a20676c6f62616c20696e646578206f60448201526b7574206f6620626f756e647360a01b6064820152608401610646565b600b8281548110610b0457610b04612b39565b905f5260205f2001549050919050565b5f610b1f81336112ae565b6002600d5403610b715760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152606401610646565b6002600d55610bf1336040516370a0823160e01b81523060048201526001600160a01b038516906370a0823190602401602060405180830381865afa158015610bbc573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610be09190612b4d565b6001600160a01b0385169190611476565b50506001600d55565b5f818152600460205260408120546001600160a01b0316806105495760405162461bcd60e51b815260206004820152602960248201527f4552433732313a206f776e657220717565727920666f72206e6f6e657869737460448201526832b73a103a37b5b2b760b91b6064820152608401610646565b5f6001600160a01b038216610cda5760405162461bcd60e51b815260206004820152602a60248201527f4552433732313a2062616c616e636520717565727920666f7220746865207a65604482015269726f206164647265737360b01b6064820152608401610646565b506001600160a01b03165f9081526005602052604090205490565b5f828152600160205260408120610d0c90836114c8565b9392505050565b5f918252602082815260408084206001600160a01b0393909316845291905290205460ff1690565b5f610d4681336112ae565b600e6107798382612baf565b7f9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6610d7d81336112ae565b610dbf87878080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250600f939250506113129050565b505f610e0388888080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250600f939250506113bb9050565b90505f88888888604051602001610e1d9493929190612c69565b60408051601f1981840301815291905290505f5b8a811015610e7457610e6c8c8c83818110610e4e57610e4e612b39565b9050602002016020810190610e63919061280b565b878786866113e5565b600101610e31565b508385837f735e5eb5afdd72cc64657ded7e5de390af3708afb5b9a80b0e5c911a0499d98f60405160405180910390a45050505050505050505050565b60606003805461055e90612a71565b6109923383836114d3565b6060610549600f836115a0565b610ee23383611020565b610efe5760405162461bcd60e51b815260040161064690612aa9565b610f0a84848484611655565b50505050565b5f8181526013602052604090205460609061054990600f906115a0565b606061054982611688565b5f818152600160205260408120610549906117e4565b5f82815260208190526040902060010154610f6981336112ae565b6107798383611455565b5f6001600160e01b0319821663780e9d6360e01b14806105495750610549826117ed565b5f908152600460205260409020546001600160a01b0316151590565b5f81815260066020526040902080546001600160a01b0319166001600160a01b0384169081179091558190610fe782610bfa565b6001600160a01b03167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92560405160405180910390a45050565b5f61102a82610f97565b61108b5760405162461bcd60e51b815260206004820152602c60248201527f4552433732313a206f70657261746f7220717565727920666f72206e6f6e657860448201526b34b9ba32b73a103a37b5b2b760a11b6064820152608401610646565b5f61109583610bfa565b9050806001600160a01b0316846001600160a01b031614806110d05750836001600160a01b03166110c5846105df565b6001600160a01b0316145b806110ff57506001600160a01b038082165f9081526007602090815260408083209388168352929052205460ff165b949350505050565b826001600160a01b031661111a82610bfa565b6001600160a01b0316146111825760405162461bcd60e51b815260206004820152602960248201527f4552433732313a207472616e73666572206f6620746f6b656e2074686174206960448201526839903737ba1037bbb760b91b6064820152608401610646565b6001600160a01b0382166111e45760405162461bcd60e51b8152602060048201526024808201527f4552433732313a207472616e7366657220746f20746865207a65726f206164646044820152637265737360e01b6064820152608401610646565b6111ef83838361182c565b6111f95f82610fb3565b6001600160a01b0383165f908152600560205260408120805460019290611221908490612ca6565b90915550506001600160a01b0382165f90815260056020526040812080546001929061124e908490612cb9565b90915550505f8181526004602052604080822080546001600160a01b0319166001600160a01b0386811691821790925591518493918716917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef91a4505050565b6112b88282610d13565b610992576112d0816001600160a01b03166014611837565b6112db836020611837565b6040516020016112ec929190612ccc565b60408051601f198184030181529082905262461bcd60e51b825261064691600401612611565b5f61131d83836119cc565b6113b45782546001810184555f848152602090200161133c8382612baf565b5082546040516001850190611352908590612d21565b90815260200160405180910390208190555082600101826040516113769190612d21565b90815260405190819003602001812054907f11497a834951095469930ec62e1641f0dcf3617d9cd7579b6da76e54df3000a7905f90a2506001610549565b505f610549565b5f82600101826040516113ce9190612d21565b908152602001604051809103902054905092915050565b5f6113ef600b5490565b90506113fb86826119f8565b5f818152601160209081526040808320889055601282528083208790556013909152902083905561142c8183611b34565b505050505050565b61143e8282611bb7565b5f8281526001602052604090206107799082611c3a565b61145f8282611c4e565b5f8281526001602052604090206107799082611cb2565b604080516001600160a01b038416602482015260448082018490528251808303909101815260649091019091526020810180516001600160e01b031663a9059cbb60e01b179052610779908490611cc6565b5f610d0c8383611d97565b816001600160a01b0316836001600160a01b0316036115345760405162461bcd60e51b815260206004820152601960248201527f4552433732313a20617070726f766520746f2063616c6c6572000000000000006044820152606401610646565b6001600160a01b038381165f81815260076020908152604080832094871680845294825291829020805460ff191686151590811790915591519182527f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a3505050565b6060826115ae600184612ca6565b815481106115be576115be612b39565b905f5260205f200180546115d190612a71565b80601f01602080910402602001604051908101604052809291908181526020018280546115fd90612a71565b80156116485780601f1061161f57610100808354040283529160200191611648565b820191905f5260205f20905b81548152906001019060200180831161162b57829003601f168201915b5050505050905092915050565b611660848484611107565b61166c84848484611dbd565b610f0a5760405162461bcd60e51b815260040161064690612d2c565b606061169382610f97565b6116f95760405162461bcd60e51b815260206004820152603160248201527f45524337323155524953746f726167653a2055524920717565727920666f72206044820152703737b732bc34b9ba32b73a103a37b5b2b760791b6064820152608401610646565b5f828152600860205260408120805461171190612a71565b80601f016020809104026020016040519081016040528092919081815260200182805461173d90612a71565b80156117885780601f1061175f57610100808354040283529160200191611788565b820191905f5260205f20905b81548152906001019060200180831161176b57829003601f168201915b505050505090505f611798611eba565b905080515f036117a9575092915050565b8151156117db5780826040516020016117c3929190612d7e565b60405160208183030381529060405292505050919050565b6110ff84611ec9565b5f610549825490565b5f6001600160e01b031982166380ac58cd60e01b148061181d57506001600160e01b03198216635b5e139f60e01b145b80610549575061054982611f90565b610779838383611fb4565b60605f611845836002612d92565b611850906002612cb9565b6001600160401b03811115611867576118676126b7565b6040519080825280601f01601f191660200182016040528015611891576020820181803683370190505b509050600360fc1b815f815181106118ab576118ab612b39565b60200101906001600160f81b03191690815f1a905350600f60fb1b816001815181106118d9576118d9612b39565b60200101906001600160f81b03191690815f1a9053505f6118fb846002612d92565b611906906001612cb9565b90505b600181111561197d576f181899199a1a9b1b9c1cb0b131b232b360811b85600f166010811061193a5761193a612b39565b1a60f81b82828151811061195057611950612b39565b60200101906001600160f81b03191690815f1a90535060049490941c9361197681612da9565b9050611909565b508315610d0c5760405162461bcd60e51b815260206004820181905260248201527f537472696e67733a20686578206c656e67746820696e73756666696369656e746044820152606401610646565b5f82600101826040516119df9190612d21565b9081526040519081900360200190205415159392505050565b6001600160a01b038216611a4e5760405162461bcd60e51b815260206004820181905260248201527f4552433732313a206d696e7420746f20746865207a65726f20616464726573736044820152606401610646565b611a5781610f97565b15611aa45760405162461bcd60e51b815260206004820152601c60248201527f4552433732313a20746f6b656e20616c7265616479206d696e746564000000006044820152606401610646565b611aaf5f838361182c565b6001600160a01b0382165f908152600560205260408120805460019290611ad7908490612cb9565b90915550505f8181526004602052604080822080546001600160a01b0319166001600160a01b03861690811790915590518392907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef908290a45050565b611b3d82610f97565b611ba05760405162461bcd60e51b815260206004820152602e60248201527f45524337323155524953746f726167653a2055524920736574206f66206e6f6e60448201526d32bc34b9ba32b73a103a37b5b2b760911b6064820152608401610646565b5f8281526008602052604090206107798282612baf565b611bc18282610d13565b610992575f828152602081815260408083206001600160a01b03851684529091529020805460ff19166001179055611bf63390565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45050565b5f610d0c836001600160a01b03841661206b565b611c588282610d13565b15610992575f828152602081815260408083206001600160a01b0385168085529252808320805460ff1916905551339285917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a45050565b5f610d0c836001600160a01b0384166120b0565b5f611d1a826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166121939092919063ffffffff16565b8051909150156107795780806020019051810190611d389190612dbe565b6107795760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b6064820152608401610646565b5f825f018281548110611dac57611dac612b39565b905f5260205f200154905092915050565b5f6001600160a01b0384163b15611eaf57604051630a85bd0160e11b81526001600160a01b0385169063150b7a0290611e00903390899088908890600401612dd9565b6020604051808303815f875af1925050508015611e3a575060408051601f3d908101601f19168201909252611e3791810190612e15565b60015b611e95573d808015611e67576040519150601f19603f3d011682016040523d82523d5f602084013e611e6c565b606091505b5080515f03611e8d5760405162461bcd60e51b815260040161064690612d2c565b805181602001fd5b6001600160e01b031916630a85bd0160e11b1490506110ff565b506001949350505050565b6060600e805461055e90612a71565b6060611ed482610f97565b611f385760405162461bcd60e51b815260206004820152602f60248201527f4552433732314d657461646174613a2055524920717565727920666f72206e6f60448201526e3732bc34b9ba32b73a103a37b5b2b760891b6064820152608401610646565b5f611f41611eba565b90505f815111611f5f5760405180602001604052805f815250610d0c565b80611f69846121a1565b604051602001611f7a929190612d7e565b6040516020818303038152906040529392505050565b5f6001600160e01b03198216635a05180f60e01b148061054957506105498261229d565b6001600160a01b03831661200e5761200981600b80545f838152600c60205260408120829055600182018355919091527f0175b7a638427703f0dbe7bb9bbf987a2551717b34e79f33b5b1008d1fa01db90155565b612031565b816001600160a01b0316836001600160a01b0316146120315761203183826122d1565b6001600160a01b038216612048576107798161236a565b826001600160a01b0316826001600160a01b031614610779576107798282612411565b5f8181526001830160205260408120546113b457508154600181810184555f848152602080822090930184905584548482528286019093526040902091909155610549565b5f818152600183016020526040812054801561218a575f6120d2600183612ca6565b85549091505f906120e590600190612ca6565b9050818114612144575f865f01828154811061210357612103612b39565b905f5260205f200154905080875f01848154811061212357612123612b39565b5f918252602080832090910192909255918252600188019052604090208390555b855486908061215557612155612e30565b600190038181905f5260205f20015f90559055856001015f8681526020019081526020015f205f905560019350505050610549565b5f915050610549565b60606110ff84845f85612453565b6060815f036121c75750506040805180820190915260018152600360fc1b602082015290565b815f5b81156121f057806121da81612e44565b91506121e99050600a83612e70565b91506121ca565b5f816001600160401b03811115612209576122096126b7565b6040519080825280601f01601f191660200182016040528015612233576020820181803683370190505b5090505b84156110ff57612248600183612ca6565b9150612255600a86612e83565b612260906030612cb9565b60f81b81838151811061227557612275612b39565b60200101906001600160f81b03191690815f1a905350612296600a86612e70565b9450612237565b5f6001600160e01b03198216637965db0b60e01b148061054957506301ffc9a760e01b6001600160e01b0319831614610549565b5f60016122dd84610c70565b6122e79190612ca6565b5f838152600a6020526040902054909150808214612338576001600160a01b0384165f9081526009602090815260408083208584528252808320548484528184208190558352600a90915290208190555b505f918252600a602090815260408084208490556001600160a01b039094168352600981528383209183525290812055565b600b545f9061237b90600190612ca6565b5f838152600c6020526040812054600b80549394509092849081106123a2576123a2612b39565b905f5260205f200154905080600b83815481106123c1576123c1612b39565b5f918252602080832090910192909255828152600c9091526040808220849055858252812055600b8054806123f8576123f8612e30565b600190038181905f5260205f20015f9055905550505050565b5f61241b83610c70565b6001600160a01b039093165f9081526009602090815260408083208684528252808320859055938252600a9052919091209190915550565b6060824710156124b45760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b6064820152608401610646565b843b6125025760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610646565b5f5f866001600160a01b0316858760405161251d9190612d21565b5f6040518083038185875af1925050503d805f8114612557576040519150601f19603f3d011682016040523d82523d5f602084013e61255c565b606091505b509150915061256c828286612577565b979650505050505050565b60608315612586575081610d0c565b8251156125965782518084602001fd5b8160405162461bcd60e51b81526004016106469190612611565b6001600160e01b0319811681146125c5575f5ffd5b50565b5f602082840312156125d8575f5ffd5b8135610d0c816125b0565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b602081525f610d0c60208301846125e3565b5f60208284031215612633575f5ffd5b5035919050565b80356001600160a01b0381168114612650575f5ffd5b919050565b5f5f60408385031215612666575f5ffd5b61266f8361263a565b946020939093013593505050565b5f5f5f6060848603121561268f575f5ffd5b6126988461263a565b92506126a66020850161263a565b929592945050506040919091013590565b634e487b7160e01b5f52604160045260245ffd5b5f5f6001600160401b038411156126e4576126e46126b7565b50604051601f19601f85018116603f011681018181106001600160401b0382111715612712576127126126b7565b604052838152905080828401851015612729575f5ffd5b838360208301375f60208583010152509392505050565b5f82601f83011261274f575f5ffd5b610d0c838335602085016126cb565b5f5f5f5f5f60a08688031215612772575f5ffd5b61277b8661263a565b945060208601356001600160401b03811115612795575f5ffd5b6127a188828901612740565b94505060408601356001600160401b038111156127bc575f5ffd5b6127c888828901612740565b9598949750949560608101359550608001359392505050565b5f5f604083850312156127f2575f5ffd5b823591506128026020840161263a565b90509250929050565b5f6020828403121561281b575f5ffd5b610d0c8261263a565b5f5f60408385031215612835575f5ffd5b50508035926020909101359150565b5f60208284031215612854575f5ffd5b81356001600160401b03811115612869575f5ffd5b6110ff84828501612740565b5f5f83601f840112612885575f5ffd5b5081356001600160401b0381111561289b575f5ffd5b6020830191508360208285010111156128b2575f5ffd5b9250929050565b5f5f5f5f5f5f5f5f60a0898b0312156128d0575f5ffd5b88356001600160401b038111156128e5575f5ffd5b8901601f81018b136128f5575f5ffd5b80356001600160401b0381111561290a575f5ffd5b8b60208260051b840101111561291e575f5ffd5b6020918201995097508901356001600160401b0381111561293d575f5ffd5b6129498b828c01612875565b90975095505060408901356001600160401b03811115612967575f5ffd5b6129738b828c01612875565b999c989b509699959896976060870135966080013595509350505050565b80151581146125c5575f5ffd5b5f5f604083850312156129af575f5ffd5b6129b88361263a565b915060208301356129c881612991565b809150509250929050565b5f5f5f5f608085870312156129e6575f5ffd5b6129ef8561263a565b93506129fd6020860161263a565b92506040850135915060608501356001600160401b03811115612a1e575f5ffd5b8501601f81018713612a2e575f5ffd5b612a3d878235602084016126cb565b91505092959194509250565b5f5f60408385031215612a5a575f5ffd5b612a638361263a565b91506128026020840161263a565b600181811c90821680612a8557607f821691505b602082108103612aa357634e487b7160e01b5f52602260045260245ffd5b50919050565b60208082526031908201527f4552433732313a207472616e736665722063616c6c6572206973206e6f74206f6040820152701ddb995c881b9bdc88185c1c1c9bdd9959607a1b606082015260800190565b5f81518060208401855e5f93019283525090919050565b5f612b1c8285612afa565b602f60f81b8152612b306001820185612afa565b95945050505050565b634e487b7160e01b5f52603260045260245ffd5b5f60208284031215612b5d575f5ffd5b5051919050565b601f82111561077957805f5260205f20601f840160051c81016020851015612b895750805b601f840160051c820191505b81811015612ba8575f8155600101612b95565b5050505050565b81516001600160401b03811115612bc857612bc86126b7565b612bdc81612bd68454612a71565b84612b64565b6020601f821160018114612c0e575f8315612bf75750848201515b5f19600385901b1c1916600184901b178455612ba8565b5f84815260208120601f198516915b82811015612c3d5787850151825560209485019460019092019101612c1d565b5084821015612c5a57868401515f19600387901b60f8161c191681555b50505050600190811b01905550565b838582375f848201602f60f81b8152838560018301375f93016001019283525090949350505050565b634e487b7160e01b5f52601160045260245ffd5b8181038181111561054957610549612c92565b8082018082111561054957610549612c92565b7f416363657373436f6e74726f6c3a206163636f756e742000000000000000000081525f612cfd6017830185612afa565b7001034b99036b4b9b9b4b733903937b6329607d1b8152612b306011820185612afa565b5f610d0c8284612afa565b60208082526032908201527f4552433732313a207472616e7366657220746f206e6f6e20455243373231526560408201527131b2b4bb32b91034b6b83632b6b2b73a32b960711b606082015260800190565b5f6110ff612d8c8386612afa565b84612afa565b808202811582820484141761054957610549612c92565b5f81612db757612db7612c92565b505f190190565b5f60208284031215612dce575f5ffd5b8151610d0c81612991565b6001600160a01b03858116825284166020820152604081018390526080606082018190525f90612e0b908301846125e3565b9695505050505050565b5f60208284031215612e25575f5ffd5b8151610d0c816125b0565b634e487b7160e01b5f52603160045260245ffd5b5f60018201612e5557612e55612c92565b5060010190565b634e487b7160e01b5f52601260045260245ffd5b5f82612e7e57612e7e612e5c565b500490565b5f82612e9157612e91612e5c565b50069056fea2646970667358221220128d49eb2d344a9e2914c081651a3b2d1952cbd72d65fe8ccb7e6c7edd3fc31264736f6c634300081e0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\x01\xFDW_5`\xE0\x1C\x80cp\xA0\x821\x11a\x01\x14W\x80c\xA2,\xB4e\x11a\0\xA9W\x80c\xC8{V\xDD\x11a\0yW\x80c\xC8{V\xDD\x14a\x04\x8AW\x80c\xCA\x15\xC8s\x14a\x04\x9DW\x80c\xD59\x13\x93\x14a\x04\xB0W\x80c\xD5Gt\x1F\x14a\x04\xD7W\x80c\xE9\x85\xE9\xC5\x14a\x04\xEAW__\xFD[\x80c\xA2,\xB4e\x14a\x04>W\x80c\xB5\x18Z\x88\x14a\x04QW\x80c\xB8\x8DO\xDE\x14a\x04dW\x80c\xC5\x88\xFF\x8B\x14a\x04wW__\xFD[\x80c\x93\x16\x88\xCB\x11a\0\xE4W\x80c\x93\x16\x88\xCB\x14a\x04\tW\x80c\x93e\xC53\x14a\x04\x1CW\x80c\x95\xD8\x9BA\x14a\x04/W\x80c\xA2\x17\xFD\xDF\x14a\x047W__\xFD[\x80cp\xA0\x821\x14a\x03\x8FW\x80c\x89l\xDD\xF4\x14a\x03\xA2W\x80c\x90\x10\xD0|\x14a\x03\xE3W\x80c\x91\xD1HT\x14a\x03\xF6W__\xFD[\x80c//\xF1]\x11a\x01\x95W\x80cH\xC6NA\x11a\x01eW\x80cH\xC6NA\x14a\x03$W\x80cOl\xCC\xE7\x14a\x037W\x80cV#\x17\xC5\x14a\x03JW\x80c`g\xBC\x15\x14a\x03iW\x80ccR!\x1E\x14a\x03|W__\xFD[\x80c//\xF1]\x14a\x02\xD8W\x80c/t\\Y\x14a\x02\xEBW\x80c6V\x8A\xBE\x14a\x02\xFEW\x80cB\x84.\x0E\x14a\x03\x11W__\xFD[\x80c\x18\x16\r\xDD\x11a\x01\xD0W\x80c\x18\x16\r\xDD\x14a\x02~W\x80c#\xB8r\xDD\x14a\x02\x90W\x80c$\x8A\x9C\xA3\x14a\x02\xA3W\x80c)\x86}\xAC\x14a\x02\xC5W__\xFD[\x80c\x01\xFF\xC9\xA7\x14a\x02\x01W\x80c\x06\xFD\xDE\x03\x14a\x02)W\x80c\x08\x18\x12\xFC\x14a\x02>W\x80c\t^\xA7\xB3\x14a\x02iW[__\xFD[a\x02\x14a\x02\x0F6`\x04a%\xC8V[a\x05%V[`@Q\x90\x15\x15\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\x021a\x05OV[`@Qa\x02 \x91\x90a&\x11V[a\x02Qa\x02L6`\x04a&#V[a\x05\xDFV[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\x02 V[a\x02|a\x02w6`\x04a&UV[a\x06jV[\0[`\x0BT[`@Q\x90\x81R` \x01a\x02 V[a\x02|a\x02\x9E6`\x04a&}V[a\x07~V[a\x02\x82a\x02\xB16`\x04a&#V[_\x90\x81R` \x81\x90R`@\x90 `\x01\x01T\x90V[a\x02|a\x02\xD36`\x04a'^V[a\x07\xAFV[a\x02|a\x02\xE66`\x04a'\xE1V[a\x08_V[a\x02\x82a\x02\xF96`\x04a&UV[a\x08\x84V[a\x02|a\x03\x0C6`\x04a'\xE1V[a\t\x18V[a\x02|a\x03\x1F6`\x04a&}V[a\t\x96V[a\x02|a\x0326`\x04a&UV[a\t\xB0V[a\x02\x82a\x03E6`\x04a&#V[a\n\x84V[a\x02\x82a\x03X6`\x04a&#V[_\x90\x81R`\x13` R`@\x90 T\x90V[a\x02|a\x03w6`\x04a(\x0BV[a\x0B\x14V[a\x02Qa\x03\x8A6`\x04a&#V[a\x0B\xFAV[a\x02\x82a\x03\x9D6`\x04a(\x0BV[a\x0CpV[a\x03\xCEa\x03\xB06`\x04a&#V[_\x90\x81R`\x11` \x90\x81R`@\x80\x83 T`\x12\x90\x92R\x90\x91 T\x90\x91V[`@\x80Q\x92\x83R` \x83\x01\x91\x90\x91R\x01a\x02 V[a\x02Qa\x03\xF16`\x04a($V[a\x0C\xF5V[a\x02\x14a\x04\x046`\x04a'\xE1V[a\r\x13V[a\x02|a\x04\x176`\x04a(DV[a\r;V[a\x02|a\x04*6`\x04a(\xB9V[a\rRV[a\x021a\x0E\xB1V[a\x02\x82_\x81V[a\x02|a\x04L6`\x04a)\x9EV[a\x0E\xC0V[a\x021a\x04_6`\x04a&#V[a\x0E\xCBV[a\x02|a\x04r6`\x04a)\xD3V[a\x0E\xD8V[a\x021a\x04\x856`\x04a&#V[a\x0F\x10V[a\x021a\x04\x986`\x04a&#V[a\x0F-V[a\x02\x82a\x04\xAB6`\x04a&#V[a\x0F8V[a\x02\x82\x7F\x9F-\xF0\xFE\xD2\xC7vH\xDEX`\xA4\xCCP\x8C\xD0\x81\x8C\x85\xB8\xB8\xA1\xABL\xEE\xEF\x8D\x98\x1C\x89V\xA6\x81V[a\x02|a\x04\xE56`\x04a'\xE1V[a\x0FNV[a\x02\x14a\x04\xF86`\x04a*IV[`\x01`\x01`\xA0\x1B\x03\x91\x82\x16_\x90\x81R`\x07` \x90\x81R`@\x80\x83 \x93\x90\x94\x16\x82R\x91\x90\x91R T`\xFF\x16\x90V[_`\x01`\x01`\xE0\x1B\x03\x19\x82\x16c\rc\x9A\xDD`\xE1\x1B\x14\x80a\x05IWPa\x05I\x82a\x0FsV[\x92\x91PPV[```\x02\x80Ta\x05^\x90a*qV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x05\x8A\x90a*qV[\x80\x15a\x05\xD5W\x80`\x1F\x10a\x05\xACWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x05\xD5V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x05\xB8W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x90P\x90V[_a\x05\xE9\x82a\x0F\x97V[a\x06OW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`,`$\x82\x01R\x7FERC721: approved query for nonex`D\x82\x01Rk4\xB9\xBA2\xB7:\x10:7\xB5\xB2\xB7`\xA1\x1B`d\x82\x01R`\x84\x01[`@Q\x80\x91\x03\x90\xFD[P_\x90\x81R`\x06` R`@\x90 T`\x01`\x01`\xA0\x1B\x03\x16\x90V[_a\x06t\x82a\x0B\xFAV[\x90P\x80`\x01`\x01`\xA0\x1B\x03\x16\x83`\x01`\x01`\xA0\x1B\x03\x16\x03a\x06\xE1W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`!`$\x82\x01R\x7FERC721: approval to current owne`D\x82\x01R`9`\xF9\x1B`d\x82\x01R`\x84\x01a\x06FV[3`\x01`\x01`\xA0\x1B\x03\x82\x16\x14\x80a\x06\xFDWPa\x06\xFD\x813a\x04\xF8V[a\x07oW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`8`$\x82\x01R\x7FERC721: approve caller is not ow`D\x82\x01R\x7Fner nor approved for all\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06FV[a\x07y\x83\x83a\x0F\xB3V[PPPV[a\x07\x883\x82a\x10 V[a\x07\xA4W`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x06F\x90a*\xA9V[a\x07y\x83\x83\x83a\x11\x07V[\x7F\x9F-\xF0\xFE\xD2\xC7vH\xDEX`\xA4\xCCP\x8C\xD0\x81\x8C\x85\xB8\xB8\xA1\xABL\xEE\xEF\x8D\x98\x1C\x89V\xA6a\x07\xDA\x813a\x12\xAEV[a\x07\xE5`\x0F\x86a\x13\x12V[P_a\x07\xF2`\x0F\x87a\x13\xBBV[\x90P_\x86\x86`@Q` \x01a\x08\x08\x92\x91\x90a+\x11V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x90Pa\x08&\x88\x86\x86\x85\x85a\x13\xE5V[\x83\x85\x83\x7Fs^^\xB5\xAF\xDDr\xCCde}\xED~]\xE3\x90\xAF7\x08\xAF\xB5\xB9\xA8\x0B\x0E\\\x91\x1A\x04\x99\xD9\x8F`@Q`@Q\x80\x91\x03\x90\xA4PPPPPPPPV[_\x82\x81R` \x81\x90R`@\x90 `\x01\x01Ta\x08z\x813a\x12\xAEV[a\x07y\x83\x83a\x144V[_a\x08\x8E\x83a\x0CpV[\x82\x10a\x08\xF0W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`+`$\x82\x01R\x7FERC721Enumerable: owner index ou`D\x82\x01Rjt of bounds`\xA8\x1B`d\x82\x01R`\x84\x01a\x06FV[P`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16_\x90\x81R`\t` \x90\x81R`@\x80\x83 \x93\x83R\x92\x90R T\x90V[`\x01`\x01`\xA0\x1B\x03\x81\x163\x14a\t\x88W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`/`$\x82\x01R\x7FAccessControl: can only renounce`D\x82\x01Rn\x1097\xB62\xB9\x9037\xB9\x109\xB2\xB63`\x89\x1B`d\x82\x01R`\x84\x01a\x06FV[a\t\x92\x82\x82a\x14UV[PPV[a\x07y\x83\x83\x83`@Q\x80` \x01`@R\x80_\x81RPa\x0E\xD8V[_a\t\xBB\x813a\x12\xAEV[`\x02`\rT\x03a\n\rW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1F`$\x82\x01R\x7FReentrancyGuard: reentrant call\0`D\x82\x01R`d\x01a\x06FV[`\x02`\rU`@\x80Qc#\xB8r\xDD`\xE0\x1B\x81R0`\x04\x82\x01R3`$\x82\x01R`D\x81\x01\x84\x90R\x90Q`\x01`\x01`\xA0\x1B\x03\x85\x16\x91c#\xB8r\xDD\x91`d\x80\x83\x01\x92_\x92\x91\x90\x82\x90\x03\x01\x81\x83\x87\x80;\x15\x80\x15a\ndW__\xFD[PZ\xF1\x15\x80\x15a\nvW=__>=_\xFD[PP`\x01`\rUPPPPPV[_a\n\x8E`\x0BT\x90V[\x82\x10a\n\xF1W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`,`$\x82\x01R\x7FERC721Enumerable: global index o`D\x82\x01Rkut of bounds`\xA0\x1B`d\x82\x01R`\x84\x01a\x06FV[`\x0B\x82\x81T\x81\x10a\x0B\x04Wa\x0B\x04a+9V[\x90_R` _ \x01T\x90P\x91\x90PV[_a\x0B\x1F\x813a\x12\xAEV[`\x02`\rT\x03a\x0BqW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1F`$\x82\x01R\x7FReentrancyGuard: reentrant call\0`D\x82\x01R`d\x01a\x06FV[`\x02`\rUa\x0B\xF13`@Qcp\xA0\x821`\xE0\x1B\x81R0`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x85\x16\x90cp\xA0\x821\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0B\xBCW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0B\xE0\x91\x90a+MV[`\x01`\x01`\xA0\x1B\x03\x85\x16\x91\x90a\x14vV[PP`\x01`\rUV[_\x81\x81R`\x04` R`@\x81 T`\x01`\x01`\xA0\x1B\x03\x16\x80a\x05IW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`)`$\x82\x01R\x7FERC721: owner query for nonexist`D\x82\x01Rh2\xB7:\x10:7\xB5\xB2\xB7`\xB9\x1B`d\x82\x01R`\x84\x01a\x06FV[_`\x01`\x01`\xA0\x1B\x03\x82\x16a\x0C\xDAW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`*`$\x82\x01R\x7FERC721: balance query for the ze`D\x82\x01Riro address`\xB0\x1B`d\x82\x01R`\x84\x01a\x06FV[P`\x01`\x01`\xA0\x1B\x03\x16_\x90\x81R`\x05` R`@\x90 T\x90V[_\x82\x81R`\x01` R`@\x81 a\r\x0C\x90\x83a\x14\xC8V[\x93\x92PPPV[_\x91\x82R` \x82\x81R`@\x80\x84 `\x01`\x01`\xA0\x1B\x03\x93\x90\x93\x16\x84R\x91\x90R\x90 T`\xFF\x16\x90V[_a\rF\x813a\x12\xAEV[`\x0Ea\x07y\x83\x82a+\xAFV[\x7F\x9F-\xF0\xFE\xD2\xC7vH\xDEX`\xA4\xCCP\x8C\xD0\x81\x8C\x85\xB8\xB8\xA1\xABL\xEE\xEF\x8D\x98\x1C\x89V\xA6a\r}\x813a\x12\xAEV[a\r\xBF\x87\x87\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x91\x90\x91RP`\x0F\x93\x92PPa\x13\x12\x90PV[P_a\x0E\x03\x88\x88\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x91\x90\x91RP`\x0F\x93\x92PPa\x13\xBB\x90PV[\x90P_\x88\x88\x88\x88`@Q` \x01a\x0E\x1D\x94\x93\x92\x91\x90a,iV[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R\x90P_[\x8A\x81\x10\x15a\x0EtWa\x0El\x8C\x8C\x83\x81\x81\x10a\x0ENWa\x0ENa+9V[\x90P` \x02\x01` \x81\x01\x90a\x0Ec\x91\x90a(\x0BV[\x87\x87\x86\x86a\x13\xE5V[`\x01\x01a\x0E1V[P\x83\x85\x83\x7Fs^^\xB5\xAF\xDDr\xCCde}\xED~]\xE3\x90\xAF7\x08\xAF\xB5\xB9\xA8\x0B\x0E\\\x91\x1A\x04\x99\xD9\x8F`@Q`@Q\x80\x91\x03\x90\xA4PPPPPPPPPPPV[```\x03\x80Ta\x05^\x90a*qV[a\t\x923\x83\x83a\x14\xD3V[``a\x05I`\x0F\x83a\x15\xA0V[a\x0E\xE23\x83a\x10 V[a\x0E\xFEW`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x06F\x90a*\xA9V[a\x0F\n\x84\x84\x84\x84a\x16UV[PPPPV[_\x81\x81R`\x13` R`@\x90 T``\x90a\x05I\x90`\x0F\x90a\x15\xA0V[``a\x05I\x82a\x16\x88V[_\x81\x81R`\x01` R`@\x81 a\x05I\x90a\x17\xE4V[_\x82\x81R` \x81\x90R`@\x90 `\x01\x01Ta\x0Fi\x813a\x12\xAEV[a\x07y\x83\x83a\x14UV[_`\x01`\x01`\xE0\x1B\x03\x19\x82\x16cx\x0E\x9Dc`\xE0\x1B\x14\x80a\x05IWPa\x05I\x82a\x17\xEDV[_\x90\x81R`\x04` R`@\x90 T`\x01`\x01`\xA0\x1B\x03\x16\x15\x15\x90V[_\x81\x81R`\x06` R`@\x90 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x84\x16\x90\x81\x17\x90\x91U\x81\x90a\x0F\xE7\x82a\x0B\xFAV[`\x01`\x01`\xA0\x1B\x03\x16\x7F\x8C[\xE1\xE5\xEB\xEC}[\xD1OqB}\x1E\x84\xF3\xDD\x03\x14\xC0\xF7\xB2)\x1E[ \n\xC8\xC7\xC3\xB9%`@Q`@Q\x80\x91\x03\x90\xA4PPV[_a\x10*\x82a\x0F\x97V[a\x10\x8BW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`,`$\x82\x01R\x7FERC721: operator query for nonex`D\x82\x01Rk4\xB9\xBA2\xB7:\x10:7\xB5\xB2\xB7`\xA1\x1B`d\x82\x01R`\x84\x01a\x06FV[_a\x10\x95\x83a\x0B\xFAV[\x90P\x80`\x01`\x01`\xA0\x1B\x03\x16\x84`\x01`\x01`\xA0\x1B\x03\x16\x14\x80a\x10\xD0WP\x83`\x01`\x01`\xA0\x1B\x03\x16a\x10\xC5\x84a\x05\xDFV[`\x01`\x01`\xA0\x1B\x03\x16\x14[\x80a\x10\xFFWP`\x01`\x01`\xA0\x1B\x03\x80\x82\x16_\x90\x81R`\x07` \x90\x81R`@\x80\x83 \x93\x88\x16\x83R\x92\x90R T`\xFF\x16[\x94\x93PPPPV[\x82`\x01`\x01`\xA0\x1B\x03\x16a\x11\x1A\x82a\x0B\xFAV[`\x01`\x01`\xA0\x1B\x03\x16\x14a\x11\x82W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`)`$\x82\x01R\x7FERC721: transfer of token that i`D\x82\x01Rh9\x9077\xBA\x107\xBB\xB7`\xB9\x1B`d\x82\x01R`\x84\x01a\x06FV[`\x01`\x01`\xA0\x1B\x03\x82\x16a\x11\xE4W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`$\x80\x82\x01R\x7FERC721: transfer to the zero add`D\x82\x01Rcress`\xE0\x1B`d\x82\x01R`\x84\x01a\x06FV[a\x11\xEF\x83\x83\x83a\x18,V[a\x11\xF9_\x82a\x0F\xB3V[`\x01`\x01`\xA0\x1B\x03\x83\x16_\x90\x81R`\x05` R`@\x81 \x80T`\x01\x92\x90a\x12!\x90\x84\x90a,\xA6V[\x90\x91UPP`\x01`\x01`\xA0\x1B\x03\x82\x16_\x90\x81R`\x05` R`@\x81 \x80T`\x01\x92\x90a\x12N\x90\x84\x90a,\xB9V[\x90\x91UPP_\x81\x81R`\x04` R`@\x80\x82 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x86\x81\x16\x91\x82\x17\x90\x92U\x91Q\x84\x93\x91\x87\x16\x91\x7F\xDD\xF2R\xAD\x1B\xE2\xC8\x9Bi\xC2\xB0h\xFC7\x8D\xAA\x95+\xA7\xF1c\xC4\xA1\x16(\xF5ZM\xF5#\xB3\xEF\x91\xA4PPPV[a\x12\xB8\x82\x82a\r\x13V[a\t\x92Wa\x12\xD0\x81`\x01`\x01`\xA0\x1B\x03\x16`\x14a\x187V[a\x12\xDB\x83` a\x187V[`@Q` \x01a\x12\xEC\x92\x91\x90a,\xCCV[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90RbF\x1B\xCD`\xE5\x1B\x82Ra\x06F\x91`\x04\x01a&\x11V[_a\x13\x1D\x83\x83a\x19\xCCV[a\x13\xB4W\x82T`\x01\x81\x01\x84U_\x84\x81R` \x90 \x01a\x13<\x83\x82a+\xAFV[P\x82T`@Q`\x01\x85\x01\x90a\x13R\x90\x85\x90a-!V[\x90\x81R` \x01`@Q\x80\x91\x03\x90 \x81\x90UP\x82`\x01\x01\x82`@Qa\x13v\x91\x90a-!V[\x90\x81R`@Q\x90\x81\x90\x03` \x01\x81 T\x90\x7F\x11Iz\x83IQ\tTi\x93\x0E\xC6.\x16A\xF0\xDC\xF3a}\x9C\xD7W\x9Bm\xA7nT\xDF0\0\xA7\x90_\x90\xA2P`\x01a\x05IV[P_a\x05IV[_\x82`\x01\x01\x82`@Qa\x13\xCE\x91\x90a-!V[\x90\x81R` \x01`@Q\x80\x91\x03\x90 T\x90P\x92\x91PPV[_a\x13\xEF`\x0BT\x90V[\x90Pa\x13\xFB\x86\x82a\x19\xF8V[_\x81\x81R`\x11` \x90\x81R`@\x80\x83 \x88\x90U`\x12\x82R\x80\x83 \x87\x90U`\x13\x90\x91R\x90 \x83\x90Ua\x14,\x81\x83a\x1B4V[PPPPPPV[a\x14>\x82\x82a\x1B\xB7V[_\x82\x81R`\x01` R`@\x90 a\x07y\x90\x82a\x1C:V[a\x14_\x82\x82a\x1CNV[_\x82\x81R`\x01` R`@\x90 a\x07y\x90\x82a\x1C\xB2V[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x84\x16`$\x82\x01R`D\x80\x82\x01\x84\x90R\x82Q\x80\x83\x03\x90\x91\x01\x81R`d\x90\x91\x01\x90\x91R` \x81\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16c\xA9\x05\x9C\xBB`\xE0\x1B\x17\x90Ra\x07y\x90\x84\x90a\x1C\xC6V[_a\r\x0C\x83\x83a\x1D\x97V[\x81`\x01`\x01`\xA0\x1B\x03\x16\x83`\x01`\x01`\xA0\x1B\x03\x16\x03a\x154W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x19`$\x82\x01R\x7FERC721: approve to caller\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06FV[`\x01`\x01`\xA0\x1B\x03\x83\x81\x16_\x81\x81R`\x07` \x90\x81R`@\x80\x83 \x94\x87\x16\x80\x84R\x94\x82R\x91\x82\x90 \x80T`\xFF\x19\x16\x86\x15\x15\x90\x81\x17\x90\x91U\x91Q\x91\x82R\x7F\x170~\xAB9\xABa\x07\xE8\x89\x98E\xAD=Y\xBD\x96S\xF2\0\xF2 \x92\x04\x89\xCA+Y7il1\x91\x01`@Q\x80\x91\x03\x90\xA3PPPV[``\x82a\x15\xAE`\x01\x84a,\xA6V[\x81T\x81\x10a\x15\xBEWa\x15\xBEa+9V[\x90_R` _ \x01\x80Ta\x15\xD1\x90a*qV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x15\xFD\x90a*qV[\x80\x15a\x16HW\x80`\x1F\x10a\x16\x1FWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x16HV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x16+W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x90P\x92\x91PPV[a\x16`\x84\x84\x84a\x11\x07V[a\x16l\x84\x84\x84\x84a\x1D\xBDV[a\x0F\nW`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x06F\x90a-,V[``a\x16\x93\x82a\x0F\x97V[a\x16\xF9W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`1`$\x82\x01R\x7FERC721URIStorage: URI query for `D\x82\x01Rp77\xB72\xBC4\xB9\xBA2\xB7:\x10:7\xB5\xB2\xB7`y\x1B`d\x82\x01R`\x84\x01a\x06FV[_\x82\x81R`\x08` R`@\x81 \x80Ta\x17\x11\x90a*qV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x17=\x90a*qV[\x80\x15a\x17\x88W\x80`\x1F\x10a\x17_Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x17\x88V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x17kW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x90P_a\x17\x98a\x1E\xBAV[\x90P\x80Q_\x03a\x17\xA9WP\x92\x91PPV[\x81Q\x15a\x17\xDBW\x80\x82`@Q` \x01a\x17\xC3\x92\x91\x90a-~V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x92PPP\x91\x90PV[a\x10\xFF\x84a\x1E\xC9V[_a\x05I\x82T\x90V[_`\x01`\x01`\xE0\x1B\x03\x19\x82\x16c\x80\xACX\xCD`\xE0\x1B\x14\x80a\x18\x1DWP`\x01`\x01`\xE0\x1B\x03\x19\x82\x16c[^\x13\x9F`\xE0\x1B\x14[\x80a\x05IWPa\x05I\x82a\x1F\x90V[a\x07y\x83\x83\x83a\x1F\xB4V[``_a\x18E\x83`\x02a-\x92V[a\x18P\x90`\x02a,\xB9V[`\x01`\x01`@\x1B\x03\x81\x11\x15a\x18gWa\x18ga&\xB7V[`@Q\x90\x80\x82R\x80`\x1F\x01`\x1F\x19\x16` \x01\x82\x01`@R\x80\x15a\x18\x91W` \x82\x01\x81\x806\x837\x01\x90P[P\x90P`\x03`\xFC\x1B\x81_\x81Q\x81\x10a\x18\xABWa\x18\xABa+9V[` \x01\x01\x90`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x81_\x1A\x90SP`\x0F`\xFB\x1B\x81`\x01\x81Q\x81\x10a\x18\xD9Wa\x18\xD9a+9V[` \x01\x01\x90`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x81_\x1A\x90SP_a\x18\xFB\x84`\x02a-\x92V[a\x19\x06\x90`\x01a,\xB9V[\x90P[`\x01\x81\x11\x15a\x19}Wo\x18\x18\x99\x19\x9A\x1A\x9B\x1B\x9C\x1C\xB0\xB11\xB22\xB3`\x81\x1B\x85`\x0F\x16`\x10\x81\x10a\x19:Wa\x19:a+9V[\x1A`\xF8\x1B\x82\x82\x81Q\x81\x10a\x19PWa\x19Pa+9V[` \x01\x01\x90`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x81_\x1A\x90SP`\x04\x94\x90\x94\x1C\x93a\x19v\x81a-\xA9V[\x90Pa\x19\tV[P\x83\x15a\r\x0CW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7FStrings: hex length insufficient`D\x82\x01R`d\x01a\x06FV[_\x82`\x01\x01\x82`@Qa\x19\xDF\x91\x90a-!V[\x90\x81R`@Q\x90\x81\x90\x03` \x01\x90 T\x15\x15\x93\x92PPPV[`\x01`\x01`\xA0\x1B\x03\x82\x16a\x1ANW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7FERC721: mint to the zero address`D\x82\x01R`d\x01a\x06FV[a\x1AW\x81a\x0F\x97V[\x15a\x1A\xA4W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7FERC721: token already minted\0\0\0\0`D\x82\x01R`d\x01a\x06FV[a\x1A\xAF_\x83\x83a\x18,V[`\x01`\x01`\xA0\x1B\x03\x82\x16_\x90\x81R`\x05` R`@\x81 \x80T`\x01\x92\x90a\x1A\xD7\x90\x84\x90a,\xB9V[\x90\x91UPP_\x81\x81R`\x04` R`@\x80\x82 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x86\x16\x90\x81\x17\x90\x91U\x90Q\x83\x92\x90\x7F\xDD\xF2R\xAD\x1B\xE2\xC8\x9Bi\xC2\xB0h\xFC7\x8D\xAA\x95+\xA7\xF1c\xC4\xA1\x16(\xF5ZM\xF5#\xB3\xEF\x90\x82\x90\xA4PPV[a\x1B=\x82a\x0F\x97V[a\x1B\xA0W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`.`$\x82\x01R\x7FERC721URIStorage: URI set of non`D\x82\x01Rm2\xBC4\xB9\xBA2\xB7:\x10:7\xB5\xB2\xB7`\x91\x1B`d\x82\x01R`\x84\x01a\x06FV[_\x82\x81R`\x08` R`@\x90 a\x07y\x82\x82a+\xAFV[a\x1B\xC1\x82\x82a\r\x13V[a\t\x92W_\x82\x81R` \x81\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x85\x16\x84R\x90\x91R\x90 \x80T`\xFF\x19\x16`\x01\x17\x90Ua\x1B\xF63\x90V[`\x01`\x01`\xA0\x1B\x03\x16\x81`\x01`\x01`\xA0\x1B\x03\x16\x83\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r`@Q`@Q\x80\x91\x03\x90\xA4PPV[_a\r\x0C\x83`\x01`\x01`\xA0\x1B\x03\x84\x16a kV[a\x1CX\x82\x82a\r\x13V[\x15a\t\x92W_\x82\x81R` \x81\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x85\x16\x80\x85R\x92R\x80\x83 \x80T`\xFF\x19\x16\x90UQ3\x92\x85\x91\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B\x91\x90\xA4PPV[_a\r\x0C\x83`\x01`\x01`\xA0\x1B\x03\x84\x16a \xB0V[_a\x1D\x1A\x82`@Q\x80`@\x01`@R\x80` \x81R` \x01\x7FSafeERC20: low-level call failed\x81RP\x85`\x01`\x01`\xA0\x1B\x03\x16a!\x93\x90\x92\x91\x90c\xFF\xFF\xFF\xFF\x16V[\x80Q\x90\x91P\x15a\x07yW\x80\x80` \x01\x90Q\x81\x01\x90a\x1D8\x91\x90a-\xBEV[a\x07yW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`*`$\x82\x01R\x7FSafeERC20: ERC20 operation did n`D\x82\x01Ri\x1B\xDD\x08\x1C\xDDX\xD8\xD9YY`\xB2\x1B`d\x82\x01R`\x84\x01a\x06FV[_\x82_\x01\x82\x81T\x81\x10a\x1D\xACWa\x1D\xACa+9V[\x90_R` _ \x01T\x90P\x92\x91PPV[_`\x01`\x01`\xA0\x1B\x03\x84\x16;\x15a\x1E\xAFW`@Qc\n\x85\xBD\x01`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x85\x16\x90c\x15\x0Bz\x02\x90a\x1E\0\x903\x90\x89\x90\x88\x90\x88\x90`\x04\x01a-\xD9V[` `@Q\x80\x83\x03\x81_\x87Z\xF1\x92PPP\x80\x15a\x1E:WP`@\x80Q`\x1F=\x90\x81\x01`\x1F\x19\x16\x82\x01\x90\x92Ra\x1E7\x91\x81\x01\x90a.\x15V[`\x01[a\x1E\x95W=\x80\x80\x15a\x1EgW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\x1ElV[``\x91P[P\x80Q_\x03a\x1E\x8DW`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x06F\x90a-,V[\x80Q\x81` \x01\xFD[`\x01`\x01`\xE0\x1B\x03\x19\x16c\n\x85\xBD\x01`\xE1\x1B\x14\x90Pa\x10\xFFV[P`\x01\x94\x93PPPPV[```\x0E\x80Ta\x05^\x90a*qV[``a\x1E\xD4\x82a\x0F\x97V[a\x1F8W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`/`$\x82\x01R\x7FERC721Metadata: URI query for no`D\x82\x01Rn72\xBC4\xB9\xBA2\xB7:\x10:7\xB5\xB2\xB7`\x89\x1B`d\x82\x01R`\x84\x01a\x06FV[_a\x1FAa\x1E\xBAV[\x90P_\x81Q\x11a\x1F_W`@Q\x80` \x01`@R\x80_\x81RPa\r\x0CV[\x80a\x1Fi\x84a!\xA1V[`@Q` \x01a\x1Fz\x92\x91\x90a-~V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x93\x92PPPV[_`\x01`\x01`\xE0\x1B\x03\x19\x82\x16cZ\x05\x18\x0F`\xE0\x1B\x14\x80a\x05IWPa\x05I\x82a\"\x9DV[`\x01`\x01`\xA0\x1B\x03\x83\x16a \x0EWa \t\x81`\x0B\x80T_\x83\x81R`\x0C` R`@\x81 \x82\x90U`\x01\x82\x01\x83U\x91\x90\x91R\x7F\x01u\xB7\xA68Bw\x03\xF0\xDB\xE7\xBB\x9B\xBF\x98z%Qq{4\xE7\x9F3\xB5\xB1\0\x8D\x1F\xA0\x1D\xB9\x01UV[a 1V[\x81`\x01`\x01`\xA0\x1B\x03\x16\x83`\x01`\x01`\xA0\x1B\x03\x16\x14a 1Wa 1\x83\x82a\"\xD1V[`\x01`\x01`\xA0\x1B\x03\x82\x16a HWa\x07y\x81a#jV[\x82`\x01`\x01`\xA0\x1B\x03\x16\x82`\x01`\x01`\xA0\x1B\x03\x16\x14a\x07yWa\x07y\x82\x82a$\x11V[_\x81\x81R`\x01\x83\x01` R`@\x81 Ta\x13\xB4WP\x81T`\x01\x81\x81\x01\x84U_\x84\x81R` \x80\x82 \x90\x93\x01\x84\x90U\x84T\x84\x82R\x82\x86\x01\x90\x93R`@\x90 \x91\x90\x91Ua\x05IV[_\x81\x81R`\x01\x83\x01` R`@\x81 T\x80\x15a!\x8AW_a \xD2`\x01\x83a,\xA6V[\x85T\x90\x91P_\x90a \xE5\x90`\x01\x90a,\xA6V[\x90P\x81\x81\x14a!DW_\x86_\x01\x82\x81T\x81\x10a!\x03Wa!\x03a+9V[\x90_R` _ \x01T\x90P\x80\x87_\x01\x84\x81T\x81\x10a!#Wa!#a+9V[_\x91\x82R` \x80\x83 \x90\x91\x01\x92\x90\x92U\x91\x82R`\x01\x88\x01\x90R`@\x90 \x83\x90U[\x85T\x86\x90\x80a!UWa!Ua.0V[`\x01\x90\x03\x81\x81\x90_R` _ \x01_\x90U\x90U\x85`\x01\x01_\x86\x81R` \x01\x90\x81R` \x01_ _\x90U`\x01\x93PPPPa\x05IV[_\x91PPa\x05IV[``a\x10\xFF\x84\x84_\x85a$SV[``\x81_\x03a!\xC7WPP`@\x80Q\x80\x82\x01\x90\x91R`\x01\x81R`\x03`\xFC\x1B` \x82\x01R\x90V[\x81_[\x81\x15a!\xF0W\x80a!\xDA\x81a.DV[\x91Pa!\xE9\x90P`\n\x83a.pV[\x91Pa!\xCAV[_\x81`\x01`\x01`@\x1B\x03\x81\x11\x15a\"\tWa\"\ta&\xB7V[`@Q\x90\x80\x82R\x80`\x1F\x01`\x1F\x19\x16` \x01\x82\x01`@R\x80\x15a\"3W` \x82\x01\x81\x806\x837\x01\x90P[P\x90P[\x84\x15a\x10\xFFWa\"H`\x01\x83a,\xA6V[\x91Pa\"U`\n\x86a.\x83V[a\"`\x90`0a,\xB9V[`\xF8\x1B\x81\x83\x81Q\x81\x10a\"uWa\"ua+9V[` \x01\x01\x90`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x81_\x1A\x90SPa\"\x96`\n\x86a.pV[\x94Pa\"7V[_`\x01`\x01`\xE0\x1B\x03\x19\x82\x16cye\xDB\x0B`\xE0\x1B\x14\x80a\x05IWPc\x01\xFF\xC9\xA7`\xE0\x1B`\x01`\x01`\xE0\x1B\x03\x19\x83\x16\x14a\x05IV[_`\x01a\"\xDD\x84a\x0CpV[a\"\xE7\x91\x90a,\xA6V[_\x83\x81R`\n` R`@\x90 T\x90\x91P\x80\x82\x14a#8W`\x01`\x01`\xA0\x1B\x03\x84\x16_\x90\x81R`\t` \x90\x81R`@\x80\x83 \x85\x84R\x82R\x80\x83 T\x84\x84R\x81\x84 \x81\x90U\x83R`\n\x90\x91R\x90 \x81\x90U[P_\x91\x82R`\n` \x90\x81R`@\x80\x84 \x84\x90U`\x01`\x01`\xA0\x1B\x03\x90\x94\x16\x83R`\t\x81R\x83\x83 \x91\x83RR\x90\x81 UV[`\x0BT_\x90a#{\x90`\x01\x90a,\xA6V[_\x83\x81R`\x0C` R`@\x81 T`\x0B\x80T\x93\x94P\x90\x92\x84\x90\x81\x10a#\xA2Wa#\xA2a+9V[\x90_R` _ \x01T\x90P\x80`\x0B\x83\x81T\x81\x10a#\xC1Wa#\xC1a+9V[_\x91\x82R` \x80\x83 \x90\x91\x01\x92\x90\x92U\x82\x81R`\x0C\x90\x91R`@\x80\x82 \x84\x90U\x85\x82R\x81 U`\x0B\x80T\x80a#\xF8Wa#\xF8a.0V[`\x01\x90\x03\x81\x81\x90_R` _ \x01_\x90U\x90UPPPPV[_a$\x1B\x83a\x0CpV[`\x01`\x01`\xA0\x1B\x03\x90\x93\x16_\x90\x81R`\t` \x90\x81R`@\x80\x83 \x86\x84R\x82R\x80\x83 \x85\x90U\x93\x82R`\n\x90R\x91\x90\x91 \x91\x90\x91UPV[``\x82G\x10\x15a$\xB4W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FAddress: insufficient balance fo`D\x82\x01Re\x1C\x88\x18\xD8[\x1B`\xD2\x1B`d\x82\x01R`\x84\x01a\x06FV[\x84;a%\x02W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1D`$\x82\x01R\x7FAddress: call to non-contract\0\0\0`D\x82\x01R`d\x01a\x06FV[__\x86`\x01`\x01`\xA0\x1B\x03\x16\x85\x87`@Qa%\x1D\x91\x90a-!V[_`@Q\x80\x83\x03\x81\x85\x87Z\xF1\x92PPP=\x80_\x81\x14a%WW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a%\\V[``\x91P[P\x91P\x91Pa%l\x82\x82\x86a%wV[\x97\x96PPPPPPPV[``\x83\x15a%\x86WP\x81a\r\x0CV[\x82Q\x15a%\x96W\x82Q\x80\x84` \x01\xFD[\x81`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x06F\x91\x90a&\x11V[`\x01`\x01`\xE0\x1B\x03\x19\x81\x16\x81\x14a%\xC5W__\xFD[PV[_` \x82\x84\x03\x12\x15a%\xD8W__\xFD[\x815a\r\x0C\x81a%\xB0V[_\x81Q\x80\x84R\x80` \x84\x01` \x86\x01^_` \x82\x86\x01\x01R` `\x1F\x19`\x1F\x83\x01\x16\x85\x01\x01\x91PP\x92\x91PPV[` \x81R_a\r\x0C` \x83\x01\x84a%\xE3V[_` \x82\x84\x03\x12\x15a&3W__\xFD[P5\x91\x90PV[\x805`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a&PW__\xFD[\x91\x90PV[__`@\x83\x85\x03\x12\x15a&fW__\xFD[a&o\x83a&:V[\x94` \x93\x90\x93\x015\x93PPPV[___``\x84\x86\x03\x12\x15a&\x8FW__\xFD[a&\x98\x84a&:V[\x92Pa&\xA6` \x85\x01a&:V[\x92\x95\x92\x94PPP`@\x91\x90\x91\x015\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[__`\x01`\x01`@\x1B\x03\x84\x11\x15a&\xE4Wa&\xE4a&\xB7V[P`@Q`\x1F\x19`\x1F\x85\x01\x81\x16`?\x01\x16\x81\x01\x81\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17\x15a'\x12Wa'\x12a&\xB7V[`@R\x83\x81R\x90P\x80\x82\x84\x01\x85\x10\x15a')W__\xFD[\x83\x83` \x83\x017_` \x85\x83\x01\x01RP\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a'OW__\xFD[a\r\x0C\x83\x835` \x85\x01a&\xCBV[_____`\xA0\x86\x88\x03\x12\x15a'rW__\xFD[a'{\x86a&:V[\x94P` \x86\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a'\x95W__\xFD[a'\xA1\x88\x82\x89\x01a'@V[\x94PP`@\x86\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a'\xBCW__\xFD[a'\xC8\x88\x82\x89\x01a'@V[\x95\x98\x94\x97P\x94\x95``\x81\x015\x95P`\x80\x015\x93\x92PPPV[__`@\x83\x85\x03\x12\x15a'\xF2W__\xFD[\x825\x91Pa(\x02` \x84\x01a&:V[\x90P\x92P\x92\x90PV[_` \x82\x84\x03\x12\x15a(\x1BW__\xFD[a\r\x0C\x82a&:V[__`@\x83\x85\x03\x12\x15a(5W__\xFD[PP\x805\x92` \x90\x91\x015\x91PV[_` \x82\x84\x03\x12\x15a(TW__\xFD[\x815`\x01`\x01`@\x1B\x03\x81\x11\x15a(iW__\xFD[a\x10\xFF\x84\x82\x85\x01a'@V[__\x83`\x1F\x84\x01\x12a(\x85W__\xFD[P\x815`\x01`\x01`@\x1B\x03\x81\x11\x15a(\x9BW__\xFD[` \x83\x01\x91P\x83` \x82\x85\x01\x01\x11\x15a(\xB2W__\xFD[\x92P\x92\x90PV[________`\xA0\x89\x8B\x03\x12\x15a(\xD0W__\xFD[\x885`\x01`\x01`@\x1B\x03\x81\x11\x15a(\xE5W__\xFD[\x89\x01`\x1F\x81\x01\x8B\x13a(\xF5W__\xFD[\x805`\x01`\x01`@\x1B\x03\x81\x11\x15a)\nW__\xFD[\x8B` \x82`\x05\x1B\x84\x01\x01\x11\x15a)\x1EW__\xFD[` \x91\x82\x01\x99P\x97P\x89\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a)=W__\xFD[a)I\x8B\x82\x8C\x01a(uV[\x90\x97P\x95PP`@\x89\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a)gW__\xFD[a)s\x8B\x82\x8C\x01a(uV[\x99\x9C\x98\x9BP\x96\x99\x95\x98\x96\x97``\x87\x015\x96`\x80\x015\x95P\x93PPPPV[\x80\x15\x15\x81\x14a%\xC5W__\xFD[__`@\x83\x85\x03\x12\x15a)\xAFW__\xFD[a)\xB8\x83a&:V[\x91P` \x83\x015a)\xC8\x81a)\x91V[\x80\x91PP\x92P\x92\x90PV[____`\x80\x85\x87\x03\x12\x15a)\xE6W__\xFD[a)\xEF\x85a&:V[\x93Pa)\xFD` \x86\x01a&:V[\x92P`@\x85\x015\x91P``\x85\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a*\x1EW__\xFD[\x85\x01`\x1F\x81\x01\x87\x13a*.W__\xFD[a*=\x87\x825` \x84\x01a&\xCBV[\x91PP\x92\x95\x91\x94P\x92PV[__`@\x83\x85\x03\x12\x15a*ZW__\xFD[a*c\x83a&:V[\x91Pa(\x02` \x84\x01a&:V[`\x01\x81\x81\x1C\x90\x82\x16\x80a*\x85W`\x7F\x82\x16\x91P[` \x82\x10\x81\x03a*\xA3WcNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[P\x91\x90PV[` \x80\x82R`1\x90\x82\x01R\x7FERC721: transfer caller is not o`@\x82\x01Rp\x1D\xDB\x99\\\x88\x1B\x9B\xDC\x88\x18\\\x1C\x1C\x9B\xDD\x99Y`z\x1B``\x82\x01R`\x80\x01\x90V[_\x81Q\x80` \x84\x01\x85^_\x93\x01\x92\x83RP\x90\x91\x90PV[_a+\x1C\x82\x85a*\xFAV[`/`\xF8\x1B\x81Ra+0`\x01\x82\x01\x85a*\xFAV[\x95\x94PPPPPV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[_` \x82\x84\x03\x12\x15a+]W__\xFD[PQ\x91\x90PV[`\x1F\x82\x11\x15a\x07yW\x80_R` _ `\x1F\x84\x01`\x05\x1C\x81\x01` \x85\x10\x15a+\x89WP\x80[`\x1F\x84\x01`\x05\x1C\x82\x01\x91P[\x81\x81\x10\x15a+\xA8W_\x81U`\x01\x01a+\x95V[PPPPPV[\x81Q`\x01`\x01`@\x1B\x03\x81\x11\x15a+\xC8Wa+\xC8a&\xB7V[a+\xDC\x81a+\xD6\x84Ta*qV[\x84a+dV[` `\x1F\x82\x11`\x01\x81\x14a,\x0EW_\x83\x15a+\xF7WP\x84\x82\x01Q[_\x19`\x03\x85\x90\x1B\x1C\x19\x16`\x01\x84\x90\x1B\x17\x84Ua+\xA8V[_\x84\x81R` \x81 `\x1F\x19\x85\x16\x91[\x82\x81\x10\x15a,=W\x87\x85\x01Q\x82U` \x94\x85\x01\x94`\x01\x90\x92\x01\x91\x01a,\x1DV[P\x84\x82\x10\x15a,ZW\x86\x84\x01Q_\x19`\x03\x87\x90\x1B`\xF8\x16\x1C\x19\x16\x81U[PPPP`\x01\x90\x81\x1B\x01\x90UPV[\x83\x85\x827_\x84\x82\x01`/`\xF8\x1B\x81R\x83\x85`\x01\x83\x017_\x93\x01`\x01\x01\x92\x83RP\x90\x94\x93PPPPV[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[\x81\x81\x03\x81\x81\x11\x15a\x05IWa\x05Ia,\x92V[\x80\x82\x01\x80\x82\x11\x15a\x05IWa\x05Ia,\x92V[\x7FAccessControl: account \0\0\0\0\0\0\0\0\0\x81R_a,\xFD`\x17\x83\x01\x85a*\xFAV[p\x01\x03K\x99\x03kK\x9B\x9BKs9\x03\x93{c)`}\x1B\x81Ra+0`\x11\x82\x01\x85a*\xFAV[_a\r\x0C\x82\x84a*\xFAV[` \x80\x82R`2\x90\x82\x01R\x7FERC721: transfer to non ERC721Re`@\x82\x01Rq1\xB2\xB4\xBB2\xB9\x104\xB6\xB862\xB6\xB2\xB7:2\xB9`q\x1B``\x82\x01R`\x80\x01\x90V[_a\x10\xFFa-\x8C\x83\x86a*\xFAV[\x84a*\xFAV[\x80\x82\x02\x81\x15\x82\x82\x04\x84\x14\x17a\x05IWa\x05Ia,\x92V[_\x81a-\xB7Wa-\xB7a,\x92V[P_\x19\x01\x90V[_` \x82\x84\x03\x12\x15a-\xCEW__\xFD[\x81Qa\r\x0C\x81a)\x91V[`\x01`\x01`\xA0\x1B\x03\x85\x81\x16\x82R\x84\x16` \x82\x01R`@\x81\x01\x83\x90R`\x80``\x82\x01\x81\x90R_\x90a.\x0B\x90\x83\x01\x84a%\xE3V[\x96\x95PPPPPPV[_` \x82\x84\x03\x12\x15a.%W__\xFD[\x81Qa\r\x0C\x81a%\xB0V[cNH{q`\xE0\x1B_R`1`\x04R`$_\xFD[_`\x01\x82\x01a.UWa.Ua,\x92V[P`\x01\x01\x90V[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[_\x82a.~Wa.~a.\\V[P\x04\x90V[_\x82a.\x91Wa.\x91a.\\V[P\x06\x90V\xFE\xA2dipfsX\"\x12 \x12\x8DI\xEB-4J\x9E)\x14\xC0\x81e\x1A;-\x19R\xCB\xD7-e\xFE\x8C\xCB~l~\xDD?\xC3\x12dsolcC\0\x08\x1E\x003",
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Approval(address,address,uint256)` and selector `0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925`.
```solidity
event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Approval {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub approved: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub tokenId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Approval {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "Approval(address,address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                140u8, 91u8, 225u8, 229u8, 235u8, 236u8, 125u8, 91u8, 209u8, 79u8, 113u8,
                66u8, 125u8, 30u8, 132u8, 243u8, 221u8, 3u8, 20u8, 192u8, 247u8, 178u8,
                41u8, 30u8, 91u8, 32u8, 10u8, 200u8, 199u8, 195u8, 185u8, 37u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    owner: topics.1,
                    approved: topics.2,
                    tokenId: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.owner.clone(),
                    self.approved.clone(),
                    self.tokenId.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.owner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.approved,
                );
                out[3usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.tokenId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Approval {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Approval> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Approval) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `ApprovalForAll(address,address,bool)` and selector `0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31`.
```solidity
event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ApprovalForAll {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub approved: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ApprovalForAll {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "ApprovalForAll(address,address,bool)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                23u8, 48u8, 126u8, 171u8, 57u8, 171u8, 97u8, 7u8, 232u8, 137u8, 152u8,
                69u8, 173u8, 61u8, 89u8, 189u8, 150u8, 83u8, 242u8, 0u8, 242u8, 32u8,
                146u8, 4u8, 137u8, 202u8, 43u8, 89u8, 55u8, 105u8, 108u8, 49u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    owner: topics.1,
                    operator: topics.2,
                    approved: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.approved,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.owner.clone(), self.operator.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.owner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.operator,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ApprovalForAll {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ApprovalForAll> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ApprovalForAll) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `BoostMinted(uint256,uint256,uint256)` and selector `0x735e5eb5afdd72cc64657ded7e5de390af3708afb5b9a80b0e5c911a0499d98f`.
```solidity
event BoostMinted(uint256 indexed boostTypeIndex, uint256 indexed boostNumerator, uint256 indexed redeemDeadline);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BoostMinted {
        #[allow(missing_docs)]
        pub boostTypeIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub boostNumerator: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub redeemDeadline: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BoostMinted {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "BoostMinted(uint256,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                115u8, 94u8, 94u8, 181u8, 175u8, 221u8, 114u8, 204u8, 100u8, 101u8,
                125u8, 237u8, 126u8, 93u8, 227u8, 144u8, 175u8, 55u8, 8u8, 175u8, 181u8,
                185u8, 168u8, 11u8, 14u8, 92u8, 145u8, 26u8, 4u8, 153u8, 217u8, 143u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    boostTypeIndex: topics.1,
                    boostNumerator: topics.2,
                    redeemDeadline: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.boostTypeIndex.clone(),
                    self.boostNumerator.clone(),
                    self.redeemDeadline.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.boostTypeIndex);
                out[2usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.boostNumerator);
                out[3usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.redeemDeadline);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BoostMinted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BoostMinted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BoostMinted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RoleAdminChanged(bytes32,bytes32,bytes32)` and selector `0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff`.
```solidity
event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleAdminChanged {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub previousAdminRole: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub newAdminRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleAdminChanged {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "RoleAdminChanged(bytes32,bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                189u8, 121u8, 184u8, 111u8, 254u8, 10u8, 184u8, 232u8, 119u8, 97u8, 81u8,
                81u8, 66u8, 23u8, 205u8, 124u8, 172u8, 213u8, 44u8, 144u8, 159u8, 102u8,
                71u8, 92u8, 58u8, 244u8, 78u8, 18u8, 159u8, 11u8, 0u8, 255u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    previousAdminRole: topics.2,
                    newAdminRole: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.previousAdminRole.clone(),
                    self.newAdminRole.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.previousAdminRole);
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.newAdminRole);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleAdminChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleAdminChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleAdminChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RoleGranted(bytes32,address,address)` and selector `0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d`.
```solidity
event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleGranted {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleGranted {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleGranted(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                47u8, 135u8, 136u8, 17u8, 126u8, 126u8, 255u8, 29u8, 130u8, 233u8, 38u8,
                236u8, 121u8, 73u8, 1u8, 209u8, 124u8, 120u8, 2u8, 74u8, 80u8, 39u8, 9u8,
                64u8, 48u8, 69u8, 64u8, 167u8, 51u8, 101u8, 111u8, 13u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleGranted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleGranted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleGranted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RoleRevoked(bytes32,address,address)` and selector `0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b`.
```solidity
event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleRevoked {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleRevoked {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleRevoked(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                246u8, 57u8, 31u8, 92u8, 50u8, 217u8, 198u8, 157u8, 42u8, 71u8, 234u8,
                103u8, 11u8, 68u8, 41u8, 116u8, 181u8, 57u8, 53u8, 209u8, 237u8, 199u8,
                253u8, 100u8, 235u8, 33u8, 224u8, 71u8, 168u8, 57u8, 23u8, 27u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleRevoked {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleRevoked> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleRevoked) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `SetCreated(uint256)` and selector `0x11497a834951095469930ec62e1641f0dcf3617d9cd7579b6da76e54df3000a7`.
```solidity
event SetCreated(uint256 indexed typeIndex);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct SetCreated {
        #[allow(missing_docs)]
        pub typeIndex: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for SetCreated {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "SetCreated(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                17u8, 73u8, 122u8, 131u8, 73u8, 81u8, 9u8, 84u8, 105u8, 147u8, 14u8,
                198u8, 46u8, 22u8, 65u8, 240u8, 220u8, 243u8, 97u8, 125u8, 156u8, 215u8,
                87u8, 155u8, 109u8, 167u8, 110u8, 84u8, 223u8, 48u8, 0u8, 167u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { typeIndex: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.typeIndex.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.typeIndex);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for SetCreated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&SetCreated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &SetCreated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Transfer(address,address,uint256)` and selector `0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef`.
```solidity
event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Transfer {
        #[allow(missing_docs)]
        pub from: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub tokenId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Transfer {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "Transfer(address,address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                221u8, 242u8, 82u8, 173u8, 27u8, 226u8, 200u8, 155u8, 105u8, 194u8,
                176u8, 104u8, 252u8, 55u8, 141u8, 170u8, 149u8, 43u8, 167u8, 241u8, 99u8,
                196u8, 161u8, 22u8, 40u8, 245u8, 90u8, 77u8, 245u8, 35u8, 179u8, 239u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    from: topics.1,
                    to: topics.2,
                    tokenId: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.from.clone(),
                    self.to.clone(),
                    self.tokenId.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.from,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.to,
                );
                out[3usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.tokenId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Transfer {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Transfer> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Transfer) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(address newAdmin, string baseTokenURI);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub newAdmin: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub baseTokenURI: alloy::sol_types::private::String,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (value.newAdmin, value.baseTokenURI)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        newAdmin: tuple.0,
                        baseTokenURI: tuple.1,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newAdmin,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.baseTokenURI,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `DEFAULT_ADMIN_ROLE()` and selector `0xa217fddf`.
```solidity
function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLECall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`DEFAULT_ADMIN_ROLE()`](DEFAULT_ADMIN_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DEFAULT_ADMIN_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DEFAULT_ADMIN_ROLE()";
            const SELECTOR: [u8; 4] = [162u8, 23u8, 253u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: DEFAULT_ADMIN_ROLEReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: DEFAULT_ADMIN_ROLEReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `MINTER_ROLE()` and selector `0xd5391393`.
```solidity
function MINTER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MINTER_ROLECall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`MINTER_ROLE()`](MINTER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MINTER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MINTER_ROLECall> for UnderlyingRustTuple<'_> {
                fn from(value: MINTER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for MINTER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MINTER_ROLEReturn> for UnderlyingRustTuple<'_> {
                fn from(value: MINTER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for MINTER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for MINTER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MINTER_ROLE()";
            const SELECTOR: [u8; 4] = [213u8, 57u8, 19u8, 147u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: MINTER_ROLEReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: MINTER_ROLEReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `approve(address,uint256)` and selector `0x095ea7b3`.
```solidity
function approve(address to, uint256 tokenId) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct approveCall {
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub tokenId: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`approve(address,uint256)`](approveCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct approveReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<approveCall> for UnderlyingRustTuple<'_> {
                fn from(value: approveCall) -> Self {
                    (value.to, value.tokenId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for approveCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        to: tuple.0,
                        tokenId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<approveReturn> for UnderlyingRustTuple<'_> {
                fn from(value: approveReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for approveReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl approveReturn {
            fn _tokenize(
                &self,
            ) -> <approveCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for approveCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = approveReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "approve(address,uint256)";
            const SELECTOR: [u8; 4] = [9u8, 94u8, 167u8, 179u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.tokenId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                approveReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `balanceOf(address)` and selector `0x70a08231`.
```solidity
function balanceOf(address owner) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct balanceOfCall {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`balanceOf(address)`](balanceOfCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct balanceOfReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<balanceOfCall> for UnderlyingRustTuple<'_> {
                fn from(value: balanceOfCall) -> Self {
                    (value.owner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for balanceOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { owner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<balanceOfReturn> for UnderlyingRustTuple<'_> {
                fn from(value: balanceOfReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for balanceOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for balanceOfCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "balanceOf(address)";
            const SELECTOR: [u8; 4] = [112u8, 160u8, 130u8, 49u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: balanceOfReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: balanceOfReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `batchMint(address[],string,string,uint256,uint256)` and selector `0x9365c533`.
```solidity
function batchMint(address[] memory to, string memory boostType, string memory boostRank, uint256 boostNumerator, uint256 redeemDeadline) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct batchMintCall {
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
        #[allow(missing_docs)]
        pub boostType: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub boostRank: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub boostNumerator: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub redeemDeadline: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`batchMint(address[],string,string,uint256,uint256)`](batchMintCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct batchMintReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<batchMintCall> for UnderlyingRustTuple<'_> {
                fn from(value: batchMintCall) -> Self {
                    (
                        value.to,
                        value.boostType,
                        value.boostRank,
                        value.boostNumerator,
                        value.redeemDeadline,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for batchMintCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        to: tuple.0,
                        boostType: tuple.1,
                        boostRank: tuple.2,
                        boostNumerator: tuple.3,
                        redeemDeadline: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<batchMintReturn> for UnderlyingRustTuple<'_> {
                fn from(value: batchMintReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for batchMintReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl batchMintReturn {
            fn _tokenize(
                &self,
            ) -> <batchMintCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for batchMintCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = batchMintReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "batchMint(address[],string,string,uint256,uint256)";
            const SELECTOR: [u8; 4] = [147u8, 101u8, 197u8, 51u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.to),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.boostType,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.boostRank,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.boostNumerator),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.redeemDeadline),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                batchMintReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `boostOf(uint256)` and selector `0x896cddf4`.
```solidity
function boostOf(uint256 tokenId) external view returns (uint256, uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct boostOfCall {
        #[allow(missing_docs)]
        pub tokenId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`boostOf(uint256)`](boostOfCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct boostOfReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub _1: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<boostOfCall> for UnderlyingRustTuple<'_> {
                fn from(value: boostOfCall) -> Self {
                    (value.tokenId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for boostOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { tokenId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<boostOfReturn> for UnderlyingRustTuple<'_> {
                fn from(value: boostOfReturn) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for boostOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0, _1: tuple.1 }
                }
            }
        }
        impl boostOfReturn {
            fn _tokenize(
                &self,
            ) -> <boostOfCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._1),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for boostOfCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = boostOfReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "boostOf(uint256)";
            const SELECTOR: [u8; 4] = [137u8, 108u8, 221u8, 244u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.tokenId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                boostOfReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getApproved(uint256)` and selector `0x081812fc`.
```solidity
function getApproved(uint256 tokenId) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getApprovedCall {
        #[allow(missing_docs)]
        pub tokenId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getApproved(uint256)`](getApprovedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getApprovedReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getApprovedCall> for UnderlyingRustTuple<'_> {
                fn from(value: getApprovedCall) -> Self {
                    (value.tokenId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getApprovedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { tokenId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getApprovedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getApprovedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getApprovedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getApprovedCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getApproved(uint256)";
            const SELECTOR: [u8; 4] = [8u8, 24u8, 18u8, 252u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.tokenId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getApprovedReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getApprovedReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getRoleAdmin(bytes32)` and selector `0x248a9ca3`.
```solidity
function getRoleAdmin(bytes32 role) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getRoleAdmin(bytes32)`](getRoleAdminCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminCall> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminCall) -> Self {
                    (value.role,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { role: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRoleAdminCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRoleAdmin(bytes32)";
            const SELECTOR: [u8; 4] = [36u8, 138u8, 156u8, 163u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getRoleAdminReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getRoleAdminReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getRoleMember(bytes32,uint256)` and selector `0x9010d07c`.
```solidity
function getRoleMember(bytes32 role, uint256 index) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleMemberCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub index: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getRoleMember(bytes32,uint256)`](getRoleMemberCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleMemberReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleMemberCall> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleMemberCall) -> Self {
                    (value.role, value.index)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleMemberCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        index: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleMemberReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleMemberReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleMemberReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRoleMemberCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRoleMember(bytes32,uint256)";
            const SELECTOR: [u8; 4] = [144u8, 16u8, 208u8, 124u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getRoleMemberReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getRoleMemberReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getRoleMemberCount(bytes32)` and selector `0xca15c873`.
```solidity
function getRoleMemberCount(bytes32 role) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleMemberCountCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getRoleMemberCount(bytes32)`](getRoleMemberCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleMemberCountReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleMemberCountCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getRoleMemberCountCall) -> Self {
                    (value.role,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getRoleMemberCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { role: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleMemberCountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getRoleMemberCountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getRoleMemberCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRoleMemberCountCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRoleMemberCount(bytes32)";
            const SELECTOR: [u8; 4] = [202u8, 21u8, 200u8, 115u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getRoleMemberCountReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getRoleMemberCountReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `grantRole(bytes32,address)` and selector `0x2f2ff15d`.
```solidity
function grantRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`grantRole(bytes32,address)`](grantRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl grantRoleReturn {
            fn _tokenize(
                &self,
            ) -> <grantRoleCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for grantRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = grantRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "grantRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [47u8, 47u8, 241u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                grantRoleReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `hasRole(bytes32,address)` and selector `0x91d14854`.
```solidity
function hasRole(bytes32 role, address account) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`hasRole(bytes32,address)`](hasRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for hasRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "hasRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [145u8, 209u8, 72u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: hasRoleReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: hasRoleReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `isApprovedForAll(address,address)` and selector `0xe985e9c5`.
```solidity
function isApprovedForAll(address owner, address operator) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isApprovedForAllCall {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`isApprovedForAll(address,address)`](isApprovedForAllCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isApprovedForAllReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isApprovedForAllCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: isApprovedForAllCall) -> Self {
                    (value.owner, value.operator)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isApprovedForAllCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        owner: tuple.0,
                        operator: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isApprovedForAllReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: isApprovedForAllReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isApprovedForAllReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isApprovedForAllCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isApprovedForAll(address,address)";
            const SELECTOR: [u8; 4] = [233u8, 133u8, 233u8, 197u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: isApprovedForAllReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: isApprovedForAllReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `mint(address,string,string,uint256,uint256)` and selector `0x29867dac`.
```solidity
function mint(address to, string memory boostType, string memory boostRank, uint256 boostNumerator, uint256 redeemDeadline) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintCall {
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub boostType: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub boostRank: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub boostNumerator: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub redeemDeadline: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`mint(address,string,string,uint256,uint256)`](mintCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintCall> for UnderlyingRustTuple<'_> {
                fn from(value: mintCall) -> Self {
                    (
                        value.to,
                        value.boostType,
                        value.boostRank,
                        value.boostNumerator,
                        value.redeemDeadline,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for mintCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        to: tuple.0,
                        boostType: tuple.1,
                        boostRank: tuple.2,
                        boostNumerator: tuple.3,
                        redeemDeadline: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintReturn> for UnderlyingRustTuple<'_> {
                fn from(value: mintReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for mintReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl mintReturn {
            fn _tokenize(
                &self,
            ) -> <mintCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for mintCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = mintReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "mint(address,string,string,uint256,uint256)";
            const SELECTOR: [u8; 4] = [41u8, 134u8, 125u8, 172u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.boostType,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.boostRank,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.boostNumerator),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.redeemDeadline),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                mintReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `name()` and selector `0x06fdde03`.
```solidity
function name() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nameCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`name()`](nameCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nameReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nameCall> for UnderlyingRustTuple<'_> {
                fn from(value: nameCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for nameCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nameReturn> for UnderlyingRustTuple<'_> {
                fn from(value: nameReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for nameReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for nameCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::String;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "name()";
            const SELECTOR: [u8; 4] = [6u8, 253u8, 222u8, 3u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: nameReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: nameReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `ownerOf(uint256)` and selector `0x6352211e`.
```solidity
function ownerOf(uint256 tokenId) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerOfCall {
        #[allow(missing_docs)]
        pub tokenId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`ownerOf(uint256)`](ownerOfCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerOfReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerOfCall> for UnderlyingRustTuple<'_> {
                fn from(value: ownerOfCall) -> Self {
                    (value.tokenId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { tokenId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerOfReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ownerOfReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ownerOfCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ownerOf(uint256)";
            const SELECTOR: [u8; 4] = [99u8, 82u8, 33u8, 30u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.tokenId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: ownerOfReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: ownerOfReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `reclaimErc20Tokens(address)` and selector `0x6067bc15`.
```solidity
function reclaimErc20Tokens(address tokenAddress) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct reclaimErc20TokensCall {
        #[allow(missing_docs)]
        pub tokenAddress: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`reclaimErc20Tokens(address)`](reclaimErc20TokensCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct reclaimErc20TokensReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<reclaimErc20TokensCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: reclaimErc20TokensCall) -> Self {
                    (value.tokenAddress,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for reclaimErc20TokensCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { tokenAddress: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<reclaimErc20TokensReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: reclaimErc20TokensReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for reclaimErc20TokensReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl reclaimErc20TokensReturn {
            fn _tokenize(
                &self,
            ) -> <reclaimErc20TokensCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for reclaimErc20TokensCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = reclaimErc20TokensReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "reclaimErc20Tokens(address)";
            const SELECTOR: [u8; 4] = [96u8, 103u8, 188u8, 21u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.tokenAddress,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                reclaimErc20TokensReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `reclaimErc721Tokens(address,uint256)` and selector `0x48c64e41`.
```solidity
function reclaimErc721Tokens(address tokenAddress, uint256 tokenId) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct reclaimErc721TokensCall {
        #[allow(missing_docs)]
        pub tokenAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub tokenId: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`reclaimErc721Tokens(address,uint256)`](reclaimErc721TokensCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct reclaimErc721TokensReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<reclaimErc721TokensCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: reclaimErc721TokensCall) -> Self {
                    (value.tokenAddress, value.tokenId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for reclaimErc721TokensCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        tokenAddress: tuple.0,
                        tokenId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<reclaimErc721TokensReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: reclaimErc721TokensReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for reclaimErc721TokensReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl reclaimErc721TokensReturn {
            fn _tokenize(
                &self,
            ) -> <reclaimErc721TokensCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for reclaimErc721TokensCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = reclaimErc721TokensReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "reclaimErc721Tokens(address,uint256)";
            const SELECTOR: [u8; 4] = [72u8, 198u8, 78u8, 65u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.tokenAddress,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.tokenId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                reclaimErc721TokensReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `renounceRole(bytes32,address)` and selector `0x36568abe`.
```solidity
function renounceRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`renounceRole(bytes32,address)`](renounceRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl renounceRoleReturn {
            fn _tokenize(
                &self,
            ) -> <renounceRoleCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [54u8, 86u8, 138u8, 190u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                renounceRoleReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `revokeRole(bytes32,address)` and selector `0xd547741f`.
```solidity
function revokeRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`revokeRole(bytes32,address)`](revokeRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl revokeRoleReturn {
            fn _tokenize(
                &self,
            ) -> <revokeRoleCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for revokeRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = revokeRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "revokeRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [213u8, 71u8, 116u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                revokeRoleReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `safeTransferFrom(address,address,uint256)` and selector `0x42842e0e`.
```solidity
function safeTransferFrom(address from, address to, uint256 tokenId) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct safeTransferFrom_0Call {
        #[allow(missing_docs)]
        pub from: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub tokenId: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`safeTransferFrom(address,address,uint256)`](safeTransferFrom_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct safeTransferFrom_0Return {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<safeTransferFrom_0Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: safeTransferFrom_0Call) -> Self {
                    (value.from, value.to, value.tokenId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for safeTransferFrom_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        from: tuple.0,
                        to: tuple.1,
                        tokenId: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<safeTransferFrom_0Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: safeTransferFrom_0Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for safeTransferFrom_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl safeTransferFrom_0Return {
            fn _tokenize(
                &self,
            ) -> <safeTransferFrom_0Call as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for safeTransferFrom_0Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = safeTransferFrom_0Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "safeTransferFrom(address,address,uint256)";
            const SELECTOR: [u8; 4] = [66u8, 132u8, 46u8, 14u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.from,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.tokenId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                safeTransferFrom_0Return::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `safeTransferFrom(address,address,uint256,bytes)` and selector `0xb88d4fde`.
```solidity
function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct safeTransferFrom_1Call {
        #[allow(missing_docs)]
        pub from: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub tokenId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub _data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`safeTransferFrom(address,address,uint256,bytes)`](safeTransferFrom_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct safeTransferFrom_1Return {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<safeTransferFrom_1Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: safeTransferFrom_1Call) -> Self {
                    (value.from, value.to, value.tokenId, value._data)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for safeTransferFrom_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        from: tuple.0,
                        to: tuple.1,
                        tokenId: tuple.2,
                        _data: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<safeTransferFrom_1Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: safeTransferFrom_1Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for safeTransferFrom_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl safeTransferFrom_1Return {
            fn _tokenize(
                &self,
            ) -> <safeTransferFrom_1Call as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for safeTransferFrom_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = safeTransferFrom_1Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "safeTransferFrom(address,address,uint256,bytes)";
            const SELECTOR: [u8; 4] = [184u8, 141u8, 79u8, 222u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.from,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.tokenId),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self._data,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                safeTransferFrom_1Return::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setApprovalForAll(address,bool)` and selector `0xa22cb465`.
```solidity
function setApprovalForAll(address operator, bool approved) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setApprovalForAllCall {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub approved: bool,
    }
    ///Container type for the return parameters of the [`setApprovalForAll(address,bool)`](setApprovalForAllCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setApprovalForAllReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, bool);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setApprovalForAllCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setApprovalForAllCall) -> Self {
                    (value.operator, value.approved)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setApprovalForAllCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        operator: tuple.0,
                        approved: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setApprovalForAllReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setApprovalForAllReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setApprovalForAllReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setApprovalForAllReturn {
            fn _tokenize(
                &self,
            ) -> <setApprovalForAllCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setApprovalForAllCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setApprovalForAllReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setApprovalForAll(address,bool)";
            const SELECTOR: [u8; 4] = [162u8, 44u8, 180u8, 101u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.approved,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setApprovalForAllReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `supportsInterface(bytes4)` and selector `0x01ffc9a7`.
```solidity
function supportsInterface(bytes4 interfaceId) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceCall {
        #[allow(missing_docs)]
        pub interfaceId: alloy::sol_types::private::FixedBytes<4>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`supportsInterface(bytes4)`](supportsInterfaceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<4>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceCall) -> Self {
                    (value.interfaceId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { interfaceId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for supportsInterfaceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "supportsInterface(bytes4)";
            const SELECTOR: [u8; 4] = [1u8, 255u8, 201u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        4,
                    > as alloy_sol_types::SolType>::tokenize(&self.interfaceId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: supportsInterfaceReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: supportsInterfaceReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `symbol()` and selector `0x95d89b41`.
```solidity
function symbol() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct symbolCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`symbol()`](symbolCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct symbolReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<symbolCall> for UnderlyingRustTuple<'_> {
                fn from(value: symbolCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for symbolCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<symbolReturn> for UnderlyingRustTuple<'_> {
                fn from(value: symbolReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for symbolReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for symbolCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::String;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "symbol()";
            const SELECTOR: [u8; 4] = [149u8, 216u8, 155u8, 65u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: symbolReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: symbolReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `tokenByIndex(uint256)` and selector `0x4f6ccce7`.
```solidity
function tokenByIndex(uint256 index) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct tokenByIndexCall {
        #[allow(missing_docs)]
        pub index: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`tokenByIndex(uint256)`](tokenByIndexCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct tokenByIndexReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<tokenByIndexCall> for UnderlyingRustTuple<'_> {
                fn from(value: tokenByIndexCall) -> Self {
                    (value.index,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for tokenByIndexCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { index: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<tokenByIndexReturn> for UnderlyingRustTuple<'_> {
                fn from(value: tokenByIndexReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for tokenByIndexReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for tokenByIndexCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "tokenByIndex(uint256)";
            const SELECTOR: [u8; 4] = [79u8, 108u8, 204u8, 231u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: tokenByIndexReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: tokenByIndexReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `tokenOfOwnerByIndex(address,uint256)` and selector `0x2f745c59`.
```solidity
function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct tokenOfOwnerByIndexCall {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub index: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`tokenOfOwnerByIndex(address,uint256)`](tokenOfOwnerByIndexCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct tokenOfOwnerByIndexReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<tokenOfOwnerByIndexCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: tokenOfOwnerByIndexCall) -> Self {
                    (value.owner, value.index)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for tokenOfOwnerByIndexCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        owner: tuple.0,
                        index: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<tokenOfOwnerByIndexReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: tokenOfOwnerByIndexReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for tokenOfOwnerByIndexReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for tokenOfOwnerByIndexCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "tokenOfOwnerByIndex(address,uint256)";
            const SELECTOR: [u8; 4] = [47u8, 116u8, 92u8, 89u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: tokenOfOwnerByIndexReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: tokenOfOwnerByIndexReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `tokenURI(uint256)` and selector `0xc87b56dd`.
```solidity
function tokenURI(uint256 tokenId) external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct tokenURICall {
        #[allow(missing_docs)]
        pub tokenId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`tokenURI(uint256)`](tokenURICall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct tokenURIReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<tokenURICall> for UnderlyingRustTuple<'_> {
                fn from(value: tokenURICall) -> Self {
                    (value.tokenId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for tokenURICall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { tokenId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<tokenURIReturn> for UnderlyingRustTuple<'_> {
                fn from(value: tokenURIReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for tokenURIReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for tokenURICall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::String;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "tokenURI(uint256)";
            const SELECTOR: [u8; 4] = [200u8, 123u8, 86u8, 221u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.tokenId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: tokenURIReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: tokenURIReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `totalSupply()` and selector `0x18160ddd`.
```solidity
function totalSupply() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalSupplyCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`totalSupply()`](totalSupplyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalSupplyReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalSupplyCall> for UnderlyingRustTuple<'_> {
                fn from(value: totalSupplyCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for totalSupplyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalSupplyReturn> for UnderlyingRustTuple<'_> {
                fn from(value: totalSupplyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for totalSupplyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for totalSupplyCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "totalSupply()";
            const SELECTOR: [u8; 4] = [24u8, 22u8, 13u8, 221u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: totalSupplyReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: totalSupplyReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `transferFrom(address,address,uint256)` and selector `0x23b872dd`.
```solidity
function transferFrom(address from, address to, uint256 tokenId) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferFromCall {
        #[allow(missing_docs)]
        pub from: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub tokenId: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`transferFrom(address,address,uint256)`](transferFromCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferFromReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferFromCall> for UnderlyingRustTuple<'_> {
                fn from(value: transferFromCall) -> Self {
                    (value.from, value.to, value.tokenId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferFromCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        from: tuple.0,
                        to: tuple.1,
                        tokenId: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferFromReturn> for UnderlyingRustTuple<'_> {
                fn from(value: transferFromReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferFromReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl transferFromReturn {
            fn _tokenize(
                &self,
            ) -> <transferFromCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferFromCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferFromReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferFrom(address,address,uint256)";
            const SELECTOR: [u8; 4] = [35u8, 184u8, 114u8, 221u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.from,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.tokenId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                transferFromReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `typeAt(uint256)` and selector `0xb5185a88`.
```solidity
function typeAt(uint256 typeIndex) external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct typeAtCall {
        #[allow(missing_docs)]
        pub typeIndex: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`typeAt(uint256)`](typeAtCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct typeAtReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<typeAtCall> for UnderlyingRustTuple<'_> {
                fn from(value: typeAtCall) -> Self {
                    (value.typeIndex,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for typeAtCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { typeIndex: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<typeAtReturn> for UnderlyingRustTuple<'_> {
                fn from(value: typeAtReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for typeAtReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for typeAtCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::String;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "typeAt(uint256)";
            const SELECTOR: [u8; 4] = [181u8, 24u8, 90u8, 136u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.typeIndex),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: typeAtReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: typeAtReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `typeIndexOf(uint256)` and selector `0x562317c5`.
```solidity
function typeIndexOf(uint256 tokenId) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct typeIndexOfCall {
        #[allow(missing_docs)]
        pub tokenId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`typeIndexOf(uint256)`](typeIndexOfCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct typeIndexOfReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<typeIndexOfCall> for UnderlyingRustTuple<'_> {
                fn from(value: typeIndexOfCall) -> Self {
                    (value.tokenId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for typeIndexOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { tokenId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<typeIndexOfReturn> for UnderlyingRustTuple<'_> {
                fn from(value: typeIndexOfReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for typeIndexOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for typeIndexOfCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "typeIndexOf(uint256)";
            const SELECTOR: [u8; 4] = [86u8, 35u8, 23u8, 197u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.tokenId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: typeIndexOfReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: typeIndexOfReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `typeOf(uint256)` and selector `0xc588ff8b`.
```solidity
function typeOf(uint256 tokenId) external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct typeOfCall {
        #[allow(missing_docs)]
        pub tokenId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`typeOf(uint256)`](typeOfCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct typeOfReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<typeOfCall> for UnderlyingRustTuple<'_> {
                fn from(value: typeOfCall) -> Self {
                    (value.tokenId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for typeOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { tokenId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<typeOfReturn> for UnderlyingRustTuple<'_> {
                fn from(value: typeOfReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for typeOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for typeOfCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::String;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "typeOf(uint256)";
            const SELECTOR: [u8; 4] = [197u8, 136u8, 255u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.tokenId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: typeOfReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: typeOfReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `updateBaseURI(string)` and selector `0x931688cb`.
```solidity
function updateBaseURI(string memory baseTokenURI) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateBaseURICall {
        #[allow(missing_docs)]
        pub baseTokenURI: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`updateBaseURI(string)`](updateBaseURICall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateBaseURIReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateBaseURICall> for UnderlyingRustTuple<'_> {
                fn from(value: updateBaseURICall) -> Self {
                    (value.baseTokenURI,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for updateBaseURICall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { baseTokenURI: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateBaseURIReturn> for UnderlyingRustTuple<'_> {
                fn from(value: updateBaseURIReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for updateBaseURIReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl updateBaseURIReturn {
            fn _tokenize(
                &self,
            ) -> <updateBaseURICall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateBaseURICall {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateBaseURIReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateBaseURI(string)";
            const SELECTOR: [u8; 4] = [147u8, 22u8, 136u8, 203u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.baseTokenURI,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                updateBaseURIReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`HoprBoost`](self) function calls.
    #[derive(Clone)]
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    pub enum HoprBoostCalls {
        #[allow(missing_docs)]
        DEFAULT_ADMIN_ROLE(DEFAULT_ADMIN_ROLECall),
        #[allow(missing_docs)]
        MINTER_ROLE(MINTER_ROLECall),
        #[allow(missing_docs)]
        approve(approveCall),
        #[allow(missing_docs)]
        balanceOf(balanceOfCall),
        #[allow(missing_docs)]
        batchMint(batchMintCall),
        #[allow(missing_docs)]
        boostOf(boostOfCall),
        #[allow(missing_docs)]
        getApproved(getApprovedCall),
        #[allow(missing_docs)]
        getRoleAdmin(getRoleAdminCall),
        #[allow(missing_docs)]
        getRoleMember(getRoleMemberCall),
        #[allow(missing_docs)]
        getRoleMemberCount(getRoleMemberCountCall),
        #[allow(missing_docs)]
        grantRole(grantRoleCall),
        #[allow(missing_docs)]
        hasRole(hasRoleCall),
        #[allow(missing_docs)]
        isApprovedForAll(isApprovedForAllCall),
        #[allow(missing_docs)]
        mint(mintCall),
        #[allow(missing_docs)]
        name(nameCall),
        #[allow(missing_docs)]
        ownerOf(ownerOfCall),
        #[allow(missing_docs)]
        reclaimErc20Tokens(reclaimErc20TokensCall),
        #[allow(missing_docs)]
        reclaimErc721Tokens(reclaimErc721TokensCall),
        #[allow(missing_docs)]
        renounceRole(renounceRoleCall),
        #[allow(missing_docs)]
        revokeRole(revokeRoleCall),
        #[allow(missing_docs)]
        safeTransferFrom_0(safeTransferFrom_0Call),
        #[allow(missing_docs)]
        safeTransferFrom_1(safeTransferFrom_1Call),
        #[allow(missing_docs)]
        setApprovalForAll(setApprovalForAllCall),
        #[allow(missing_docs)]
        supportsInterface(supportsInterfaceCall),
        #[allow(missing_docs)]
        symbol(symbolCall),
        #[allow(missing_docs)]
        tokenByIndex(tokenByIndexCall),
        #[allow(missing_docs)]
        tokenOfOwnerByIndex(tokenOfOwnerByIndexCall),
        #[allow(missing_docs)]
        tokenURI(tokenURICall),
        #[allow(missing_docs)]
        totalSupply(totalSupplyCall),
        #[allow(missing_docs)]
        transferFrom(transferFromCall),
        #[allow(missing_docs)]
        typeAt(typeAtCall),
        #[allow(missing_docs)]
        typeIndexOf(typeIndexOfCall),
        #[allow(missing_docs)]
        typeOf(typeOfCall),
        #[allow(missing_docs)]
        updateBaseURI(updateBaseURICall),
    }
    impl HoprBoostCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [1u8, 255u8, 201u8, 167u8],
            [6u8, 253u8, 222u8, 3u8],
            [8u8, 24u8, 18u8, 252u8],
            [9u8, 94u8, 167u8, 179u8],
            [24u8, 22u8, 13u8, 221u8],
            [35u8, 184u8, 114u8, 221u8],
            [36u8, 138u8, 156u8, 163u8],
            [41u8, 134u8, 125u8, 172u8],
            [47u8, 47u8, 241u8, 93u8],
            [47u8, 116u8, 92u8, 89u8],
            [54u8, 86u8, 138u8, 190u8],
            [66u8, 132u8, 46u8, 14u8],
            [72u8, 198u8, 78u8, 65u8],
            [79u8, 108u8, 204u8, 231u8],
            [86u8, 35u8, 23u8, 197u8],
            [96u8, 103u8, 188u8, 21u8],
            [99u8, 82u8, 33u8, 30u8],
            [112u8, 160u8, 130u8, 49u8],
            [137u8, 108u8, 221u8, 244u8],
            [144u8, 16u8, 208u8, 124u8],
            [145u8, 209u8, 72u8, 84u8],
            [147u8, 22u8, 136u8, 203u8],
            [147u8, 101u8, 197u8, 51u8],
            [149u8, 216u8, 155u8, 65u8],
            [162u8, 23u8, 253u8, 223u8],
            [162u8, 44u8, 180u8, 101u8],
            [181u8, 24u8, 90u8, 136u8],
            [184u8, 141u8, 79u8, 222u8],
            [197u8, 136u8, 255u8, 139u8],
            [200u8, 123u8, 86u8, 221u8],
            [202u8, 21u8, 200u8, 115u8],
            [213u8, 57u8, 19u8, 147u8],
            [213u8, 71u8, 116u8, 31u8],
            [233u8, 133u8, 233u8, 197u8],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(supportsInterface),
            ::core::stringify!(name),
            ::core::stringify!(getApproved),
            ::core::stringify!(approve),
            ::core::stringify!(totalSupply),
            ::core::stringify!(transferFrom),
            ::core::stringify!(getRoleAdmin),
            ::core::stringify!(mint),
            ::core::stringify!(grantRole),
            ::core::stringify!(tokenOfOwnerByIndex),
            ::core::stringify!(renounceRole),
            ::core::stringify!(safeTransferFrom_0),
            ::core::stringify!(reclaimErc721Tokens),
            ::core::stringify!(tokenByIndex),
            ::core::stringify!(typeIndexOf),
            ::core::stringify!(reclaimErc20Tokens),
            ::core::stringify!(ownerOf),
            ::core::stringify!(balanceOf),
            ::core::stringify!(boostOf),
            ::core::stringify!(getRoleMember),
            ::core::stringify!(hasRole),
            ::core::stringify!(updateBaseURI),
            ::core::stringify!(batchMint),
            ::core::stringify!(symbol),
            ::core::stringify!(DEFAULT_ADMIN_ROLE),
            ::core::stringify!(setApprovalForAll),
            ::core::stringify!(typeAt),
            ::core::stringify!(safeTransferFrom_1),
            ::core::stringify!(typeOf),
            ::core::stringify!(tokenURI),
            ::core::stringify!(getRoleMemberCount),
            ::core::stringify!(MINTER_ROLE),
            ::core::stringify!(revokeRole),
            ::core::stringify!(isApprovedForAll),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <supportsInterfaceCall as alloy_sol_types::SolCall>::SIGNATURE,
            <nameCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getApprovedCall as alloy_sol_types::SolCall>::SIGNATURE,
            <approveCall as alloy_sol_types::SolCall>::SIGNATURE,
            <totalSupplyCall as alloy_sol_types::SolCall>::SIGNATURE,
            <transferFromCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getRoleAdminCall as alloy_sol_types::SolCall>::SIGNATURE,
            <mintCall as alloy_sol_types::SolCall>::SIGNATURE,
            <grantRoleCall as alloy_sol_types::SolCall>::SIGNATURE,
            <tokenOfOwnerByIndexCall as alloy_sol_types::SolCall>::SIGNATURE,
            <renounceRoleCall as alloy_sol_types::SolCall>::SIGNATURE,
            <safeTransferFrom_0Call as alloy_sol_types::SolCall>::SIGNATURE,
            <reclaimErc721TokensCall as alloy_sol_types::SolCall>::SIGNATURE,
            <tokenByIndexCall as alloy_sol_types::SolCall>::SIGNATURE,
            <typeIndexOfCall as alloy_sol_types::SolCall>::SIGNATURE,
            <reclaimErc20TokensCall as alloy_sol_types::SolCall>::SIGNATURE,
            <ownerOfCall as alloy_sol_types::SolCall>::SIGNATURE,
            <balanceOfCall as alloy_sol_types::SolCall>::SIGNATURE,
            <boostOfCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getRoleMemberCall as alloy_sol_types::SolCall>::SIGNATURE,
            <hasRoleCall as alloy_sol_types::SolCall>::SIGNATURE,
            <updateBaseURICall as alloy_sol_types::SolCall>::SIGNATURE,
            <batchMintCall as alloy_sol_types::SolCall>::SIGNATURE,
            <symbolCall as alloy_sol_types::SolCall>::SIGNATURE,
            <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::SIGNATURE,
            <setApprovalForAllCall as alloy_sol_types::SolCall>::SIGNATURE,
            <typeAtCall as alloy_sol_types::SolCall>::SIGNATURE,
            <safeTransferFrom_1Call as alloy_sol_types::SolCall>::SIGNATURE,
            <typeOfCall as alloy_sol_types::SolCall>::SIGNATURE,
            <tokenURICall as alloy_sol_types::SolCall>::SIGNATURE,
            <getRoleMemberCountCall as alloy_sol_types::SolCall>::SIGNATURE,
            <MINTER_ROLECall as alloy_sol_types::SolCall>::SIGNATURE,
            <revokeRoleCall as alloy_sol_types::SolCall>::SIGNATURE,
            <isApprovedForAllCall as alloy_sol_types::SolCall>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for HoprBoostCalls {
        const NAME: &'static str = "HoprBoostCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 34usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::DEFAULT_ADMIN_ROLE(_) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::MINTER_ROLE(_) => {
                    <MINTER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::approve(_) => <approveCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::balanceOf(_) => {
                    <balanceOfCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::batchMint(_) => {
                    <batchMintCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::boostOf(_) => <boostOfCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getApproved(_) => {
                    <getApprovedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRoleAdmin(_) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRoleMember(_) => {
                    <getRoleMemberCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRoleMemberCount(_) => {
                    <getRoleMemberCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::grantRole(_) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::hasRole(_) => <hasRoleCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::isApprovedForAll(_) => {
                    <isApprovedForAllCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::mint(_) => <mintCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::name(_) => <nameCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::ownerOf(_) => <ownerOfCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::reclaimErc20Tokens(_) => {
                    <reclaimErc20TokensCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::reclaimErc721Tokens(_) => {
                    <reclaimErc721TokensCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::renounceRole(_) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::revokeRole(_) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::safeTransferFrom_0(_) => {
                    <safeTransferFrom_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::safeTransferFrom_1(_) => {
                    <safeTransferFrom_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setApprovalForAll(_) => {
                    <setApprovalForAllCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::supportsInterface(_) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::symbol(_) => <symbolCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::tokenByIndex(_) => {
                    <tokenByIndexCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::tokenOfOwnerByIndex(_) => {
                    <tokenOfOwnerByIndexCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::tokenURI(_) => <tokenURICall as alloy_sol_types::SolCall>::SELECTOR,
                Self::totalSupply(_) => {
                    <totalSupplyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::transferFrom(_) => {
                    <transferFromCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::typeAt(_) => <typeAtCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::typeIndexOf(_) => {
                    <typeIndexOfCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::typeOf(_) => <typeOfCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::updateBaseURI(_) => {
                    <updateBaseURICall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<HoprBoostCalls>] = &[
                {
                    fn supportsInterface(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::supportsInterface)
                    }
                    supportsInterface
                },
                {
                    fn name(data: &[u8]) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <nameCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprBoostCalls::name)
                    }
                    name
                },
                {
                    fn getApproved(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <getApprovedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::getApproved)
                    }
                    getApproved
                },
                {
                    fn approve(data: &[u8]) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <approveCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprBoostCalls::approve)
                    }
                    approve
                },
                {
                    fn totalSupply(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <totalSupplyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::totalSupply)
                    }
                    totalSupply
                },
                {
                    fn transferFrom(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <transferFromCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::transferFrom)
                    }
                    transferFrom
                },
                {
                    fn getRoleAdmin(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <getRoleAdminCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::getRoleAdmin)
                    }
                    getRoleAdmin
                },
                {
                    fn mint(data: &[u8]) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <mintCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprBoostCalls::mint)
                    }
                    mint
                },
                {
                    fn grantRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <grantRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprBoostCalls::grantRole)
                    }
                    grantRole
                },
                {
                    fn tokenOfOwnerByIndex(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <tokenOfOwnerByIndexCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::tokenOfOwnerByIndex)
                    }
                    tokenOfOwnerByIndex
                },
                {
                    fn renounceRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <renounceRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::renounceRole)
                    }
                    renounceRole
                },
                {
                    fn safeTransferFrom_0(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <safeTransferFrom_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::safeTransferFrom_0)
                    }
                    safeTransferFrom_0
                },
                {
                    fn reclaimErc721Tokens(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <reclaimErc721TokensCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::reclaimErc721Tokens)
                    }
                    reclaimErc721Tokens
                },
                {
                    fn tokenByIndex(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <tokenByIndexCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::tokenByIndex)
                    }
                    tokenByIndex
                },
                {
                    fn typeIndexOf(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <typeIndexOfCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::typeIndexOf)
                    }
                    typeIndexOf
                },
                {
                    fn reclaimErc20Tokens(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <reclaimErc20TokensCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::reclaimErc20Tokens)
                    }
                    reclaimErc20Tokens
                },
                {
                    fn ownerOf(data: &[u8]) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <ownerOfCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprBoostCalls::ownerOf)
                    }
                    ownerOf
                },
                {
                    fn balanceOf(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <balanceOfCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprBoostCalls::balanceOf)
                    }
                    balanceOf
                },
                {
                    fn boostOf(data: &[u8]) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <boostOfCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprBoostCalls::boostOf)
                    }
                    boostOf
                },
                {
                    fn getRoleMember(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <getRoleMemberCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::getRoleMember)
                    }
                    getRoleMember
                },
                {
                    fn hasRole(data: &[u8]) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <hasRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprBoostCalls::hasRole)
                    }
                    hasRole
                },
                {
                    fn updateBaseURI(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <updateBaseURICall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::updateBaseURI)
                    }
                    updateBaseURI
                },
                {
                    fn batchMint(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <batchMintCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprBoostCalls::batchMint)
                    }
                    batchMint
                },
                {
                    fn symbol(data: &[u8]) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <symbolCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprBoostCalls::symbol)
                    }
                    symbol
                },
                {
                    fn DEFAULT_ADMIN_ROLE(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::DEFAULT_ADMIN_ROLE)
                    }
                    DEFAULT_ADMIN_ROLE
                },
                {
                    fn setApprovalForAll(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <setApprovalForAllCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::setApprovalForAll)
                    }
                    setApprovalForAll
                },
                {
                    fn typeAt(data: &[u8]) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <typeAtCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprBoostCalls::typeAt)
                    }
                    typeAt
                },
                {
                    fn safeTransferFrom_1(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <safeTransferFrom_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::safeTransferFrom_1)
                    }
                    safeTransferFrom_1
                },
                {
                    fn typeOf(data: &[u8]) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <typeOfCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprBoostCalls::typeOf)
                    }
                    typeOf
                },
                {
                    fn tokenURI(data: &[u8]) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <tokenURICall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprBoostCalls::tokenURI)
                    }
                    tokenURI
                },
                {
                    fn getRoleMemberCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <getRoleMemberCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::getRoleMemberCount)
                    }
                    getRoleMemberCount
                },
                {
                    fn MINTER_ROLE(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <MINTER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::MINTER_ROLE)
                    }
                    MINTER_ROLE
                },
                {
                    fn revokeRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <revokeRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::revokeRole)
                    }
                    revokeRole
                },
                {
                    fn isApprovedForAll(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <isApprovedForAllCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::isApprovedForAll)
                    }
                    isApprovedForAll
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<HoprBoostCalls>] = &[
                {
                    fn supportsInterface(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::supportsInterface)
                    }
                    supportsInterface
                },
                {
                    fn name(data: &[u8]) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <nameCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::name)
                    }
                    name
                },
                {
                    fn getApproved(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <getApprovedCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::getApproved)
                    }
                    getApproved
                },
                {
                    fn approve(data: &[u8]) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <approveCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::approve)
                    }
                    approve
                },
                {
                    fn totalSupply(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <totalSupplyCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::totalSupply)
                    }
                    totalSupply
                },
                {
                    fn transferFrom(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <transferFromCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::transferFrom)
                    }
                    transferFrom
                },
                {
                    fn getRoleAdmin(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <getRoleAdminCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::getRoleAdmin)
                    }
                    getRoleAdmin
                },
                {
                    fn mint(data: &[u8]) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <mintCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::mint)
                    }
                    mint
                },
                {
                    fn grantRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <grantRoleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::grantRole)
                    }
                    grantRole
                },
                {
                    fn tokenOfOwnerByIndex(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <tokenOfOwnerByIndexCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::tokenOfOwnerByIndex)
                    }
                    tokenOfOwnerByIndex
                },
                {
                    fn renounceRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <renounceRoleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::renounceRole)
                    }
                    renounceRole
                },
                {
                    fn safeTransferFrom_0(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <safeTransferFrom_0Call as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::safeTransferFrom_0)
                    }
                    safeTransferFrom_0
                },
                {
                    fn reclaimErc721Tokens(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <reclaimErc721TokensCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::reclaimErc721Tokens)
                    }
                    reclaimErc721Tokens
                },
                {
                    fn tokenByIndex(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <tokenByIndexCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::tokenByIndex)
                    }
                    tokenByIndex
                },
                {
                    fn typeIndexOf(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <typeIndexOfCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::typeIndexOf)
                    }
                    typeIndexOf
                },
                {
                    fn reclaimErc20Tokens(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <reclaimErc20TokensCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::reclaimErc20Tokens)
                    }
                    reclaimErc20Tokens
                },
                {
                    fn ownerOf(data: &[u8]) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <ownerOfCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::ownerOf)
                    }
                    ownerOf
                },
                {
                    fn balanceOf(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <balanceOfCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::balanceOf)
                    }
                    balanceOf
                },
                {
                    fn boostOf(data: &[u8]) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <boostOfCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::boostOf)
                    }
                    boostOf
                },
                {
                    fn getRoleMember(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <getRoleMemberCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::getRoleMember)
                    }
                    getRoleMember
                },
                {
                    fn hasRole(data: &[u8]) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <hasRoleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::hasRole)
                    }
                    hasRole
                },
                {
                    fn updateBaseURI(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <updateBaseURICall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::updateBaseURI)
                    }
                    updateBaseURI
                },
                {
                    fn batchMint(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <batchMintCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::batchMint)
                    }
                    batchMint
                },
                {
                    fn symbol(data: &[u8]) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <symbolCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::symbol)
                    }
                    symbol
                },
                {
                    fn DEFAULT_ADMIN_ROLE(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::DEFAULT_ADMIN_ROLE)
                    }
                    DEFAULT_ADMIN_ROLE
                },
                {
                    fn setApprovalForAll(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <setApprovalForAllCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::setApprovalForAll)
                    }
                    setApprovalForAll
                },
                {
                    fn typeAt(data: &[u8]) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <typeAtCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::typeAt)
                    }
                    typeAt
                },
                {
                    fn safeTransferFrom_1(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <safeTransferFrom_1Call as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::safeTransferFrom_1)
                    }
                    safeTransferFrom_1
                },
                {
                    fn typeOf(data: &[u8]) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <typeOfCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::typeOf)
                    }
                    typeOf
                },
                {
                    fn tokenURI(data: &[u8]) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <tokenURICall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::tokenURI)
                    }
                    tokenURI
                },
                {
                    fn getRoleMemberCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <getRoleMemberCountCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::getRoleMemberCount)
                    }
                    getRoleMemberCount
                },
                {
                    fn MINTER_ROLE(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <MINTER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::MINTER_ROLE)
                    }
                    MINTER_ROLE
                },
                {
                    fn revokeRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <revokeRoleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::revokeRole)
                    }
                    revokeRole
                },
                {
                    fn isApprovedForAll(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <isApprovedForAllCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::isApprovedForAll)
                    }
                    isApprovedForAll
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::MINTER_ROLE(inner) => {
                    <MINTER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::approve(inner) => {
                    <approveCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::balanceOf(inner) => {
                    <balanceOfCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::batchMint(inner) => {
                    <batchMintCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::boostOf(inner) => {
                    <boostOfCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getApproved(inner) => {
                    <getApprovedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRoleMember(inner) => {
                    <getRoleMemberCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRoleMemberCount(inner) => {
                    <getRoleMemberCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::isApprovedForAll(inner) => {
                    <isApprovedForAllCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::mint(inner) => {
                    <mintCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::name(inner) => {
                    <nameCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::ownerOf(inner) => {
                    <ownerOfCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::reclaimErc20Tokens(inner) => {
                    <reclaimErc20TokensCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::reclaimErc721Tokens(inner) => {
                    <reclaimErc721TokensCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::safeTransferFrom_0(inner) => {
                    <safeTransferFrom_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::safeTransferFrom_1(inner) => {
                    <safeTransferFrom_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setApprovalForAll(inner) => {
                    <setApprovalForAllCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::symbol(inner) => {
                    <symbolCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::tokenByIndex(inner) => {
                    <tokenByIndexCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::tokenOfOwnerByIndex(inner) => {
                    <tokenOfOwnerByIndexCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::tokenURI(inner) => {
                    <tokenURICall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::totalSupply(inner) => {
                    <totalSupplyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::transferFrom(inner) => {
                    <transferFromCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::typeAt(inner) => {
                    <typeAtCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::typeIndexOf(inner) => {
                    <typeIndexOfCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::typeOf(inner) => {
                    <typeOfCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::updateBaseURI(inner) => {
                    <updateBaseURICall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::MINTER_ROLE(inner) => {
                    <MINTER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::approve(inner) => {
                    <approveCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::balanceOf(inner) => {
                    <balanceOfCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::batchMint(inner) => {
                    <batchMintCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::boostOf(inner) => {
                    <boostOfCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::getApproved(inner) => {
                    <getApprovedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRoleMember(inner) => {
                    <getRoleMemberCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRoleMemberCount(inner) => {
                    <getRoleMemberCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::isApprovedForAll(inner) => {
                    <isApprovedForAllCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::mint(inner) => {
                    <mintCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::name(inner) => {
                    <nameCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::ownerOf(inner) => {
                    <ownerOfCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::reclaimErc20Tokens(inner) => {
                    <reclaimErc20TokensCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::reclaimErc721Tokens(inner) => {
                    <reclaimErc721TokensCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::safeTransferFrom_0(inner) => {
                    <safeTransferFrom_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::safeTransferFrom_1(inner) => {
                    <safeTransferFrom_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setApprovalForAll(inner) => {
                    <setApprovalForAllCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::symbol(inner) => {
                    <symbolCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::tokenByIndex(inner) => {
                    <tokenByIndexCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::tokenOfOwnerByIndex(inner) => {
                    <tokenOfOwnerByIndexCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::tokenURI(inner) => {
                    <tokenURICall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::totalSupply(inner) => {
                    <totalSupplyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transferFrom(inner) => {
                    <transferFromCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::typeAt(inner) => {
                    <typeAtCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::typeIndexOf(inner) => {
                    <typeIndexOfCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::typeOf(inner) => {
                    <typeOfCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::updateBaseURI(inner) => {
                    <updateBaseURICall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`HoprBoost`](self) events.
    #[derive(Clone)]
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum HoprBoostEvents {
        #[allow(missing_docs)]
        Approval(Approval),
        #[allow(missing_docs)]
        ApprovalForAll(ApprovalForAll),
        #[allow(missing_docs)]
        BoostMinted(BoostMinted),
        #[allow(missing_docs)]
        RoleAdminChanged(RoleAdminChanged),
        #[allow(missing_docs)]
        RoleGranted(RoleGranted),
        #[allow(missing_docs)]
        RoleRevoked(RoleRevoked),
        #[allow(missing_docs)]
        SetCreated(SetCreated),
        #[allow(missing_docs)]
        Transfer(Transfer),
    }
    impl HoprBoostEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                17u8, 73u8, 122u8, 131u8, 73u8, 81u8, 9u8, 84u8, 105u8, 147u8, 14u8,
                198u8, 46u8, 22u8, 65u8, 240u8, 220u8, 243u8, 97u8, 125u8, 156u8, 215u8,
                87u8, 155u8, 109u8, 167u8, 110u8, 84u8, 223u8, 48u8, 0u8, 167u8,
            ],
            [
                23u8, 48u8, 126u8, 171u8, 57u8, 171u8, 97u8, 7u8, 232u8, 137u8, 152u8,
                69u8, 173u8, 61u8, 89u8, 189u8, 150u8, 83u8, 242u8, 0u8, 242u8, 32u8,
                146u8, 4u8, 137u8, 202u8, 43u8, 89u8, 55u8, 105u8, 108u8, 49u8,
            ],
            [
                47u8, 135u8, 136u8, 17u8, 126u8, 126u8, 255u8, 29u8, 130u8, 233u8, 38u8,
                236u8, 121u8, 73u8, 1u8, 209u8, 124u8, 120u8, 2u8, 74u8, 80u8, 39u8, 9u8,
                64u8, 48u8, 69u8, 64u8, 167u8, 51u8, 101u8, 111u8, 13u8,
            ],
            [
                115u8, 94u8, 94u8, 181u8, 175u8, 221u8, 114u8, 204u8, 100u8, 101u8,
                125u8, 237u8, 126u8, 93u8, 227u8, 144u8, 175u8, 55u8, 8u8, 175u8, 181u8,
                185u8, 168u8, 11u8, 14u8, 92u8, 145u8, 26u8, 4u8, 153u8, 217u8, 143u8,
            ],
            [
                140u8, 91u8, 225u8, 229u8, 235u8, 236u8, 125u8, 91u8, 209u8, 79u8, 113u8,
                66u8, 125u8, 30u8, 132u8, 243u8, 221u8, 3u8, 20u8, 192u8, 247u8, 178u8,
                41u8, 30u8, 91u8, 32u8, 10u8, 200u8, 199u8, 195u8, 185u8, 37u8,
            ],
            [
                189u8, 121u8, 184u8, 111u8, 254u8, 10u8, 184u8, 232u8, 119u8, 97u8, 81u8,
                81u8, 66u8, 23u8, 205u8, 124u8, 172u8, 213u8, 44u8, 144u8, 159u8, 102u8,
                71u8, 92u8, 58u8, 244u8, 78u8, 18u8, 159u8, 11u8, 0u8, 255u8,
            ],
            [
                221u8, 242u8, 82u8, 173u8, 27u8, 226u8, 200u8, 155u8, 105u8, 194u8,
                176u8, 104u8, 252u8, 55u8, 141u8, 170u8, 149u8, 43u8, 167u8, 241u8, 99u8,
                196u8, 161u8, 22u8, 40u8, 245u8, 90u8, 77u8, 245u8, 35u8, 179u8, 239u8,
            ],
            [
                246u8, 57u8, 31u8, 92u8, 50u8, 217u8, 198u8, 157u8, 42u8, 71u8, 234u8,
                103u8, 11u8, 68u8, 41u8, 116u8, 181u8, 57u8, 53u8, 209u8, 237u8, 199u8,
                253u8, 100u8, 235u8, 33u8, 224u8, 71u8, 168u8, 57u8, 23u8, 27u8,
            ],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(SetCreated),
            ::core::stringify!(ApprovalForAll),
            ::core::stringify!(RoleGranted),
            ::core::stringify!(BoostMinted),
            ::core::stringify!(Approval),
            ::core::stringify!(RoleAdminChanged),
            ::core::stringify!(Transfer),
            ::core::stringify!(RoleRevoked),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <SetCreated as alloy_sol_types::SolEvent>::SIGNATURE,
            <ApprovalForAll as alloy_sol_types::SolEvent>::SIGNATURE,
            <RoleGranted as alloy_sol_types::SolEvent>::SIGNATURE,
            <BoostMinted as alloy_sol_types::SolEvent>::SIGNATURE,
            <Approval as alloy_sol_types::SolEvent>::SIGNATURE,
            <RoleAdminChanged as alloy_sol_types::SolEvent>::SIGNATURE,
            <Transfer as alloy_sol_types::SolEvent>::SIGNATURE,
            <RoleRevoked as alloy_sol_types::SolEvent>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 32usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 32usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for HoprBoostEvents {
        const NAME: &'static str = "HoprBoostEvents";
        const COUNT: usize = 8usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<Approval as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Approval as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::Approval)
                }
                Some(<ApprovalForAll as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <ApprovalForAll as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::ApprovalForAll)
                }
                Some(<BoostMinted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <BoostMinted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::BoostMinted)
                }
                Some(<RoleAdminChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleAdminChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RoleAdminChanged)
                }
                Some(<RoleGranted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleGranted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RoleGranted)
                }
                Some(<RoleRevoked as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleRevoked as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RoleRevoked)
                }
                Some(<SetCreated as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <SetCreated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::SetCreated)
                }
                Some(<Transfer as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Transfer as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::Transfer)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for HoprBoostEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Approval(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ApprovalForAll(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BoostMinted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::SetCreated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Transfer(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Approval(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ApprovalForAll(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BoostMinted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::SetCreated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Transfer(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`HoprBoost`](self) contract instance.

See the [wrapper's documentation](`HoprBoostInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        __provider: P,
    ) -> HoprBoostInstance<P, N> {
        HoprBoostInstance::<P, N>::new(address, __provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        __provider: P,
        newAdmin: alloy::sol_types::private::Address,
        baseTokenURI: alloy::sol_types::private::String,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<HoprBoostInstance<P, N>>,
    > {
        HoprBoostInstance::<P, N>::deploy(__provider, newAdmin, baseTokenURI)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        __provider: P,
        newAdmin: alloy::sol_types::private::Address,
        baseTokenURI: alloy::sol_types::private::String,
    ) -> alloy_contract::RawCallBuilder<P, N> {
        HoprBoostInstance::<P, N>::deploy_builder(__provider, newAdmin, baseTokenURI)
    }
    /**A [`HoprBoost`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`HoprBoost`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct HoprBoostInstance<P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for HoprBoostInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("HoprBoostInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > HoprBoostInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`HoprBoost`](self) contract instance.

See the [wrapper's documentation](`HoprBoostInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            __provider: P,
        ) -> Self {
            Self {
                address,
                provider: __provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            __provider: P,
            newAdmin: alloy::sol_types::private::Address,
            baseTokenURI: alloy::sol_types::private::String,
        ) -> alloy_contract::Result<HoprBoostInstance<P, N>> {
            let call_builder = Self::deploy_builder(__provider, newAdmin, baseTokenURI);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            __provider: P,
            newAdmin: alloy::sol_types::private::Address,
            baseTokenURI: alloy::sol_types::private::String,
        ) -> alloy_contract::RawCallBuilder<P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                __provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall {
                            newAdmin,
                            baseTokenURI,
                        },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> HoprBoostInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> HoprBoostInstance<P, N> {
            HoprBoostInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > HoprBoostInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`DEFAULT_ADMIN_ROLE`] function.
        pub fn DEFAULT_ADMIN_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, DEFAULT_ADMIN_ROLECall, N> {
            self.call_builder(&DEFAULT_ADMIN_ROLECall)
        }
        ///Creates a new call builder for the [`MINTER_ROLE`] function.
        pub fn MINTER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, MINTER_ROLECall, N> {
            self.call_builder(&MINTER_ROLECall)
        }
        ///Creates a new call builder for the [`approve`] function.
        pub fn approve(
            &self,
            to: alloy::sol_types::private::Address,
            tokenId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, approveCall, N> {
            self.call_builder(&approveCall { to, tokenId })
        }
        ///Creates a new call builder for the [`balanceOf`] function.
        pub fn balanceOf(
            &self,
            owner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, balanceOfCall, N> {
            self.call_builder(&balanceOfCall { owner })
        }
        ///Creates a new call builder for the [`batchMint`] function.
        pub fn batchMint(
            &self,
            to: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            boostType: alloy::sol_types::private::String,
            boostRank: alloy::sol_types::private::String,
            boostNumerator: alloy::sol_types::private::primitives::aliases::U256,
            redeemDeadline: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, batchMintCall, N> {
            self.call_builder(
                &batchMintCall {
                    to,
                    boostType,
                    boostRank,
                    boostNumerator,
                    redeemDeadline,
                },
            )
        }
        ///Creates a new call builder for the [`boostOf`] function.
        pub fn boostOf(
            &self,
            tokenId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, boostOfCall, N> {
            self.call_builder(&boostOfCall { tokenId })
        }
        ///Creates a new call builder for the [`getApproved`] function.
        pub fn getApproved(
            &self,
            tokenId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getApprovedCall, N> {
            self.call_builder(&getApprovedCall { tokenId })
        }
        ///Creates a new call builder for the [`getRoleAdmin`] function.
        pub fn getRoleAdmin(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, getRoleAdminCall, N> {
            self.call_builder(&getRoleAdminCall { role })
        }
        ///Creates a new call builder for the [`getRoleMember`] function.
        pub fn getRoleMember(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            index: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getRoleMemberCall, N> {
            self.call_builder(&getRoleMemberCall { role, index })
        }
        ///Creates a new call builder for the [`getRoleMemberCount`] function.
        pub fn getRoleMemberCount(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, getRoleMemberCountCall, N> {
            self.call_builder(&getRoleMemberCountCall { role })
        }
        ///Creates a new call builder for the [`grantRole`] function.
        pub fn grantRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, grantRoleCall, N> {
            self.call_builder(&grantRoleCall { role, account })
        }
        ///Creates a new call builder for the [`hasRole`] function.
        pub fn hasRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, hasRoleCall, N> {
            self.call_builder(&hasRoleCall { role, account })
        }
        ///Creates a new call builder for the [`isApprovedForAll`] function.
        pub fn isApprovedForAll(
            &self,
            owner: alloy::sol_types::private::Address,
            operator: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, isApprovedForAllCall, N> {
            self.call_builder(
                &isApprovedForAllCall {
                    owner,
                    operator,
                },
            )
        }
        ///Creates a new call builder for the [`mint`] function.
        pub fn mint(
            &self,
            to: alloy::sol_types::private::Address,
            boostType: alloy::sol_types::private::String,
            boostRank: alloy::sol_types::private::String,
            boostNumerator: alloy::sol_types::private::primitives::aliases::U256,
            redeemDeadline: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, mintCall, N> {
            self.call_builder(
                &mintCall {
                    to,
                    boostType,
                    boostRank,
                    boostNumerator,
                    redeemDeadline,
                },
            )
        }
        ///Creates a new call builder for the [`name`] function.
        pub fn name(&self) -> alloy_contract::SolCallBuilder<&P, nameCall, N> {
            self.call_builder(&nameCall)
        }
        ///Creates a new call builder for the [`ownerOf`] function.
        pub fn ownerOf(
            &self,
            tokenId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, ownerOfCall, N> {
            self.call_builder(&ownerOfCall { tokenId })
        }
        ///Creates a new call builder for the [`reclaimErc20Tokens`] function.
        pub fn reclaimErc20Tokens(
            &self,
            tokenAddress: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, reclaimErc20TokensCall, N> {
            self.call_builder(
                &reclaimErc20TokensCall {
                    tokenAddress,
                },
            )
        }
        ///Creates a new call builder for the [`reclaimErc721Tokens`] function.
        pub fn reclaimErc721Tokens(
            &self,
            tokenAddress: alloy::sol_types::private::Address,
            tokenId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, reclaimErc721TokensCall, N> {
            self.call_builder(
                &reclaimErc721TokensCall {
                    tokenAddress,
                    tokenId,
                },
            )
        }
        ///Creates a new call builder for the [`renounceRole`] function.
        pub fn renounceRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, renounceRoleCall, N> {
            self.call_builder(&renounceRoleCall { role, account })
        }
        ///Creates a new call builder for the [`revokeRole`] function.
        pub fn revokeRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, revokeRoleCall, N> {
            self.call_builder(&revokeRoleCall { role, account })
        }
        ///Creates a new call builder for the [`safeTransferFrom_0`] function.
        pub fn safeTransferFrom_0(
            &self,
            from: alloy::sol_types::private::Address,
            to: alloy::sol_types::private::Address,
            tokenId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, safeTransferFrom_0Call, N> {
            self.call_builder(
                &safeTransferFrom_0Call {
                    from,
                    to,
                    tokenId,
                },
            )
        }
        ///Creates a new call builder for the [`safeTransferFrom_1`] function.
        pub fn safeTransferFrom_1(
            &self,
            from: alloy::sol_types::private::Address,
            to: alloy::sol_types::private::Address,
            tokenId: alloy::sol_types::private::primitives::aliases::U256,
            _data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<&P, safeTransferFrom_1Call, N> {
            self.call_builder(
                &safeTransferFrom_1Call {
                    from,
                    to,
                    tokenId,
                    _data,
                },
            )
        }
        ///Creates a new call builder for the [`setApprovalForAll`] function.
        pub fn setApprovalForAll(
            &self,
            operator: alloy::sol_types::private::Address,
            approved: bool,
        ) -> alloy_contract::SolCallBuilder<&P, setApprovalForAllCall, N> {
            self.call_builder(
                &setApprovalForAllCall {
                    operator,
                    approved,
                },
            )
        }
        ///Creates a new call builder for the [`supportsInterface`] function.
        pub fn supportsInterface(
            &self,
            interfaceId: alloy::sol_types::private::FixedBytes<4>,
        ) -> alloy_contract::SolCallBuilder<&P, supportsInterfaceCall, N> {
            self.call_builder(
                &supportsInterfaceCall {
                    interfaceId,
                },
            )
        }
        ///Creates a new call builder for the [`symbol`] function.
        pub fn symbol(&self) -> alloy_contract::SolCallBuilder<&P, symbolCall, N> {
            self.call_builder(&symbolCall)
        }
        ///Creates a new call builder for the [`tokenByIndex`] function.
        pub fn tokenByIndex(
            &self,
            index: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, tokenByIndexCall, N> {
            self.call_builder(&tokenByIndexCall { index })
        }
        ///Creates a new call builder for the [`tokenOfOwnerByIndex`] function.
        pub fn tokenOfOwnerByIndex(
            &self,
            owner: alloy::sol_types::private::Address,
            index: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, tokenOfOwnerByIndexCall, N> {
            self.call_builder(
                &tokenOfOwnerByIndexCall {
                    owner,
                    index,
                },
            )
        }
        ///Creates a new call builder for the [`tokenURI`] function.
        pub fn tokenURI(
            &self,
            tokenId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, tokenURICall, N> {
            self.call_builder(&tokenURICall { tokenId })
        }
        ///Creates a new call builder for the [`totalSupply`] function.
        pub fn totalSupply(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, totalSupplyCall, N> {
            self.call_builder(&totalSupplyCall)
        }
        ///Creates a new call builder for the [`transferFrom`] function.
        pub fn transferFrom(
            &self,
            from: alloy::sol_types::private::Address,
            to: alloy::sol_types::private::Address,
            tokenId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, transferFromCall, N> {
            self.call_builder(
                &transferFromCall {
                    from,
                    to,
                    tokenId,
                },
            )
        }
        ///Creates a new call builder for the [`typeAt`] function.
        pub fn typeAt(
            &self,
            typeIndex: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, typeAtCall, N> {
            self.call_builder(&typeAtCall { typeIndex })
        }
        ///Creates a new call builder for the [`typeIndexOf`] function.
        pub fn typeIndexOf(
            &self,
            tokenId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, typeIndexOfCall, N> {
            self.call_builder(&typeIndexOfCall { tokenId })
        }
        ///Creates a new call builder for the [`typeOf`] function.
        pub fn typeOf(
            &self,
            tokenId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, typeOfCall, N> {
            self.call_builder(&typeOfCall { tokenId })
        }
        ///Creates a new call builder for the [`updateBaseURI`] function.
        pub fn updateBaseURI(
            &self,
            baseTokenURI: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<&P, updateBaseURICall, N> {
            self.call_builder(&updateBaseURICall { baseTokenURI })
        }
    }
    /// Event filters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > HoprBoostInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`Approval`] event.
        pub fn Approval_filter(&self) -> alloy_contract::Event<&P, Approval, N> {
            self.event_filter::<Approval>()
        }
        ///Creates a new event filter for the [`ApprovalForAll`] event.
        pub fn ApprovalForAll_filter(
            &self,
        ) -> alloy_contract::Event<&P, ApprovalForAll, N> {
            self.event_filter::<ApprovalForAll>()
        }
        ///Creates a new event filter for the [`BoostMinted`] event.
        pub fn BoostMinted_filter(&self) -> alloy_contract::Event<&P, BoostMinted, N> {
            self.event_filter::<BoostMinted>()
        }
        ///Creates a new event filter for the [`RoleAdminChanged`] event.
        pub fn RoleAdminChanged_filter(
            &self,
        ) -> alloy_contract::Event<&P, RoleAdminChanged, N> {
            self.event_filter::<RoleAdminChanged>()
        }
        ///Creates a new event filter for the [`RoleGranted`] event.
        pub fn RoleGranted_filter(&self) -> alloy_contract::Event<&P, RoleGranted, N> {
            self.event_filter::<RoleGranted>()
        }
        ///Creates a new event filter for the [`RoleRevoked`] event.
        pub fn RoleRevoked_filter(&self) -> alloy_contract::Event<&P, RoleRevoked, N> {
            self.event_filter::<RoleRevoked>()
        }
        ///Creates a new event filter for the [`SetCreated`] event.
        pub fn SetCreated_filter(&self) -> alloy_contract::Event<&P, SetCreated, N> {
            self.event_filter::<SetCreated>()
        }
        ///Creates a new event filter for the [`Transfer`] event.
        pub fn Transfer_filter(&self) -> alloy_contract::Event<&P, Transfer, N> {
            self.event_filter::<Transfer>()
        }
    }
}
