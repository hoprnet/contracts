/**

Generated by the following Solidity interface...
```solidity
interface HoprAnnouncements {
    type KeyId is uint32;
    struct KeyBindingWithSignature {
        bytes32 ed25519_sig_0;
        bytes32 ed25519_sig_1;
        bytes32 ed25519_pub_key;
        address chain_key;
    }

    error AddressEmptyCode(address target);
    error AlreadyInitialized();
    error ContractNotResponsible();
    error EmptyMultiaddr();
    error ExistingKeyBinding();
    error FailedCall();
    error InvalidSafeAddress();
    error KeyIdOutOfRange();
    error MultiSigUninitialized();
    error ZeroAddress(string reason);
    error ZeroInterval();

    event AddressAnnouncement(address node, string baseMultiaddr);
    event KeyBinding(bytes32 ed25519_sig_0, bytes32 ed25519_sig_1, bytes32 ed25519_pub_key, address chain_key);
    event LedgerDomainSeparatorUpdated(bytes32 indexed ledgerDomainSeparator);
    event RevokeAnnouncement(address node);

    constructor(address safeRegistry);

    function LEDGER_VERSION() external view returns (string memory);
    function SNAPSHOT_INTERVAL() external view returns (uint256);
    function announce(string memory baseMultiaddr) external;
    function announceSafe(address selfAddress, string memory baseMultiaddr) external;
    function bindKeys(bytes32 ed25519_sig_0, bytes32 ed25519_sig_1, bytes32 ed25519_pub_key) external;
    function bindKeysAnnounce(bytes32 ed25519_sig_0, bytes32 ed25519_sig_1, bytes32 ed25519_pub_key, string memory baseMultiaddr) external;
    function bindKeysAnnounceSafe(address selfAddress, bytes32 ed25519_sig_0, bytes32 ed25519_sig_1, bytes32 ed25519_pub_key, string memory baseMultiaddr) external;
    function bindKeysSafe(address selfAddress, bytes32 ed25519_sig_0, bytes32 ed25519_sig_1, bytes32 ed25519_pub_key) external;
    function getAllKeyBindings() external view returns (KeyBindingWithSignature[] memory);
    function getKeyBindingCount() external view returns (uint256);
    function getKeyBindingWithKeyId(KeyId keyId) external view returns (KeyBindingWithSignature memory);
    function getKeyIdRange() external pure returns (uint32 minKeyId, uint32 maxKeyId);
    function getKeyIdWithOffchainKey(bytes32 ed25519_pub_key) external view returns (bool, KeyId);
    function getOffchainKeyWithKeyId(KeyId keyId) external view returns (bytes32 ed25519_pub_key);
    function isOffchainKeyBound(bytes32 ed25519_pub_key) external view returns (bool);
    function latestRoot() external view returns (bytes28 rootHash, uint32 timestamp);
    function latestSnapshotRoot() external view returns (bytes28 rootHash, uint32 timestamp);
    function ledgerDomainSeparator() external view returns (bytes32);
    function multiaddrOf(address) external view returns (string memory);
    function multicall(bytes[] memory data) external returns (bytes[] memory results);
    function revoke() external;
    function revokeSafe(address selfAddress) external;
    function tryGetKeyBinding(bytes32 ed25519_pub_key) external view returns (bool, KeyId, KeyBindingWithSignature memory);
    function updateLedgerDomainSeparator() external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "safeRegistry",
        "type": "address",
        "internalType": "contract HoprNodeSafeRegistry"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "LEDGER_VERSION",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "SNAPSHOT_INTERVAL",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "announce",
    "inputs": [
      {
        "name": "baseMultiaddr",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "announceSafe",
    "inputs": [
      {
        "name": "selfAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "baseMultiaddr",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "bindKeys",
    "inputs": [
      {
        "name": "ed25519_sig_0",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "ed25519_sig_1",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "ed25519_pub_key",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "bindKeysAnnounce",
    "inputs": [
      {
        "name": "ed25519_sig_0",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "ed25519_sig_1",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "ed25519_pub_key",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "baseMultiaddr",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "bindKeysAnnounceSafe",
    "inputs": [
      {
        "name": "selfAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "ed25519_sig_0",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "ed25519_sig_1",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "ed25519_pub_key",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "baseMultiaddr",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "bindKeysSafe",
    "inputs": [
      {
        "name": "selfAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "ed25519_sig_0",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "ed25519_sig_1",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "ed25519_pub_key",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "getAllKeyBindings",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "tuple[]",
        "internalType": "struct KeyBindingWithSignature[]",
        "components": [
          {
            "name": "ed25519_sig_0",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "ed25519_sig_1",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "ed25519_pub_key",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "chain_key",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getKeyBindingCount",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getKeyBindingWithKeyId",
    "inputs": [
      {
        "name": "keyId",
        "type": "uint32",
        "internalType": "KeyId"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct KeyBindingWithSignature",
        "components": [
          {
            "name": "ed25519_sig_0",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "ed25519_sig_1",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "ed25519_pub_key",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "chain_key",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getKeyIdRange",
    "inputs": [],
    "outputs": [
      {
        "name": "minKeyId",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "maxKeyId",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "getKeyIdWithOffchainKey",
    "inputs": [
      {
        "name": "ed25519_pub_key",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      },
      {
        "name": "",
        "type": "uint32",
        "internalType": "KeyId"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getOffchainKeyWithKeyId",
    "inputs": [
      {
        "name": "keyId",
        "type": "uint32",
        "internalType": "KeyId"
      }
    ],
    "outputs": [
      {
        "name": "ed25519_pub_key",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isOffchainKeyBound",
    "inputs": [
      {
        "name": "ed25519_pub_key",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "latestRoot",
    "inputs": [],
    "outputs": [
      {
        "name": "rootHash",
        "type": "bytes28",
        "internalType": "bytes28"
      },
      {
        "name": "timestamp",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "latestSnapshotRoot",
    "inputs": [],
    "outputs": [
      {
        "name": "rootHash",
        "type": "bytes28",
        "internalType": "bytes28"
      },
      {
        "name": "timestamp",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "ledgerDomainSeparator",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "multiaddrOf",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "multicall",
    "inputs": [
      {
        "name": "data",
        "type": "bytes[]",
        "internalType": "bytes[]"
      }
    ],
    "outputs": [
      {
        "name": "results",
        "type": "bytes[]",
        "internalType": "bytes[]"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "revoke",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "revokeSafe",
    "inputs": [
      {
        "name": "selfAddress",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "tryGetKeyBinding",
    "inputs": [
      {
        "name": "ed25519_pub_key",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      },
      {
        "name": "",
        "type": "uint32",
        "internalType": "KeyId"
      },
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct KeyBindingWithSignature",
        "components": [
          {
            "name": "ed25519_sig_0",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "ed25519_sig_1",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "ed25519_pub_key",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "chain_key",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "updateLedgerDomainSeparator",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "AddressAnnouncement",
    "inputs": [
      {
        "name": "node",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "baseMultiaddr",
        "type": "string",
        "indexed": false,
        "internalType": "string"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "KeyBinding",
    "inputs": [
      {
        "name": "ed25519_sig_0",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "ed25519_sig_1",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "ed25519_pub_key",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "chain_key",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "LedgerDomainSeparatorUpdated",
    "inputs": [
      {
        "name": "ledgerDomainSeparator",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RevokeAnnouncement",
    "inputs": [
      {
        "name": "node",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AddressEmptyCode",
    "inputs": [
      {
        "name": "target",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "AlreadyInitialized",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ContractNotResponsible",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyMultiaddr",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ExistingKeyBinding",
    "inputs": []
  },
  {
    "type": "error",
    "name": "FailedCall",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidSafeAddress",
    "inputs": []
  },
  {
    "type": "error",
    "name": "KeyIdOutOfRange",
    "inputs": []
  },
  {
    "type": "error",
    "name": "MultiSigUninitialized",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ZeroAddress",
    "inputs": [
      {
        "name": "reason",
        "type": "string",
        "internalType": "string"
      }
    ]
  },
  {
    "type": "error",
    "name": "ZeroInterval",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod HoprAnnouncements {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60a06040525f805460ff60a01b1916905534801561001b575f5ffd5b50604051611eaf380380611eaf83398101604081905261003a9161028f565b6201518060808190526040516001600160601b03193060601b16602082015260340160408051808303601f190181529190528051602091820120901c600160e01b4263ffffffff90811682029290921760018190556001600160e01b0380821691839004909316909102176002556100b29061011d16565b506001600160a01b03811661010e5760405163eac0d38960e01b815260206004820152601e60248201527f736166655265676973747279206d757374206e6f7420626520656d7074790000604482015260640160405180910390fd5b61011781610217565b506102bc565b604080518082018252600a8152692437b8392632b233b2b960b11b6020918201528151808301835260058152640322e302e360dc1b9082015281517f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f81527f6cd681790c78c220517b099a737f8e85f69e797abe4e2910fb189b61db4bf2cd918101919091527fb4bcb154e38601c389396fa918314da42d4626f13ef6d0ceb07e5f5d26b2fbc39181019190915246606082015230608082015260a09020600354811461021457600381905560405181907fa43fad83920fd09445855e854e73c9c532e17402c9ceb09993a2392843a5bdb9905f90a25b50565b5f54600160a01b900460ff16156102405760405162dc149f60e41b815260040160405180910390fd5b6001600160a01b0381166102675760405163474ebe2f60e11b815260040160405180910390fd5b5f80546001600160a01b039092166001600160a81b031990921691909117600160a01b179055565b5f6020828403121561029f575f5ffd5b81516001600160a01b03811681146102b5575f5ffd5b9392505050565b608051611bd46102db5f395f818161023a01526112250152611bd45ff3fe608060405234801561000f575f5ffd5b5060043610610153575f3560e01c8063b6549f75116100bf578063ddad190211610079578063ddad190214610354578063ddb9dfc114610378578063ea0a52371461038b578063f83e42921461039e578063f884a9cb146103a6578063fad0e5a2146103b9575f5ffd5b8063b6549f75146102f8578063c966c4fe14610300578063cae2b43414610309578063d7b0fef11461031c578063dbb98d9114610339578063dc96fd501461034c575f5ffd5b80636d2beef1116101105780636d2beef114610235578063773b4a331461025c578063a2a0775614610273578063a8b4eec914610295578063a969635a146102b5578063ac9650d8146102d8575f5ffd5b80630df18f941461015757806310ab52971461019b578063308c712e146101b05780634ac3e4f2146101c557806353665aaa146101e6578063604634c914610206575b5f5ffd5b60025461017490602081901b90600160e01b900463ffffffff1682565b6040805163ffffffff19909316835263ffffffff9091166020830152015b60405180910390f35b6101a36103cc565b60405161019291906114f4565b6101c36101be366004611555565b610456565b005b6101d86101d3366004611570565b610520565b604051908152602001610192565b6101f96101f4366004611555565b610544565b60405161019291906115c1565b6102196102143660046115d3565b6105db565b60408051921515835263ffffffff909116602083015201610192565b6101d87f000000000000000000000000000000000000000000000000000000000000000081565b604080515f815263ffffffff602082015201610192565b6102866102813660046115d3565b6105f7565b604051610192939291906115ea565b6102a86102a3366004611570565b61061f565b6040516101929190611614565b6102c86102c33660046115d3565b610646565b6040519015158152602001610192565b6102eb6102e6366004611622565b61065d565b6040516101929190611693565b6101c3610743565b6101d860035481565b6101c36103173660046116f6565b610808565b60015461017490602081901b90600160e01b900463ffffffff1682565b6101c361034736600461172e565b6108d8565b6101c36109a3565b6101f9604051806040016040528060058152602001640322e302e360dc1b81525081565b6101c361038636600461179c565b610a9d565b6101c361039936600461180a565b610b7a565b6101d8610c3f565b6101c36103b4366004611849565b610c4e565b6101c36103c73660046118a5565b610d1f565b606060045f01805480602002602001604051908101604052809291908181526020015f905b8282101561044d575f84815260209081902060408051608081018252600486029092018054835260018082015484860152600282015492840192909252600301546001600160a01b0316606083015290835290920191016103f1565b50505050905090565b5f548190600160a01b900460ff16610481576040516308a9441960e31b815260040160405180910390fd5b5f546040516302265e3160e61b81526001600160a01b038381166004830152339216906389978c4090602401602060405180830381865afa1580156104c8573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906104ec91906118f6565b6001600160a01b0316146105135760405163acd5a82360e01b815260040160405180910390fd5b61051c82610ded565b5050565b5f63ffffffff80831690610539906004908390610eb116565b604001519392505050565b60066020525f90815260409020805461055c90611911565b80601f016020809104026020016040519081016040528092919081815260200182805461058890611911565b80156105d35780601f106105aa576101008083540402835291602001916105d3565b820191905f5260205f20905b8154815290600101906020018083116105b657829003601f168201915b505050505081565b5f8080806105ea600486610f1e565b5090969095509350505050565b5f5f610601611451565b5f808061060f600488610f1e565b9199909850909650945050505050565b610627611451565b63ffffffff8083169061063f906004908390610eb116565b9392505050565b5f8181526005602052604081205415155b92915050565b604080515f8152602081019091526060908267ffffffffffffffff81111561068757610687611970565b6040519080825280602002602001820160405280156106ba57816020015b60608152602001906001900390816106a55790505b5091505f5b8381101561073b57610716308686848181106106dd576106dd611984565b90506020028101906106ef9190611998565b85604051602001610702939291906119f2565b604051602081830303815290604052610ff5565b83828151811061072857610728611984565b60209081029190910101526001016106bf565b505092915050565b5f54600160a01b900460ff1661076c576040516308a9441960e31b815260040160405180910390fd5b5f80546040516302265e3160e61b81523360048201526001600160a01b03909116906389978c4090602401602060405180830381865afa1580156107b2573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906107d691906118f6565b6001600160a01b0316146107fd5760405163acd5a82360e01b815260040160405180910390fd5b61080633610ded565b565b5f548490600160a01b900460ff16610833576040516308a9441960e31b815260040160405180910390fd5b5f546040516302265e3160e61b81526001600160a01b038381166004830152339216906389978c4090602401602060405180830381865afa15801561087a573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061089e91906118f6565b6001600160a01b0316146108c55760405163acd5a82360e01b815260040160405180910390fd5b6108d185858585611067565b5050505050565b5f54600160a01b900460ff16610901576040516308a9441960e31b815260040160405180910390fd5b5f80546040516302265e3160e61b81523360048201526001600160a01b03909116906389978c4090602401602060405180830381865afa158015610947573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061096b91906118f6565b6001600160a01b0316146109925760405163acd5a82360e01b815260040160405180910390fd5b61099e33848484611067565b505050565b604080518082018252600a8152692437b8392632b233b2b960b11b6020918201528151808301835260058152640322e302e360dc1b9082015281517f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f81527f6cd681790c78c220517b099a737f8e85f69e797abe4e2910fb189b61db4bf2cd918101919091527fb4bcb154e38601c389396fa918314da42d4626f13ef6d0ceb07e5f5d26b2fbc39181019190915246606082015230608082015260a090206003548114610a9a57600381905560405181907fa43fad83920fd09445855e854e73c9c532e17402c9ceb09993a2392843a5bdb9905f90a25b50565b5f548690600160a01b900460ff16610ac8576040516308a9441960e31b815260040160405180910390fd5b5f546040516302265e3160e61b81526001600160a01b038381166004830152339216906389978c4090602401602060405180830381865afa158015610b0f573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610b3391906118f6565b6001600160a01b031614610b5a5760405163acd5a82360e01b815260040160405180910390fd5b610b6687878787611067565b610b7187848461115d565b50505050505050565b5f54600160a01b900460ff16610ba3576040516308a9441960e31b815260040160405180910390fd5b5f80546040516302265e3160e61b81523360048201526001600160a01b03909116906389978c4090602401602060405180830381865afa158015610be9573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610c0d91906118f6565b6001600160a01b031614610c345760405163acd5a82360e01b815260040160405180910390fd5b61051c33838361115d565b5f610c4960045490565b905090565b5f54600160a01b900460ff16610c77576040516308a9441960e31b815260040160405180910390fd5b5f80546040516302265e3160e61b81523360048201526001600160a01b03909116906389978c4090602401602060405180830381865afa158015610cbd573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610ce191906118f6565b6001600160a01b031614610d085760405163acd5a82360e01b815260040160405180910390fd5b610d1433868686611067565b6108d133838361115d565b5f548390600160a01b900460ff16610d4a576040516308a9441960e31b815260040160405180910390fd5b5f546040516302265e3160e61b81526001600160a01b038381166004830152339216906389978c4090602401602060405180830381865afa158015610d91573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610db591906118f6565b6001600160a01b031614610ddc5760405163acd5a82360e01b815260040160405180910390fd5b610de784848461115d565b50505050565b6001600160a01b0381165f908152600660205260408120610e0d9161147e565b610e727fa4de30a528becadf82649d1395c0e30dd18ae35b5a96ce71e9295bb14bc9f3bc82604051602001610e5e92919091825260601b6bffffffffffffffffffffffff1916602082015260340190565b60405160208183030381529060405261121a565b6040516001600160a01b03821681527fa4de30a528becadf82649d1395c0e30dd18ae35b5a96ce71e9295bb14bc9f3bc9060200160405180910390a150565b610eb9611451565b825f018281548110610ecd57610ecd611984565b5f918252602091829020604080516080810182526004909302909101805483526001810154938301939093526002830154908201526003909101546001600160a01b03166060820152905092915050565b5f5f610f28611451565b5f84815260018601602052604081205490819003610f6f575050604080516080810182525f8082526020820181905291810182905260608101829052909250829150610fee565b6001610f7b818361195d565b87610f8760018561195d565b81548110610f9757610f97611984565b5f918252602091829020604080516080810182526004909302909101805483526001810154938301939093526002830154908201526003909101546001600160a01b0316606082015291955093509150610fee9050565b9250925092565b60605f5f846001600160a01b0316846040516110119190611a11565b5f60405180830381855af49150503d805f8114611049576040519150601f19603f3d011682016040523d82523d5f602084013e61104e565b606091505b509150915061105e8583836112ff565b95945050505050565b6110a46040518060800160405280858152602001848152602001838152602001866001600160a01b0316815250600461135f90919063ffffffff16565b50604080517fbf49ccd41a4118c7e1e72143bad844e5f6ed12bf60caa642d88d19ca10244c36602082015290810184905260608082018490526080820183905285901b6bffffffffffffffffffffffff191660a08201526111079060b401610e5e565b60408051848152602081018490529081018290526001600160a01b03851660608201527fbf49ccd41a4118c7e1e72143bad844e5f6ed12bf60caa642d88d19ca10244c369060800160405180910390a150505050565b5f81900361117d57604051629ceac760e41b815260040160405180910390fd5b6001600160a01b0383165f90815260066020526040902061119f828483611a60565b506111da7fc4df5ba16814838ab2618829d68f8623bb897302f24dbdba2279dbe45adb3d14848484604051602001610e5e9493929190611b1a565b7fc4df5ba16814838ab2618829d68f8623bb897302f24dbdba2279dbe45adb3d1483838360405161120d93929190611b4c565b60405180910390a1505050565b6001545f90611257907f000000000000000000000000000000000000000000000000000000000000000090600160e01b900463ffffffff16611b8b565b421115611262575060015b600354600154835160208086019190912060408051808401959095524360e01b6001600160e01b0319169085015291901b63ffffffff19166044830152606082015260800160408051601f19818403018152919052805160209182012063ffffffff4216600160e01b02911c17600155801561051c5750506001546001600160e01b038116600160e01b9182900463ffffffff1690910217600255565b6060826113145761130f82611429565b61063f565b815115801561132b57506001600160a01b0384163b155b1561135857604051639996b31560e01b81526001600160a01b038516600482015260240160405180910390fd5b5092915050565b81545f9063ffffffff11611386576040516310953bff60e11b815260040160405180910390fd5b6040808301515f908152600185016020522054156113b65760405162584c6f60e51b815260040160405180910390fd5b8254600180820185555f858152602080822086516004909502019384558581015184840155604080870151600286018190556060880151600390960180546001600160a01b0319166001600160a01b03909716969096179095558754948352838801909152902082905561063f9161195d565b80511561143857805160208201fd5b60405163d6bda27560e01b815260040160405180910390fd5b60405180608001604052805f81526020015f81526020015f81526020015f6001600160a01b031681525090565b50805461148a90611911565b5f825580601f10611499575050565b601f0160209004905f5260205f2090810190610a9a91905b808211156114c4575f81556001016114b1565b5090565b8051825260208082015190830152604080820151908301526060908101516001600160a01b0316910152565b602080825282518282018190525f918401906040840190835b81811015611536576115208385516114c8565b602093909301926080929092019160010161150d565b509095945050505050565b6001600160a01b0381168114610a9a575f5ffd5b5f60208284031215611565575f5ffd5b813561063f81611541565b5f60208284031215611580575f5ffd5b813563ffffffff8116811461063f575f5ffd5b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b602081525f61063f6020830184611593565b5f602082840312156115e3575f5ffd5b5035919050565b831515815263ffffffff8316602082015260c0810161160c60408301846114c8565b949350505050565b6080810161065782846114c8565b5f5f60208385031215611633575f5ffd5b823567ffffffffffffffff811115611649575f5ffd5b8301601f81018513611659575f5ffd5b803567ffffffffffffffff81111561166f575f5ffd5b8560208260051b8401011115611683575f5ffd5b6020919091019590945092505050565b5f602082016020835280845180835260408501915060408160051b8601019250602086015f5b828110156116ea57603f198786030184526116d5858351611593565b945060209384019391909101906001016116b9565b50929695505050505050565b5f5f5f5f60808587031215611709575f5ffd5b843561171481611541565b966020860135965060408601359560600135945092505050565b5f5f5f60608486031215611740575f5ffd5b505081359360208301359350604090920135919050565b5f5f83601f840112611767575f5ffd5b50813567ffffffffffffffff81111561177e575f5ffd5b602083019150836020828501011115611795575f5ffd5b9250929050565b5f5f5f5f5f5f60a087890312156117b1575f5ffd5b86356117bc81611541565b9550602087013594506040870135935060608701359250608087013567ffffffffffffffff8111156117ec575f5ffd5b6117f889828a01611757565b979a9699509497509295939492505050565b5f5f6020838503121561181b575f5ffd5b823567ffffffffffffffff811115611831575f5ffd5b61183d85828601611757565b90969095509350505050565b5f5f5f5f5f6080868803121561185d575f5ffd5b853594506020860135935060408601359250606086013567ffffffffffffffff811115611888575f5ffd5b61189488828901611757565b969995985093965092949392505050565b5f5f5f604084860312156118b7575f5ffd5b83356118c281611541565b9250602084013567ffffffffffffffff8111156118dd575f5ffd5b6118e986828701611757565b9497909650939450505050565b5f60208284031215611906575f5ffd5b815161063f81611541565b600181811c9082168061192557607f821691505b60208210810361194357634e487b7160e01b5f52602260045260245ffd5b50919050565b634e487b7160e01b5f52601160045260245ffd5b8181038181111561065757610657611949565b634e487b7160e01b5f52604160045260245ffd5b634e487b7160e01b5f52603260045260245ffd5b5f5f8335601e198436030181126119ad575f5ffd5b83018035915067ffffffffffffffff8211156119c7575f5ffd5b602001915036819003821315611795575f5ffd5b5f81518060208401855e5f93019283525090919050565b828482375f8382015f8152611a0781856119db565b9695505050505050565b5f61063f82846119db565b601f82111561099e57805f5260205f20601f840160051c81016020851015611a415750805b601f840160051c820191505b818110156108d1575f8155600101611a4d565b67ffffffffffffffff831115611a7857611a78611970565b611a8c83611a868354611911565b83611a1c565b5f601f841160018114611abd575f8515611aa65750838201355b5f19600387901b1c1916600186901b1783556108d1565b5f83815260208120601f198716915b82811015611aec5786850135825560209485019460019092019101611acc565b5086821015611b08575f1960f88860031b161c19848701351681555b505060018560011b0183555050505050565b8481526bffffffffffffffffffffffff198460601b166020820152818360348301375f91016034019081529392505050565b6001600160a01b03841681526040602082018190528101829052818360608301375f818301606090810191909152601f909201601f1916010192915050565b808201808211156106575761065761194956fea26469706673582212203e2d5bfee7d6592b86e506310420e998d133c7736d8a6f783d8b19bd9371469164736f6c634300081e0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\xA0`@R_\x80T`\xFF`\xA0\x1B\x19\x16\x90U4\x80\x15a\0\x1BW__\xFD[P`@Qa\x1E\xAF8\x03\x80a\x1E\xAF\x839\x81\x01`@\x81\x90Ra\0:\x91a\x02\x8FV[b\x01Q\x80`\x80\x81\x90R`@Q`\x01`\x01``\x1B\x03\x190``\x1B\x16` \x82\x01R`4\x01`@\x80Q\x80\x83\x03`\x1F\x19\x01\x81R\x91\x90R\x80Q` \x91\x82\x01 \x90\x1C`\x01`\xE0\x1BBc\xFF\xFF\xFF\xFF\x90\x81\x16\x82\x02\x92\x90\x92\x17`\x01\x81\x90U`\x01`\x01`\xE0\x1B\x03\x80\x82\x16\x91\x83\x90\x04\x90\x93\x16\x90\x91\x02\x17`\x02Ua\0\xB2\x90a\x01\x1D\x16V[P`\x01`\x01`\xA0\x1B\x03\x81\x16a\x01\x0EW`@Qc\xEA\xC0\xD3\x89`\xE0\x1B\x81R` `\x04\x82\x01R`\x1E`$\x82\x01R\x7FsafeRegistry must not be empty\0\0`D\x82\x01R`d\x01`@Q\x80\x91\x03\x90\xFD[a\x01\x17\x81a\x02\x17V[Pa\x02\xBCV[`@\x80Q\x80\x82\x01\x82R`\n\x81Ri$7\xB89&2\xB23\xB2\xB9`\xB1\x1B` \x91\x82\x01R\x81Q\x80\x83\x01\x83R`\x05\x81Rd\x03\"\xE3\x02\xE3`\xDC\x1B\x90\x82\x01R\x81Q\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x81R\x7Fl\xD6\x81y\x0Cx\xC2 Q{\t\x9As\x7F\x8E\x85\xF6\x9Eyz\xBEN)\x10\xFB\x18\x9Ba\xDBK\xF2\xCD\x91\x81\x01\x91\x90\x91R\x7F\xB4\xBC\xB1T\xE3\x86\x01\xC3\x899o\xA9\x181M\xA4-F&\xF1>\xF6\xD0\xCE\xB0~_]&\xB2\xFB\xC3\x91\x81\x01\x91\x90\x91RF``\x82\x01R0`\x80\x82\x01R`\xA0\x90 `\x03T\x81\x14a\x02\x14W`\x03\x81\x90U`@Q\x81\x90\x7F\xA4?\xAD\x83\x92\x0F\xD0\x94E\x85^\x85Ns\xC9\xC52\xE1t\x02\xC9\xCE\xB0\x99\x93\xA29(C\xA5\xBD\xB9\x90_\x90\xA2[PV[_T`\x01`\xA0\x1B\x90\x04`\xFF\x16\x15a\x02@W`@Qb\xDC\x14\x9F`\xE4\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x01`\x01`\xA0\x1B\x03\x81\x16a\x02gW`@QcGN\xBE/`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80T`\x01`\x01`\xA0\x1B\x03\x90\x92\x16`\x01`\x01`\xA8\x1B\x03\x19\x90\x92\x16\x91\x90\x91\x17`\x01`\xA0\x1B\x17\x90UV[_` \x82\x84\x03\x12\x15a\x02\x9FW__\xFD[\x81Q`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x02\xB5W__\xFD[\x93\x92PPPV[`\x80Qa\x1B\xD4a\x02\xDB_9_\x81\x81a\x02:\x01Ra\x12%\x01Ra\x1B\xD4_\xF3\xFE`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\x01SW_5`\xE0\x1C\x80c\xB6T\x9Fu\x11a\0\xBFW\x80c\xDD\xAD\x19\x02\x11a\0yW\x80c\xDD\xAD\x19\x02\x14a\x03TW\x80c\xDD\xB9\xDF\xC1\x14a\x03xW\x80c\xEA\nR7\x14a\x03\x8BW\x80c\xF8>B\x92\x14a\x03\x9EW\x80c\xF8\x84\xA9\xCB\x14a\x03\xA6W\x80c\xFA\xD0\xE5\xA2\x14a\x03\xB9W__\xFD[\x80c\xB6T\x9Fu\x14a\x02\xF8W\x80c\xC9f\xC4\xFE\x14a\x03\0W\x80c\xCA\xE2\xB44\x14a\x03\tW\x80c\xD7\xB0\xFE\xF1\x14a\x03\x1CW\x80c\xDB\xB9\x8D\x91\x14a\x039W\x80c\xDC\x96\xFDP\x14a\x03LW__\xFD[\x80cm+\xEE\xF1\x11a\x01\x10W\x80cm+\xEE\xF1\x14a\x025W\x80cw;J3\x14a\x02\\W\x80c\xA2\xA0wV\x14a\x02sW\x80c\xA8\xB4\xEE\xC9\x14a\x02\x95W\x80c\xA9icZ\x14a\x02\xB5W\x80c\xAC\x96P\xD8\x14a\x02\xD8W__\xFD[\x80c\r\xF1\x8F\x94\x14a\x01WW\x80c\x10\xABR\x97\x14a\x01\x9BW\x80c0\x8Cq.\x14a\x01\xB0W\x80cJ\xC3\xE4\xF2\x14a\x01\xC5W\x80cSfZ\xAA\x14a\x01\xE6W\x80c`F4\xC9\x14a\x02\x06W[__\xFD[`\x02Ta\x01t\x90` \x81\x90\x1B\x90`\x01`\xE0\x1B\x90\x04c\xFF\xFF\xFF\xFF\x16\x82V[`@\x80Qc\xFF\xFF\xFF\xFF\x19\x90\x93\x16\x83Rc\xFF\xFF\xFF\xFF\x90\x91\x16` \x83\x01R\x01[`@Q\x80\x91\x03\x90\xF3[a\x01\xA3a\x03\xCCV[`@Qa\x01\x92\x91\x90a\x14\xF4V[a\x01\xC3a\x01\xBE6`\x04a\x15UV[a\x04VV[\0[a\x01\xD8a\x01\xD36`\x04a\x15pV[a\x05 V[`@Q\x90\x81R` \x01a\x01\x92V[a\x01\xF9a\x01\xF46`\x04a\x15UV[a\x05DV[`@Qa\x01\x92\x91\x90a\x15\xC1V[a\x02\x19a\x02\x146`\x04a\x15\xD3V[a\x05\xDBV[`@\x80Q\x92\x15\x15\x83Rc\xFF\xFF\xFF\xFF\x90\x91\x16` \x83\x01R\x01a\x01\x92V[a\x01\xD8\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`@\x80Q_\x81Rc\xFF\xFF\xFF\xFF` \x82\x01R\x01a\x01\x92V[a\x02\x86a\x02\x816`\x04a\x15\xD3V[a\x05\xF7V[`@Qa\x01\x92\x93\x92\x91\x90a\x15\xEAV[a\x02\xA8a\x02\xA36`\x04a\x15pV[a\x06\x1FV[`@Qa\x01\x92\x91\x90a\x16\x14V[a\x02\xC8a\x02\xC36`\x04a\x15\xD3V[a\x06FV[`@Q\x90\x15\x15\x81R` \x01a\x01\x92V[a\x02\xEBa\x02\xE66`\x04a\x16\"V[a\x06]V[`@Qa\x01\x92\x91\x90a\x16\x93V[a\x01\xC3a\x07CV[a\x01\xD8`\x03T\x81V[a\x01\xC3a\x03\x176`\x04a\x16\xF6V[a\x08\x08V[`\x01Ta\x01t\x90` \x81\x90\x1B\x90`\x01`\xE0\x1B\x90\x04c\xFF\xFF\xFF\xFF\x16\x82V[a\x01\xC3a\x03G6`\x04a\x17.V[a\x08\xD8V[a\x01\xC3a\t\xA3V[a\x01\xF9`@Q\x80`@\x01`@R\x80`\x05\x81R` \x01d\x03\"\xE3\x02\xE3`\xDC\x1B\x81RP\x81V[a\x01\xC3a\x03\x866`\x04a\x17\x9CV[a\n\x9DV[a\x01\xC3a\x03\x996`\x04a\x18\nV[a\x0BzV[a\x01\xD8a\x0C?V[a\x01\xC3a\x03\xB46`\x04a\x18IV[a\x0CNV[a\x01\xC3a\x03\xC76`\x04a\x18\xA5V[a\r\x1FV[```\x04_\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01_\x90[\x82\x82\x10\x15a\x04MW_\x84\x81R` \x90\x81\x90 `@\x80Q`\x80\x81\x01\x82R`\x04\x86\x02\x90\x92\x01\x80T\x83R`\x01\x80\x82\x01T\x84\x86\x01R`\x02\x82\x01T\x92\x84\x01\x92\x90\x92R`\x03\x01T`\x01`\x01`\xA0\x1B\x03\x16``\x83\x01R\x90\x83R\x90\x92\x01\x91\x01a\x03\xF1V[PPPP\x90P\x90V[_T\x81\x90`\x01`\xA0\x1B\x90\x04`\xFF\x16a\x04\x81W`@Qc\x08\xA9D\x19`\xE3\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_T`@Qc\x02&^1`\xE6\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\x04\x83\x01R3\x92\x16\x90c\x89\x97\x8C@\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x04\xC8W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x04\xEC\x91\x90a\x18\xF6V[`\x01`\x01`\xA0\x1B\x03\x16\x14a\x05\x13W`@Qc\xAC\xD5\xA8#`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x05\x1C\x82a\r\xEDV[PPV[_c\xFF\xFF\xFF\xFF\x80\x83\x16\x90a\x059\x90`\x04\x90\x83\x90a\x0E\xB1\x16V[`@\x01Q\x93\x92PPPV[`\x06` R_\x90\x81R`@\x90 \x80Ta\x05\\\x90a\x19\x11V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x05\x88\x90a\x19\x11V[\x80\x15a\x05\xD3W\x80`\x1F\x10a\x05\xAAWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x05\xD3V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x05\xB6W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81V[_\x80\x80\x80a\x05\xEA`\x04\x86a\x0F\x1EV[P\x90\x96\x90\x95P\x93PPPPV[__a\x06\x01a\x14QV[_\x80\x80a\x06\x0F`\x04\x88a\x0F\x1EV[\x91\x99\x90\x98P\x90\x96P\x94PPPPPV[a\x06'a\x14QV[c\xFF\xFF\xFF\xFF\x80\x83\x16\x90a\x06?\x90`\x04\x90\x83\x90a\x0E\xB1\x16V[\x93\x92PPPV[_\x81\x81R`\x05` R`@\x81 T\x15\x15[\x92\x91PPV[`@\x80Q_\x81R` \x81\x01\x90\x91R``\x90\x82g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x06\x87Wa\x06\x87a\x19pV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x06\xBAW\x81` \x01[``\x81R` \x01\x90`\x01\x90\x03\x90\x81a\x06\xA5W\x90P[P\x91P_[\x83\x81\x10\x15a\x07;Wa\x07\x160\x86\x86\x84\x81\x81\x10a\x06\xDDWa\x06\xDDa\x19\x84V[\x90P` \x02\x81\x01\x90a\x06\xEF\x91\x90a\x19\x98V[\x85`@Q` \x01a\x07\x02\x93\x92\x91\x90a\x19\xF2V[`@Q` \x81\x83\x03\x03\x81R\x90`@Ra\x0F\xF5V[\x83\x82\x81Q\x81\x10a\x07(Wa\x07(a\x19\x84V[` \x90\x81\x02\x91\x90\x91\x01\x01R`\x01\x01a\x06\xBFV[PP\x92\x91PPV[_T`\x01`\xA0\x1B\x90\x04`\xFF\x16a\x07lW`@Qc\x08\xA9D\x19`\xE3\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80T`@Qc\x02&^1`\xE6\x1B\x81R3`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90c\x89\x97\x8C@\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x07\xB2W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x07\xD6\x91\x90a\x18\xF6V[`\x01`\x01`\xA0\x1B\x03\x16\x14a\x07\xFDW`@Qc\xAC\xD5\xA8#`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x08\x063a\r\xEDV[V[_T\x84\x90`\x01`\xA0\x1B\x90\x04`\xFF\x16a\x083W`@Qc\x08\xA9D\x19`\xE3\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_T`@Qc\x02&^1`\xE6\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\x04\x83\x01R3\x92\x16\x90c\x89\x97\x8C@\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x08zW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x08\x9E\x91\x90a\x18\xF6V[`\x01`\x01`\xA0\x1B\x03\x16\x14a\x08\xC5W`@Qc\xAC\xD5\xA8#`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x08\xD1\x85\x85\x85\x85a\x10gV[PPPPPV[_T`\x01`\xA0\x1B\x90\x04`\xFF\x16a\t\x01W`@Qc\x08\xA9D\x19`\xE3\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80T`@Qc\x02&^1`\xE6\x1B\x81R3`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90c\x89\x97\x8C@\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\tGW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\tk\x91\x90a\x18\xF6V[`\x01`\x01`\xA0\x1B\x03\x16\x14a\t\x92W`@Qc\xAC\xD5\xA8#`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\t\x9E3\x84\x84\x84a\x10gV[PPPV[`@\x80Q\x80\x82\x01\x82R`\n\x81Ri$7\xB89&2\xB23\xB2\xB9`\xB1\x1B` \x91\x82\x01R\x81Q\x80\x83\x01\x83R`\x05\x81Rd\x03\"\xE3\x02\xE3`\xDC\x1B\x90\x82\x01R\x81Q\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x81R\x7Fl\xD6\x81y\x0Cx\xC2 Q{\t\x9As\x7F\x8E\x85\xF6\x9Eyz\xBEN)\x10\xFB\x18\x9Ba\xDBK\xF2\xCD\x91\x81\x01\x91\x90\x91R\x7F\xB4\xBC\xB1T\xE3\x86\x01\xC3\x899o\xA9\x181M\xA4-F&\xF1>\xF6\xD0\xCE\xB0~_]&\xB2\xFB\xC3\x91\x81\x01\x91\x90\x91RF``\x82\x01R0`\x80\x82\x01R`\xA0\x90 `\x03T\x81\x14a\n\x9AW`\x03\x81\x90U`@Q\x81\x90\x7F\xA4?\xAD\x83\x92\x0F\xD0\x94E\x85^\x85Ns\xC9\xC52\xE1t\x02\xC9\xCE\xB0\x99\x93\xA29(C\xA5\xBD\xB9\x90_\x90\xA2[PV[_T\x86\x90`\x01`\xA0\x1B\x90\x04`\xFF\x16a\n\xC8W`@Qc\x08\xA9D\x19`\xE3\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_T`@Qc\x02&^1`\xE6\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\x04\x83\x01R3\x92\x16\x90c\x89\x97\x8C@\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0B\x0FW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0B3\x91\x90a\x18\xF6V[`\x01`\x01`\xA0\x1B\x03\x16\x14a\x0BZW`@Qc\xAC\xD5\xA8#`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x0Bf\x87\x87\x87\x87a\x10gV[a\x0Bq\x87\x84\x84a\x11]V[PPPPPPPV[_T`\x01`\xA0\x1B\x90\x04`\xFF\x16a\x0B\xA3W`@Qc\x08\xA9D\x19`\xE3\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80T`@Qc\x02&^1`\xE6\x1B\x81R3`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90c\x89\x97\x8C@\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0B\xE9W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0C\r\x91\x90a\x18\xF6V[`\x01`\x01`\xA0\x1B\x03\x16\x14a\x0C4W`@Qc\xAC\xD5\xA8#`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x05\x1C3\x83\x83a\x11]V[_a\x0CI`\x04T\x90V[\x90P\x90V[_T`\x01`\xA0\x1B\x90\x04`\xFF\x16a\x0CwW`@Qc\x08\xA9D\x19`\xE3\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80T`@Qc\x02&^1`\xE6\x1B\x81R3`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90c\x89\x97\x8C@\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0C\xBDW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0C\xE1\x91\x90a\x18\xF6V[`\x01`\x01`\xA0\x1B\x03\x16\x14a\r\x08W`@Qc\xAC\xD5\xA8#`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\r\x143\x86\x86\x86a\x10gV[a\x08\xD13\x83\x83a\x11]V[_T\x83\x90`\x01`\xA0\x1B\x90\x04`\xFF\x16a\rJW`@Qc\x08\xA9D\x19`\xE3\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_T`@Qc\x02&^1`\xE6\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\x04\x83\x01R3\x92\x16\x90c\x89\x97\x8C@\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\r\x91W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\r\xB5\x91\x90a\x18\xF6V[`\x01`\x01`\xA0\x1B\x03\x16\x14a\r\xDCW`@Qc\xAC\xD5\xA8#`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\r\xE7\x84\x84\x84a\x11]V[PPPPV[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R`\x06` R`@\x81 a\x0E\r\x91a\x14~V[a\x0Er\x7F\xA4\xDE0\xA5(\xBE\xCA\xDF\x82d\x9D\x13\x95\xC0\xE3\r\xD1\x8A\xE3[Z\x96\xCEq\xE9)[\xB1K\xC9\xF3\xBC\x82`@Q` \x01a\x0E^\x92\x91\x90\x91\x82R``\x1Bk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16` \x82\x01R`4\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@Ra\x12\x1AV[`@Q`\x01`\x01`\xA0\x1B\x03\x82\x16\x81R\x7F\xA4\xDE0\xA5(\xBE\xCA\xDF\x82d\x9D\x13\x95\xC0\xE3\r\xD1\x8A\xE3[Z\x96\xCEq\xE9)[\xB1K\xC9\xF3\xBC\x90` \x01`@Q\x80\x91\x03\x90\xA1PV[a\x0E\xB9a\x14QV[\x82_\x01\x82\x81T\x81\x10a\x0E\xCDWa\x0E\xCDa\x19\x84V[_\x91\x82R` \x91\x82\x90 `@\x80Q`\x80\x81\x01\x82R`\x04\x90\x93\x02\x90\x91\x01\x80T\x83R`\x01\x81\x01T\x93\x83\x01\x93\x90\x93R`\x02\x83\x01T\x90\x82\x01R`\x03\x90\x91\x01T`\x01`\x01`\xA0\x1B\x03\x16``\x82\x01R\x90P\x92\x91PPV[__a\x0F(a\x14QV[_\x84\x81R`\x01\x86\x01` R`@\x81 T\x90\x81\x90\x03a\x0FoWPP`@\x80Q`\x80\x81\x01\x82R_\x80\x82R` \x82\x01\x81\x90R\x91\x81\x01\x82\x90R``\x81\x01\x82\x90R\x90\x92P\x82\x91Pa\x0F\xEEV[`\x01a\x0F{\x81\x83a\x19]V[\x87a\x0F\x87`\x01\x85a\x19]V[\x81T\x81\x10a\x0F\x97Wa\x0F\x97a\x19\x84V[_\x91\x82R` \x91\x82\x90 `@\x80Q`\x80\x81\x01\x82R`\x04\x90\x93\x02\x90\x91\x01\x80T\x83R`\x01\x81\x01T\x93\x83\x01\x93\x90\x93R`\x02\x83\x01T\x90\x82\x01R`\x03\x90\x91\x01T`\x01`\x01`\xA0\x1B\x03\x16``\x82\x01R\x91\x95P\x93P\x91Pa\x0F\xEE\x90PV[\x92P\x92P\x92V[``__\x84`\x01`\x01`\xA0\x1B\x03\x16\x84`@Qa\x10\x11\x91\x90a\x1A\x11V[_`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80_\x81\x14a\x10IW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\x10NV[``\x91P[P\x91P\x91Pa\x10^\x85\x83\x83a\x12\xFFV[\x95\x94PPPPPV[a\x10\xA4`@Q\x80`\x80\x01`@R\x80\x85\x81R` \x01\x84\x81R` \x01\x83\x81R` \x01\x86`\x01`\x01`\xA0\x1B\x03\x16\x81RP`\x04a\x13_\x90\x91\x90c\xFF\xFF\xFF\xFF\x16V[P`@\x80Q\x7F\xBFI\xCC\xD4\x1AA\x18\xC7\xE1\xE7!C\xBA\xD8D\xE5\xF6\xED\x12\xBF`\xCA\xA6B\xD8\x8D\x19\xCA\x10$L6` \x82\x01R\x90\x81\x01\x84\x90R``\x80\x82\x01\x84\x90R`\x80\x82\x01\x83\x90R\x85\x90\x1Bk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16`\xA0\x82\x01Ra\x11\x07\x90`\xB4\x01a\x0E^V[`@\x80Q\x84\x81R` \x81\x01\x84\x90R\x90\x81\x01\x82\x90R`\x01`\x01`\xA0\x1B\x03\x85\x16``\x82\x01R\x7F\xBFI\xCC\xD4\x1AA\x18\xC7\xE1\xE7!C\xBA\xD8D\xE5\xF6\xED\x12\xBF`\xCA\xA6B\xD8\x8D\x19\xCA\x10$L6\x90`\x80\x01`@Q\x80\x91\x03\x90\xA1PPPPV[_\x81\x90\x03a\x11}W`@Qb\x9C\xEA\xC7`\xE4\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x01`\x01`\xA0\x1B\x03\x83\x16_\x90\x81R`\x06` R`@\x90 a\x11\x9F\x82\x84\x83a\x1A`V[Pa\x11\xDA\x7F\xC4\xDF[\xA1h\x14\x83\x8A\xB2a\x88)\xD6\x8F\x86#\xBB\x89s\x02\xF2M\xBD\xBA\"y\xDB\xE4Z\xDB=\x14\x84\x84\x84`@Q` \x01a\x0E^\x94\x93\x92\x91\x90a\x1B\x1AV[\x7F\xC4\xDF[\xA1h\x14\x83\x8A\xB2a\x88)\xD6\x8F\x86#\xBB\x89s\x02\xF2M\xBD\xBA\"y\xDB\xE4Z\xDB=\x14\x83\x83\x83`@Qa\x12\r\x93\x92\x91\x90a\x1BLV[`@Q\x80\x91\x03\x90\xA1PPPV[`\x01T_\x90a\x12W\x90\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90`\x01`\xE0\x1B\x90\x04c\xFF\xFF\xFF\xFF\x16a\x1B\x8BV[B\x11\x15a\x12bWP`\x01[`\x03T`\x01T\x83Q` \x80\x86\x01\x91\x90\x91 `@\x80Q\x80\x84\x01\x95\x90\x95RC`\xE0\x1B`\x01`\x01`\xE0\x1B\x03\x19\x16\x90\x85\x01R\x91\x90\x1Bc\xFF\xFF\xFF\xFF\x19\x16`D\x83\x01R``\x82\x01R`\x80\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R\x80Q` \x91\x82\x01 c\xFF\xFF\xFF\xFFB\x16`\x01`\xE0\x1B\x02\x91\x1C\x17`\x01U\x80\x15a\x05\x1CWPP`\x01T`\x01`\x01`\xE0\x1B\x03\x81\x16`\x01`\xE0\x1B\x91\x82\x90\x04c\xFF\xFF\xFF\xFF\x16\x90\x91\x02\x17`\x02UV[``\x82a\x13\x14Wa\x13\x0F\x82a\x14)V[a\x06?V[\x81Q\x15\x80\x15a\x13+WP`\x01`\x01`\xA0\x1B\x03\x84\x16;\x15[\x15a\x13XW`@Qc\x99\x96\xB3\x15`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x85\x16`\x04\x82\x01R`$\x01`@Q\x80\x91\x03\x90\xFD[P\x92\x91PPV[\x81T_\x90c\xFF\xFF\xFF\xFF\x11a\x13\x86W`@Qc\x10\x95;\xFF`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@\x80\x83\x01Q_\x90\x81R`\x01\x85\x01` R T\x15a\x13\xB6W`@QbXLo`\xE5\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x82T`\x01\x80\x82\x01\x85U_\x85\x81R` \x80\x82 \x86Q`\x04\x90\x95\x02\x01\x93\x84U\x85\x81\x01Q\x84\x84\x01U`@\x80\x87\x01Q`\x02\x86\x01\x81\x90U``\x88\x01Q`\x03\x90\x96\x01\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x90\x97\x16\x96\x90\x96\x17\x90\x95U\x87T\x94\x83R\x83\x88\x01\x90\x91R\x90 \x82\x90Ua\x06?\x91a\x19]V[\x80Q\x15a\x148W\x80Q` \x82\x01\xFD[`@Qc\xD6\xBD\xA2u`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@Q\x80`\x80\x01`@R\x80_\x81R` \x01_\x81R` \x01_\x81R` \x01_`\x01`\x01`\xA0\x1B\x03\x16\x81RP\x90V[P\x80Ta\x14\x8A\x90a\x19\x11V[_\x82U\x80`\x1F\x10a\x14\x99WPPV[`\x1F\x01` \x90\x04\x90_R` _ \x90\x81\x01\x90a\n\x9A\x91\x90[\x80\x82\x11\x15a\x14\xC4W_\x81U`\x01\x01a\x14\xB1V[P\x90V[\x80Q\x82R` \x80\x82\x01Q\x90\x83\x01R`@\x80\x82\x01Q\x90\x83\x01R``\x90\x81\x01Q`\x01`\x01`\xA0\x1B\x03\x16\x91\x01RV[` \x80\x82R\x82Q\x82\x82\x01\x81\x90R_\x91\x84\x01\x90`@\x84\x01\x90\x83[\x81\x81\x10\x15a\x156Wa\x15 \x83\x85Qa\x14\xC8V[` \x93\x90\x93\x01\x92`\x80\x92\x90\x92\x01\x91`\x01\x01a\x15\rV[P\x90\x95\x94PPPPPV[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\n\x9AW__\xFD[_` \x82\x84\x03\x12\x15a\x15eW__\xFD[\x815a\x06?\x81a\x15AV[_` \x82\x84\x03\x12\x15a\x15\x80W__\xFD[\x815c\xFF\xFF\xFF\xFF\x81\x16\x81\x14a\x06?W__\xFD[_\x81Q\x80\x84R\x80` \x84\x01` \x86\x01^_` \x82\x86\x01\x01R` `\x1F\x19`\x1F\x83\x01\x16\x85\x01\x01\x91PP\x92\x91PPV[` \x81R_a\x06?` \x83\x01\x84a\x15\x93V[_` \x82\x84\x03\x12\x15a\x15\xE3W__\xFD[P5\x91\x90PV[\x83\x15\x15\x81Rc\xFF\xFF\xFF\xFF\x83\x16` \x82\x01R`\xC0\x81\x01a\x16\x0C`@\x83\x01\x84a\x14\xC8V[\x94\x93PPPPV[`\x80\x81\x01a\x06W\x82\x84a\x14\xC8V[__` \x83\x85\x03\x12\x15a\x163W__\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x16IW__\xFD[\x83\x01`\x1F\x81\x01\x85\x13a\x16YW__\xFD[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x16oW__\xFD[\x85` \x82`\x05\x1B\x84\x01\x01\x11\x15a\x16\x83W__\xFD[` \x91\x90\x91\x01\x95\x90\x94P\x92PPPV[_` \x82\x01` \x83R\x80\x84Q\x80\x83R`@\x85\x01\x91P`@\x81`\x05\x1B\x86\x01\x01\x92P` \x86\x01_[\x82\x81\x10\x15a\x16\xEAW`?\x19\x87\x86\x03\x01\x84Ra\x16\xD5\x85\x83Qa\x15\x93V[\x94P` \x93\x84\x01\x93\x91\x90\x91\x01\x90`\x01\x01a\x16\xB9V[P\x92\x96\x95PPPPPPV[____`\x80\x85\x87\x03\x12\x15a\x17\tW__\xFD[\x845a\x17\x14\x81a\x15AV[\x96` \x86\x015\x96P`@\x86\x015\x95``\x015\x94P\x92PPPV[___``\x84\x86\x03\x12\x15a\x17@W__\xFD[PP\x815\x93` \x83\x015\x93P`@\x90\x92\x015\x91\x90PV[__\x83`\x1F\x84\x01\x12a\x17gW__\xFD[P\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x17~W__\xFD[` \x83\x01\x91P\x83` \x82\x85\x01\x01\x11\x15a\x17\x95W__\xFD[\x92P\x92\x90PV[______`\xA0\x87\x89\x03\x12\x15a\x17\xB1W__\xFD[\x865a\x17\xBC\x81a\x15AV[\x95P` \x87\x015\x94P`@\x87\x015\x93P``\x87\x015\x92P`\x80\x87\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x17\xECW__\xFD[a\x17\xF8\x89\x82\x8A\x01a\x17WV[\x97\x9A\x96\x99P\x94\x97P\x92\x95\x93\x94\x92PPPV[__` \x83\x85\x03\x12\x15a\x18\x1BW__\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x181W__\xFD[a\x18=\x85\x82\x86\x01a\x17WV[\x90\x96\x90\x95P\x93PPPPV[_____`\x80\x86\x88\x03\x12\x15a\x18]W__\xFD[\x855\x94P` \x86\x015\x93P`@\x86\x015\x92P``\x86\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x18\x88W__\xFD[a\x18\x94\x88\x82\x89\x01a\x17WV[\x96\x99\x95\x98P\x93\x96P\x92\x94\x93\x92PPPV[___`@\x84\x86\x03\x12\x15a\x18\xB7W__\xFD[\x835a\x18\xC2\x81a\x15AV[\x92P` \x84\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x18\xDDW__\xFD[a\x18\xE9\x86\x82\x87\x01a\x17WV[\x94\x97\x90\x96P\x93\x94PPPPV[_` \x82\x84\x03\x12\x15a\x19\x06W__\xFD[\x81Qa\x06?\x81a\x15AV[`\x01\x81\x81\x1C\x90\x82\x16\x80a\x19%W`\x7F\x82\x16\x91P[` \x82\x10\x81\x03a\x19CWcNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[P\x91\x90PV[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[\x81\x81\x03\x81\x81\x11\x15a\x06WWa\x06Wa\x19IV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[__\x835`\x1E\x19\x846\x03\x01\x81\x12a\x19\xADW__\xFD[\x83\x01\x805\x91Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a\x19\xC7W__\xFD[` \x01\x91P6\x81\x90\x03\x82\x13\x15a\x17\x95W__\xFD[_\x81Q\x80` \x84\x01\x85^_\x93\x01\x92\x83RP\x90\x91\x90PV[\x82\x84\x827_\x83\x82\x01_\x81Ra\x1A\x07\x81\x85a\x19\xDBV[\x96\x95PPPPPPV[_a\x06?\x82\x84a\x19\xDBV[`\x1F\x82\x11\x15a\t\x9EW\x80_R` _ `\x1F\x84\x01`\x05\x1C\x81\x01` \x85\x10\x15a\x1AAWP\x80[`\x1F\x84\x01`\x05\x1C\x82\x01\x91P[\x81\x81\x10\x15a\x08\xD1W_\x81U`\x01\x01a\x1AMV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11\x15a\x1AxWa\x1Axa\x19pV[a\x1A\x8C\x83a\x1A\x86\x83Ta\x19\x11V[\x83a\x1A\x1CV[_`\x1F\x84\x11`\x01\x81\x14a\x1A\xBDW_\x85\x15a\x1A\xA6WP\x83\x82\x015[_\x19`\x03\x87\x90\x1B\x1C\x19\x16`\x01\x86\x90\x1B\x17\x83Ua\x08\xD1V[_\x83\x81R` \x81 `\x1F\x19\x87\x16\x91[\x82\x81\x10\x15a\x1A\xECW\x86\x85\x015\x82U` \x94\x85\x01\x94`\x01\x90\x92\x01\x91\x01a\x1A\xCCV[P\x86\x82\x10\x15a\x1B\x08W_\x19`\xF8\x88`\x03\x1B\x16\x1C\x19\x84\x87\x015\x16\x81U[PP`\x01\x85`\x01\x1B\x01\x83UPPPPPV[\x84\x81Rk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x84``\x1B\x16` \x82\x01R\x81\x83`4\x83\x017_\x91\x01`4\x01\x90\x81R\x93\x92PPPV[`\x01`\x01`\xA0\x1B\x03\x84\x16\x81R`@` \x82\x01\x81\x90R\x81\x01\x82\x90R\x81\x83``\x83\x017_\x81\x83\x01``\x90\x81\x01\x91\x90\x91R`\x1F\x90\x92\x01`\x1F\x19\x16\x01\x01\x92\x91PPV[\x80\x82\x01\x80\x82\x11\x15a\x06WWa\x06Wa\x19IV\xFE\xA2dipfsX\"\x12 >-[\xFE\xE7\xD6Y+\x86\xE5\x061\x04 \xE9\x98\xD13\xC7sm\x8Aox=\x8B\x19\xBD\x93qF\x91dsolcC\0\x08\x1E\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561000f575f5ffd5b5060043610610153575f3560e01c8063b6549f75116100bf578063ddad190211610079578063ddad190214610354578063ddb9dfc114610378578063ea0a52371461038b578063f83e42921461039e578063f884a9cb146103a6578063fad0e5a2146103b9575f5ffd5b8063b6549f75146102f8578063c966c4fe14610300578063cae2b43414610309578063d7b0fef11461031c578063dbb98d9114610339578063dc96fd501461034c575f5ffd5b80636d2beef1116101105780636d2beef114610235578063773b4a331461025c578063a2a0775614610273578063a8b4eec914610295578063a969635a146102b5578063ac9650d8146102d8575f5ffd5b80630df18f941461015757806310ab52971461019b578063308c712e146101b05780634ac3e4f2146101c557806353665aaa146101e6578063604634c914610206575b5f5ffd5b60025461017490602081901b90600160e01b900463ffffffff1682565b6040805163ffffffff19909316835263ffffffff9091166020830152015b60405180910390f35b6101a36103cc565b60405161019291906114f4565b6101c36101be366004611555565b610456565b005b6101d86101d3366004611570565b610520565b604051908152602001610192565b6101f96101f4366004611555565b610544565b60405161019291906115c1565b6102196102143660046115d3565b6105db565b60408051921515835263ffffffff909116602083015201610192565b6101d87f000000000000000000000000000000000000000000000000000000000000000081565b604080515f815263ffffffff602082015201610192565b6102866102813660046115d3565b6105f7565b604051610192939291906115ea565b6102a86102a3366004611570565b61061f565b6040516101929190611614565b6102c86102c33660046115d3565b610646565b6040519015158152602001610192565b6102eb6102e6366004611622565b61065d565b6040516101929190611693565b6101c3610743565b6101d860035481565b6101c36103173660046116f6565b610808565b60015461017490602081901b90600160e01b900463ffffffff1682565b6101c361034736600461172e565b6108d8565b6101c36109a3565b6101f9604051806040016040528060058152602001640322e302e360dc1b81525081565b6101c361038636600461179c565b610a9d565b6101c361039936600461180a565b610b7a565b6101d8610c3f565b6101c36103b4366004611849565b610c4e565b6101c36103c73660046118a5565b610d1f565b606060045f01805480602002602001604051908101604052809291908181526020015f905b8282101561044d575f84815260209081902060408051608081018252600486029092018054835260018082015484860152600282015492840192909252600301546001600160a01b0316606083015290835290920191016103f1565b50505050905090565b5f548190600160a01b900460ff16610481576040516308a9441960e31b815260040160405180910390fd5b5f546040516302265e3160e61b81526001600160a01b038381166004830152339216906389978c4090602401602060405180830381865afa1580156104c8573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906104ec91906118f6565b6001600160a01b0316146105135760405163acd5a82360e01b815260040160405180910390fd5b61051c82610ded565b5050565b5f63ffffffff80831690610539906004908390610eb116565b604001519392505050565b60066020525f90815260409020805461055c90611911565b80601f016020809104026020016040519081016040528092919081815260200182805461058890611911565b80156105d35780601f106105aa576101008083540402835291602001916105d3565b820191905f5260205f20905b8154815290600101906020018083116105b657829003601f168201915b505050505081565b5f8080806105ea600486610f1e565b5090969095509350505050565b5f5f610601611451565b5f808061060f600488610f1e565b9199909850909650945050505050565b610627611451565b63ffffffff8083169061063f906004908390610eb116565b9392505050565b5f8181526005602052604081205415155b92915050565b604080515f8152602081019091526060908267ffffffffffffffff81111561068757610687611970565b6040519080825280602002602001820160405280156106ba57816020015b60608152602001906001900390816106a55790505b5091505f5b8381101561073b57610716308686848181106106dd576106dd611984565b90506020028101906106ef9190611998565b85604051602001610702939291906119f2565b604051602081830303815290604052610ff5565b83828151811061072857610728611984565b60209081029190910101526001016106bf565b505092915050565b5f54600160a01b900460ff1661076c576040516308a9441960e31b815260040160405180910390fd5b5f80546040516302265e3160e61b81523360048201526001600160a01b03909116906389978c4090602401602060405180830381865afa1580156107b2573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906107d691906118f6565b6001600160a01b0316146107fd5760405163acd5a82360e01b815260040160405180910390fd5b61080633610ded565b565b5f548490600160a01b900460ff16610833576040516308a9441960e31b815260040160405180910390fd5b5f546040516302265e3160e61b81526001600160a01b038381166004830152339216906389978c4090602401602060405180830381865afa15801561087a573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061089e91906118f6565b6001600160a01b0316146108c55760405163acd5a82360e01b815260040160405180910390fd5b6108d185858585611067565b5050505050565b5f54600160a01b900460ff16610901576040516308a9441960e31b815260040160405180910390fd5b5f80546040516302265e3160e61b81523360048201526001600160a01b03909116906389978c4090602401602060405180830381865afa158015610947573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061096b91906118f6565b6001600160a01b0316146109925760405163acd5a82360e01b815260040160405180910390fd5b61099e33848484611067565b505050565b604080518082018252600a8152692437b8392632b233b2b960b11b6020918201528151808301835260058152640322e302e360dc1b9082015281517f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f81527f6cd681790c78c220517b099a737f8e85f69e797abe4e2910fb189b61db4bf2cd918101919091527fb4bcb154e38601c389396fa918314da42d4626f13ef6d0ceb07e5f5d26b2fbc39181019190915246606082015230608082015260a090206003548114610a9a57600381905560405181907fa43fad83920fd09445855e854e73c9c532e17402c9ceb09993a2392843a5bdb9905f90a25b50565b5f548690600160a01b900460ff16610ac8576040516308a9441960e31b815260040160405180910390fd5b5f546040516302265e3160e61b81526001600160a01b038381166004830152339216906389978c4090602401602060405180830381865afa158015610b0f573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610b3391906118f6565b6001600160a01b031614610b5a5760405163acd5a82360e01b815260040160405180910390fd5b610b6687878787611067565b610b7187848461115d565b50505050505050565b5f54600160a01b900460ff16610ba3576040516308a9441960e31b815260040160405180910390fd5b5f80546040516302265e3160e61b81523360048201526001600160a01b03909116906389978c4090602401602060405180830381865afa158015610be9573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610c0d91906118f6565b6001600160a01b031614610c345760405163acd5a82360e01b815260040160405180910390fd5b61051c33838361115d565b5f610c4960045490565b905090565b5f54600160a01b900460ff16610c77576040516308a9441960e31b815260040160405180910390fd5b5f80546040516302265e3160e61b81523360048201526001600160a01b03909116906389978c4090602401602060405180830381865afa158015610cbd573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610ce191906118f6565b6001600160a01b031614610d085760405163acd5a82360e01b815260040160405180910390fd5b610d1433868686611067565b6108d133838361115d565b5f548390600160a01b900460ff16610d4a576040516308a9441960e31b815260040160405180910390fd5b5f546040516302265e3160e61b81526001600160a01b038381166004830152339216906389978c4090602401602060405180830381865afa158015610d91573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610db591906118f6565b6001600160a01b031614610ddc5760405163acd5a82360e01b815260040160405180910390fd5b610de784848461115d565b50505050565b6001600160a01b0381165f908152600660205260408120610e0d9161147e565b610e727fa4de30a528becadf82649d1395c0e30dd18ae35b5a96ce71e9295bb14bc9f3bc82604051602001610e5e92919091825260601b6bffffffffffffffffffffffff1916602082015260340190565b60405160208183030381529060405261121a565b6040516001600160a01b03821681527fa4de30a528becadf82649d1395c0e30dd18ae35b5a96ce71e9295bb14bc9f3bc9060200160405180910390a150565b610eb9611451565b825f018281548110610ecd57610ecd611984565b5f918252602091829020604080516080810182526004909302909101805483526001810154938301939093526002830154908201526003909101546001600160a01b03166060820152905092915050565b5f5f610f28611451565b5f84815260018601602052604081205490819003610f6f575050604080516080810182525f8082526020820181905291810182905260608101829052909250829150610fee565b6001610f7b818361195d565b87610f8760018561195d565b81548110610f9757610f97611984565b5f918252602091829020604080516080810182526004909302909101805483526001810154938301939093526002830154908201526003909101546001600160a01b0316606082015291955093509150610fee9050565b9250925092565b60605f5f846001600160a01b0316846040516110119190611a11565b5f60405180830381855af49150503d805f8114611049576040519150601f19603f3d011682016040523d82523d5f602084013e61104e565b606091505b509150915061105e8583836112ff565b95945050505050565b6110a46040518060800160405280858152602001848152602001838152602001866001600160a01b0316815250600461135f90919063ffffffff16565b50604080517fbf49ccd41a4118c7e1e72143bad844e5f6ed12bf60caa642d88d19ca10244c36602082015290810184905260608082018490526080820183905285901b6bffffffffffffffffffffffff191660a08201526111079060b401610e5e565b60408051848152602081018490529081018290526001600160a01b03851660608201527fbf49ccd41a4118c7e1e72143bad844e5f6ed12bf60caa642d88d19ca10244c369060800160405180910390a150505050565b5f81900361117d57604051629ceac760e41b815260040160405180910390fd5b6001600160a01b0383165f90815260066020526040902061119f828483611a60565b506111da7fc4df5ba16814838ab2618829d68f8623bb897302f24dbdba2279dbe45adb3d14848484604051602001610e5e9493929190611b1a565b7fc4df5ba16814838ab2618829d68f8623bb897302f24dbdba2279dbe45adb3d1483838360405161120d93929190611b4c565b60405180910390a1505050565b6001545f90611257907f000000000000000000000000000000000000000000000000000000000000000090600160e01b900463ffffffff16611b8b565b421115611262575060015b600354600154835160208086019190912060408051808401959095524360e01b6001600160e01b0319169085015291901b63ffffffff19166044830152606082015260800160408051601f19818403018152919052805160209182012063ffffffff4216600160e01b02911c17600155801561051c5750506001546001600160e01b038116600160e01b9182900463ffffffff1690910217600255565b6060826113145761130f82611429565b61063f565b815115801561132b57506001600160a01b0384163b155b1561135857604051639996b31560e01b81526001600160a01b038516600482015260240160405180910390fd5b5092915050565b81545f9063ffffffff11611386576040516310953bff60e11b815260040160405180910390fd5b6040808301515f908152600185016020522054156113b65760405162584c6f60e51b815260040160405180910390fd5b8254600180820185555f858152602080822086516004909502019384558581015184840155604080870151600286018190556060880151600390960180546001600160a01b0319166001600160a01b03909716969096179095558754948352838801909152902082905561063f9161195d565b80511561143857805160208201fd5b60405163d6bda27560e01b815260040160405180910390fd5b60405180608001604052805f81526020015f81526020015f81526020015f6001600160a01b031681525090565b50805461148a90611911565b5f825580601f10611499575050565b601f0160209004905f5260205f2090810190610a9a91905b808211156114c4575f81556001016114b1565b5090565b8051825260208082015190830152604080820151908301526060908101516001600160a01b0316910152565b602080825282518282018190525f918401906040840190835b81811015611536576115208385516114c8565b602093909301926080929092019160010161150d565b509095945050505050565b6001600160a01b0381168114610a9a575f5ffd5b5f60208284031215611565575f5ffd5b813561063f81611541565b5f60208284031215611580575f5ffd5b813563ffffffff8116811461063f575f5ffd5b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b602081525f61063f6020830184611593565b5f602082840312156115e3575f5ffd5b5035919050565b831515815263ffffffff8316602082015260c0810161160c60408301846114c8565b949350505050565b6080810161065782846114c8565b5f5f60208385031215611633575f5ffd5b823567ffffffffffffffff811115611649575f5ffd5b8301601f81018513611659575f5ffd5b803567ffffffffffffffff81111561166f575f5ffd5b8560208260051b8401011115611683575f5ffd5b6020919091019590945092505050565b5f602082016020835280845180835260408501915060408160051b8601019250602086015f5b828110156116ea57603f198786030184526116d5858351611593565b945060209384019391909101906001016116b9565b50929695505050505050565b5f5f5f5f60808587031215611709575f5ffd5b843561171481611541565b966020860135965060408601359560600135945092505050565b5f5f5f60608486031215611740575f5ffd5b505081359360208301359350604090920135919050565b5f5f83601f840112611767575f5ffd5b50813567ffffffffffffffff81111561177e575f5ffd5b602083019150836020828501011115611795575f5ffd5b9250929050565b5f5f5f5f5f5f60a087890312156117b1575f5ffd5b86356117bc81611541565b9550602087013594506040870135935060608701359250608087013567ffffffffffffffff8111156117ec575f5ffd5b6117f889828a01611757565b979a9699509497509295939492505050565b5f5f6020838503121561181b575f5ffd5b823567ffffffffffffffff811115611831575f5ffd5b61183d85828601611757565b90969095509350505050565b5f5f5f5f5f6080868803121561185d575f5ffd5b853594506020860135935060408601359250606086013567ffffffffffffffff811115611888575f5ffd5b61189488828901611757565b969995985093965092949392505050565b5f5f5f604084860312156118b7575f5ffd5b83356118c281611541565b9250602084013567ffffffffffffffff8111156118dd575f5ffd5b6118e986828701611757565b9497909650939450505050565b5f60208284031215611906575f5ffd5b815161063f81611541565b600181811c9082168061192557607f821691505b60208210810361194357634e487b7160e01b5f52602260045260245ffd5b50919050565b634e487b7160e01b5f52601160045260245ffd5b8181038181111561065757610657611949565b634e487b7160e01b5f52604160045260245ffd5b634e487b7160e01b5f52603260045260245ffd5b5f5f8335601e198436030181126119ad575f5ffd5b83018035915067ffffffffffffffff8211156119c7575f5ffd5b602001915036819003821315611795575f5ffd5b5f81518060208401855e5f93019283525090919050565b828482375f8382015f8152611a0781856119db565b9695505050505050565b5f61063f82846119db565b601f82111561099e57805f5260205f20601f840160051c81016020851015611a415750805b601f840160051c820191505b818110156108d1575f8155600101611a4d565b67ffffffffffffffff831115611a7857611a78611970565b611a8c83611a868354611911565b83611a1c565b5f601f841160018114611abd575f8515611aa65750838201355b5f19600387901b1c1916600186901b1783556108d1565b5f83815260208120601f198716915b82811015611aec5786850135825560209485019460019092019101611acc565b5086821015611b08575f1960f88860031b161c19848701351681555b505060018560011b0183555050505050565b8481526bffffffffffffffffffffffff198460601b166020820152818360348301375f91016034019081529392505050565b6001600160a01b03841681526040602082018190528101829052818360608301375f818301606090810191909152601f909201601f1916010192915050565b808201808211156106575761065761194956fea26469706673582212203e2d5bfee7d6592b86e506310420e998d133c7736d8a6f783d8b19bd9371469164736f6c634300081e0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\x01SW_5`\xE0\x1C\x80c\xB6T\x9Fu\x11a\0\xBFW\x80c\xDD\xAD\x19\x02\x11a\0yW\x80c\xDD\xAD\x19\x02\x14a\x03TW\x80c\xDD\xB9\xDF\xC1\x14a\x03xW\x80c\xEA\nR7\x14a\x03\x8BW\x80c\xF8>B\x92\x14a\x03\x9EW\x80c\xF8\x84\xA9\xCB\x14a\x03\xA6W\x80c\xFA\xD0\xE5\xA2\x14a\x03\xB9W__\xFD[\x80c\xB6T\x9Fu\x14a\x02\xF8W\x80c\xC9f\xC4\xFE\x14a\x03\0W\x80c\xCA\xE2\xB44\x14a\x03\tW\x80c\xD7\xB0\xFE\xF1\x14a\x03\x1CW\x80c\xDB\xB9\x8D\x91\x14a\x039W\x80c\xDC\x96\xFDP\x14a\x03LW__\xFD[\x80cm+\xEE\xF1\x11a\x01\x10W\x80cm+\xEE\xF1\x14a\x025W\x80cw;J3\x14a\x02\\W\x80c\xA2\xA0wV\x14a\x02sW\x80c\xA8\xB4\xEE\xC9\x14a\x02\x95W\x80c\xA9icZ\x14a\x02\xB5W\x80c\xAC\x96P\xD8\x14a\x02\xD8W__\xFD[\x80c\r\xF1\x8F\x94\x14a\x01WW\x80c\x10\xABR\x97\x14a\x01\x9BW\x80c0\x8Cq.\x14a\x01\xB0W\x80cJ\xC3\xE4\xF2\x14a\x01\xC5W\x80cSfZ\xAA\x14a\x01\xE6W\x80c`F4\xC9\x14a\x02\x06W[__\xFD[`\x02Ta\x01t\x90` \x81\x90\x1B\x90`\x01`\xE0\x1B\x90\x04c\xFF\xFF\xFF\xFF\x16\x82V[`@\x80Qc\xFF\xFF\xFF\xFF\x19\x90\x93\x16\x83Rc\xFF\xFF\xFF\xFF\x90\x91\x16` \x83\x01R\x01[`@Q\x80\x91\x03\x90\xF3[a\x01\xA3a\x03\xCCV[`@Qa\x01\x92\x91\x90a\x14\xF4V[a\x01\xC3a\x01\xBE6`\x04a\x15UV[a\x04VV[\0[a\x01\xD8a\x01\xD36`\x04a\x15pV[a\x05 V[`@Q\x90\x81R` \x01a\x01\x92V[a\x01\xF9a\x01\xF46`\x04a\x15UV[a\x05DV[`@Qa\x01\x92\x91\x90a\x15\xC1V[a\x02\x19a\x02\x146`\x04a\x15\xD3V[a\x05\xDBV[`@\x80Q\x92\x15\x15\x83Rc\xFF\xFF\xFF\xFF\x90\x91\x16` \x83\x01R\x01a\x01\x92V[a\x01\xD8\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`@\x80Q_\x81Rc\xFF\xFF\xFF\xFF` \x82\x01R\x01a\x01\x92V[a\x02\x86a\x02\x816`\x04a\x15\xD3V[a\x05\xF7V[`@Qa\x01\x92\x93\x92\x91\x90a\x15\xEAV[a\x02\xA8a\x02\xA36`\x04a\x15pV[a\x06\x1FV[`@Qa\x01\x92\x91\x90a\x16\x14V[a\x02\xC8a\x02\xC36`\x04a\x15\xD3V[a\x06FV[`@Q\x90\x15\x15\x81R` \x01a\x01\x92V[a\x02\xEBa\x02\xE66`\x04a\x16\"V[a\x06]V[`@Qa\x01\x92\x91\x90a\x16\x93V[a\x01\xC3a\x07CV[a\x01\xD8`\x03T\x81V[a\x01\xC3a\x03\x176`\x04a\x16\xF6V[a\x08\x08V[`\x01Ta\x01t\x90` \x81\x90\x1B\x90`\x01`\xE0\x1B\x90\x04c\xFF\xFF\xFF\xFF\x16\x82V[a\x01\xC3a\x03G6`\x04a\x17.V[a\x08\xD8V[a\x01\xC3a\t\xA3V[a\x01\xF9`@Q\x80`@\x01`@R\x80`\x05\x81R` \x01d\x03\"\xE3\x02\xE3`\xDC\x1B\x81RP\x81V[a\x01\xC3a\x03\x866`\x04a\x17\x9CV[a\n\x9DV[a\x01\xC3a\x03\x996`\x04a\x18\nV[a\x0BzV[a\x01\xD8a\x0C?V[a\x01\xC3a\x03\xB46`\x04a\x18IV[a\x0CNV[a\x01\xC3a\x03\xC76`\x04a\x18\xA5V[a\r\x1FV[```\x04_\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01_\x90[\x82\x82\x10\x15a\x04MW_\x84\x81R` \x90\x81\x90 `@\x80Q`\x80\x81\x01\x82R`\x04\x86\x02\x90\x92\x01\x80T\x83R`\x01\x80\x82\x01T\x84\x86\x01R`\x02\x82\x01T\x92\x84\x01\x92\x90\x92R`\x03\x01T`\x01`\x01`\xA0\x1B\x03\x16``\x83\x01R\x90\x83R\x90\x92\x01\x91\x01a\x03\xF1V[PPPP\x90P\x90V[_T\x81\x90`\x01`\xA0\x1B\x90\x04`\xFF\x16a\x04\x81W`@Qc\x08\xA9D\x19`\xE3\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_T`@Qc\x02&^1`\xE6\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\x04\x83\x01R3\x92\x16\x90c\x89\x97\x8C@\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x04\xC8W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x04\xEC\x91\x90a\x18\xF6V[`\x01`\x01`\xA0\x1B\x03\x16\x14a\x05\x13W`@Qc\xAC\xD5\xA8#`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x05\x1C\x82a\r\xEDV[PPV[_c\xFF\xFF\xFF\xFF\x80\x83\x16\x90a\x059\x90`\x04\x90\x83\x90a\x0E\xB1\x16V[`@\x01Q\x93\x92PPPV[`\x06` R_\x90\x81R`@\x90 \x80Ta\x05\\\x90a\x19\x11V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x05\x88\x90a\x19\x11V[\x80\x15a\x05\xD3W\x80`\x1F\x10a\x05\xAAWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x05\xD3V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x05\xB6W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81V[_\x80\x80\x80a\x05\xEA`\x04\x86a\x0F\x1EV[P\x90\x96\x90\x95P\x93PPPPV[__a\x06\x01a\x14QV[_\x80\x80a\x06\x0F`\x04\x88a\x0F\x1EV[\x91\x99\x90\x98P\x90\x96P\x94PPPPPV[a\x06'a\x14QV[c\xFF\xFF\xFF\xFF\x80\x83\x16\x90a\x06?\x90`\x04\x90\x83\x90a\x0E\xB1\x16V[\x93\x92PPPV[_\x81\x81R`\x05` R`@\x81 T\x15\x15[\x92\x91PPV[`@\x80Q_\x81R` \x81\x01\x90\x91R``\x90\x82g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x06\x87Wa\x06\x87a\x19pV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x06\xBAW\x81` \x01[``\x81R` \x01\x90`\x01\x90\x03\x90\x81a\x06\xA5W\x90P[P\x91P_[\x83\x81\x10\x15a\x07;Wa\x07\x160\x86\x86\x84\x81\x81\x10a\x06\xDDWa\x06\xDDa\x19\x84V[\x90P` \x02\x81\x01\x90a\x06\xEF\x91\x90a\x19\x98V[\x85`@Q` \x01a\x07\x02\x93\x92\x91\x90a\x19\xF2V[`@Q` \x81\x83\x03\x03\x81R\x90`@Ra\x0F\xF5V[\x83\x82\x81Q\x81\x10a\x07(Wa\x07(a\x19\x84V[` \x90\x81\x02\x91\x90\x91\x01\x01R`\x01\x01a\x06\xBFV[PP\x92\x91PPV[_T`\x01`\xA0\x1B\x90\x04`\xFF\x16a\x07lW`@Qc\x08\xA9D\x19`\xE3\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80T`@Qc\x02&^1`\xE6\x1B\x81R3`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90c\x89\x97\x8C@\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x07\xB2W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x07\xD6\x91\x90a\x18\xF6V[`\x01`\x01`\xA0\x1B\x03\x16\x14a\x07\xFDW`@Qc\xAC\xD5\xA8#`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x08\x063a\r\xEDV[V[_T\x84\x90`\x01`\xA0\x1B\x90\x04`\xFF\x16a\x083W`@Qc\x08\xA9D\x19`\xE3\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_T`@Qc\x02&^1`\xE6\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\x04\x83\x01R3\x92\x16\x90c\x89\x97\x8C@\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x08zW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x08\x9E\x91\x90a\x18\xF6V[`\x01`\x01`\xA0\x1B\x03\x16\x14a\x08\xC5W`@Qc\xAC\xD5\xA8#`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x08\xD1\x85\x85\x85\x85a\x10gV[PPPPPV[_T`\x01`\xA0\x1B\x90\x04`\xFF\x16a\t\x01W`@Qc\x08\xA9D\x19`\xE3\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80T`@Qc\x02&^1`\xE6\x1B\x81R3`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90c\x89\x97\x8C@\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\tGW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\tk\x91\x90a\x18\xF6V[`\x01`\x01`\xA0\x1B\x03\x16\x14a\t\x92W`@Qc\xAC\xD5\xA8#`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\t\x9E3\x84\x84\x84a\x10gV[PPPV[`@\x80Q\x80\x82\x01\x82R`\n\x81Ri$7\xB89&2\xB23\xB2\xB9`\xB1\x1B` \x91\x82\x01R\x81Q\x80\x83\x01\x83R`\x05\x81Rd\x03\"\xE3\x02\xE3`\xDC\x1B\x90\x82\x01R\x81Q\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x81R\x7Fl\xD6\x81y\x0Cx\xC2 Q{\t\x9As\x7F\x8E\x85\xF6\x9Eyz\xBEN)\x10\xFB\x18\x9Ba\xDBK\xF2\xCD\x91\x81\x01\x91\x90\x91R\x7F\xB4\xBC\xB1T\xE3\x86\x01\xC3\x899o\xA9\x181M\xA4-F&\xF1>\xF6\xD0\xCE\xB0~_]&\xB2\xFB\xC3\x91\x81\x01\x91\x90\x91RF``\x82\x01R0`\x80\x82\x01R`\xA0\x90 `\x03T\x81\x14a\n\x9AW`\x03\x81\x90U`@Q\x81\x90\x7F\xA4?\xAD\x83\x92\x0F\xD0\x94E\x85^\x85Ns\xC9\xC52\xE1t\x02\xC9\xCE\xB0\x99\x93\xA29(C\xA5\xBD\xB9\x90_\x90\xA2[PV[_T\x86\x90`\x01`\xA0\x1B\x90\x04`\xFF\x16a\n\xC8W`@Qc\x08\xA9D\x19`\xE3\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_T`@Qc\x02&^1`\xE6\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\x04\x83\x01R3\x92\x16\x90c\x89\x97\x8C@\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0B\x0FW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0B3\x91\x90a\x18\xF6V[`\x01`\x01`\xA0\x1B\x03\x16\x14a\x0BZW`@Qc\xAC\xD5\xA8#`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x0Bf\x87\x87\x87\x87a\x10gV[a\x0Bq\x87\x84\x84a\x11]V[PPPPPPPV[_T`\x01`\xA0\x1B\x90\x04`\xFF\x16a\x0B\xA3W`@Qc\x08\xA9D\x19`\xE3\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80T`@Qc\x02&^1`\xE6\x1B\x81R3`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90c\x89\x97\x8C@\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0B\xE9W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0C\r\x91\x90a\x18\xF6V[`\x01`\x01`\xA0\x1B\x03\x16\x14a\x0C4W`@Qc\xAC\xD5\xA8#`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x05\x1C3\x83\x83a\x11]V[_a\x0CI`\x04T\x90V[\x90P\x90V[_T`\x01`\xA0\x1B\x90\x04`\xFF\x16a\x0CwW`@Qc\x08\xA9D\x19`\xE3\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80T`@Qc\x02&^1`\xE6\x1B\x81R3`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90c\x89\x97\x8C@\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0C\xBDW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0C\xE1\x91\x90a\x18\xF6V[`\x01`\x01`\xA0\x1B\x03\x16\x14a\r\x08W`@Qc\xAC\xD5\xA8#`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\r\x143\x86\x86\x86a\x10gV[a\x08\xD13\x83\x83a\x11]V[_T\x83\x90`\x01`\xA0\x1B\x90\x04`\xFF\x16a\rJW`@Qc\x08\xA9D\x19`\xE3\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_T`@Qc\x02&^1`\xE6\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\x04\x83\x01R3\x92\x16\x90c\x89\x97\x8C@\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\r\x91W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\r\xB5\x91\x90a\x18\xF6V[`\x01`\x01`\xA0\x1B\x03\x16\x14a\r\xDCW`@Qc\xAC\xD5\xA8#`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\r\xE7\x84\x84\x84a\x11]V[PPPPV[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R`\x06` R`@\x81 a\x0E\r\x91a\x14~V[a\x0Er\x7F\xA4\xDE0\xA5(\xBE\xCA\xDF\x82d\x9D\x13\x95\xC0\xE3\r\xD1\x8A\xE3[Z\x96\xCEq\xE9)[\xB1K\xC9\xF3\xBC\x82`@Q` \x01a\x0E^\x92\x91\x90\x91\x82R``\x1Bk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16` \x82\x01R`4\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@Ra\x12\x1AV[`@Q`\x01`\x01`\xA0\x1B\x03\x82\x16\x81R\x7F\xA4\xDE0\xA5(\xBE\xCA\xDF\x82d\x9D\x13\x95\xC0\xE3\r\xD1\x8A\xE3[Z\x96\xCEq\xE9)[\xB1K\xC9\xF3\xBC\x90` \x01`@Q\x80\x91\x03\x90\xA1PV[a\x0E\xB9a\x14QV[\x82_\x01\x82\x81T\x81\x10a\x0E\xCDWa\x0E\xCDa\x19\x84V[_\x91\x82R` \x91\x82\x90 `@\x80Q`\x80\x81\x01\x82R`\x04\x90\x93\x02\x90\x91\x01\x80T\x83R`\x01\x81\x01T\x93\x83\x01\x93\x90\x93R`\x02\x83\x01T\x90\x82\x01R`\x03\x90\x91\x01T`\x01`\x01`\xA0\x1B\x03\x16``\x82\x01R\x90P\x92\x91PPV[__a\x0F(a\x14QV[_\x84\x81R`\x01\x86\x01` R`@\x81 T\x90\x81\x90\x03a\x0FoWPP`@\x80Q`\x80\x81\x01\x82R_\x80\x82R` \x82\x01\x81\x90R\x91\x81\x01\x82\x90R``\x81\x01\x82\x90R\x90\x92P\x82\x91Pa\x0F\xEEV[`\x01a\x0F{\x81\x83a\x19]V[\x87a\x0F\x87`\x01\x85a\x19]V[\x81T\x81\x10a\x0F\x97Wa\x0F\x97a\x19\x84V[_\x91\x82R` \x91\x82\x90 `@\x80Q`\x80\x81\x01\x82R`\x04\x90\x93\x02\x90\x91\x01\x80T\x83R`\x01\x81\x01T\x93\x83\x01\x93\x90\x93R`\x02\x83\x01T\x90\x82\x01R`\x03\x90\x91\x01T`\x01`\x01`\xA0\x1B\x03\x16``\x82\x01R\x91\x95P\x93P\x91Pa\x0F\xEE\x90PV[\x92P\x92P\x92V[``__\x84`\x01`\x01`\xA0\x1B\x03\x16\x84`@Qa\x10\x11\x91\x90a\x1A\x11V[_`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80_\x81\x14a\x10IW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\x10NV[``\x91P[P\x91P\x91Pa\x10^\x85\x83\x83a\x12\xFFV[\x95\x94PPPPPV[a\x10\xA4`@Q\x80`\x80\x01`@R\x80\x85\x81R` \x01\x84\x81R` \x01\x83\x81R` \x01\x86`\x01`\x01`\xA0\x1B\x03\x16\x81RP`\x04a\x13_\x90\x91\x90c\xFF\xFF\xFF\xFF\x16V[P`@\x80Q\x7F\xBFI\xCC\xD4\x1AA\x18\xC7\xE1\xE7!C\xBA\xD8D\xE5\xF6\xED\x12\xBF`\xCA\xA6B\xD8\x8D\x19\xCA\x10$L6` \x82\x01R\x90\x81\x01\x84\x90R``\x80\x82\x01\x84\x90R`\x80\x82\x01\x83\x90R\x85\x90\x1Bk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16`\xA0\x82\x01Ra\x11\x07\x90`\xB4\x01a\x0E^V[`@\x80Q\x84\x81R` \x81\x01\x84\x90R\x90\x81\x01\x82\x90R`\x01`\x01`\xA0\x1B\x03\x85\x16``\x82\x01R\x7F\xBFI\xCC\xD4\x1AA\x18\xC7\xE1\xE7!C\xBA\xD8D\xE5\xF6\xED\x12\xBF`\xCA\xA6B\xD8\x8D\x19\xCA\x10$L6\x90`\x80\x01`@Q\x80\x91\x03\x90\xA1PPPPV[_\x81\x90\x03a\x11}W`@Qb\x9C\xEA\xC7`\xE4\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x01`\x01`\xA0\x1B\x03\x83\x16_\x90\x81R`\x06` R`@\x90 a\x11\x9F\x82\x84\x83a\x1A`V[Pa\x11\xDA\x7F\xC4\xDF[\xA1h\x14\x83\x8A\xB2a\x88)\xD6\x8F\x86#\xBB\x89s\x02\xF2M\xBD\xBA\"y\xDB\xE4Z\xDB=\x14\x84\x84\x84`@Q` \x01a\x0E^\x94\x93\x92\x91\x90a\x1B\x1AV[\x7F\xC4\xDF[\xA1h\x14\x83\x8A\xB2a\x88)\xD6\x8F\x86#\xBB\x89s\x02\xF2M\xBD\xBA\"y\xDB\xE4Z\xDB=\x14\x83\x83\x83`@Qa\x12\r\x93\x92\x91\x90a\x1BLV[`@Q\x80\x91\x03\x90\xA1PPPV[`\x01T_\x90a\x12W\x90\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90`\x01`\xE0\x1B\x90\x04c\xFF\xFF\xFF\xFF\x16a\x1B\x8BV[B\x11\x15a\x12bWP`\x01[`\x03T`\x01T\x83Q` \x80\x86\x01\x91\x90\x91 `@\x80Q\x80\x84\x01\x95\x90\x95RC`\xE0\x1B`\x01`\x01`\xE0\x1B\x03\x19\x16\x90\x85\x01R\x91\x90\x1Bc\xFF\xFF\xFF\xFF\x19\x16`D\x83\x01R``\x82\x01R`\x80\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R\x80Q` \x91\x82\x01 c\xFF\xFF\xFF\xFFB\x16`\x01`\xE0\x1B\x02\x91\x1C\x17`\x01U\x80\x15a\x05\x1CWPP`\x01T`\x01`\x01`\xE0\x1B\x03\x81\x16`\x01`\xE0\x1B\x91\x82\x90\x04c\xFF\xFF\xFF\xFF\x16\x90\x91\x02\x17`\x02UV[``\x82a\x13\x14Wa\x13\x0F\x82a\x14)V[a\x06?V[\x81Q\x15\x80\x15a\x13+WP`\x01`\x01`\xA0\x1B\x03\x84\x16;\x15[\x15a\x13XW`@Qc\x99\x96\xB3\x15`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x85\x16`\x04\x82\x01R`$\x01`@Q\x80\x91\x03\x90\xFD[P\x92\x91PPV[\x81T_\x90c\xFF\xFF\xFF\xFF\x11a\x13\x86W`@Qc\x10\x95;\xFF`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@\x80\x83\x01Q_\x90\x81R`\x01\x85\x01` R T\x15a\x13\xB6W`@QbXLo`\xE5\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x82T`\x01\x80\x82\x01\x85U_\x85\x81R` \x80\x82 \x86Q`\x04\x90\x95\x02\x01\x93\x84U\x85\x81\x01Q\x84\x84\x01U`@\x80\x87\x01Q`\x02\x86\x01\x81\x90U``\x88\x01Q`\x03\x90\x96\x01\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x90\x97\x16\x96\x90\x96\x17\x90\x95U\x87T\x94\x83R\x83\x88\x01\x90\x91R\x90 \x82\x90Ua\x06?\x91a\x19]V[\x80Q\x15a\x148W\x80Q` \x82\x01\xFD[`@Qc\xD6\xBD\xA2u`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@Q\x80`\x80\x01`@R\x80_\x81R` \x01_\x81R` \x01_\x81R` \x01_`\x01`\x01`\xA0\x1B\x03\x16\x81RP\x90V[P\x80Ta\x14\x8A\x90a\x19\x11V[_\x82U\x80`\x1F\x10a\x14\x99WPPV[`\x1F\x01` \x90\x04\x90_R` _ \x90\x81\x01\x90a\n\x9A\x91\x90[\x80\x82\x11\x15a\x14\xC4W_\x81U`\x01\x01a\x14\xB1V[P\x90V[\x80Q\x82R` \x80\x82\x01Q\x90\x83\x01R`@\x80\x82\x01Q\x90\x83\x01R``\x90\x81\x01Q`\x01`\x01`\xA0\x1B\x03\x16\x91\x01RV[` \x80\x82R\x82Q\x82\x82\x01\x81\x90R_\x91\x84\x01\x90`@\x84\x01\x90\x83[\x81\x81\x10\x15a\x156Wa\x15 \x83\x85Qa\x14\xC8V[` \x93\x90\x93\x01\x92`\x80\x92\x90\x92\x01\x91`\x01\x01a\x15\rV[P\x90\x95\x94PPPPPV[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\n\x9AW__\xFD[_` \x82\x84\x03\x12\x15a\x15eW__\xFD[\x815a\x06?\x81a\x15AV[_` \x82\x84\x03\x12\x15a\x15\x80W__\xFD[\x815c\xFF\xFF\xFF\xFF\x81\x16\x81\x14a\x06?W__\xFD[_\x81Q\x80\x84R\x80` \x84\x01` \x86\x01^_` \x82\x86\x01\x01R` `\x1F\x19`\x1F\x83\x01\x16\x85\x01\x01\x91PP\x92\x91PPV[` \x81R_a\x06?` \x83\x01\x84a\x15\x93V[_` \x82\x84\x03\x12\x15a\x15\xE3W__\xFD[P5\x91\x90PV[\x83\x15\x15\x81Rc\xFF\xFF\xFF\xFF\x83\x16` \x82\x01R`\xC0\x81\x01a\x16\x0C`@\x83\x01\x84a\x14\xC8V[\x94\x93PPPPV[`\x80\x81\x01a\x06W\x82\x84a\x14\xC8V[__` \x83\x85\x03\x12\x15a\x163W__\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x16IW__\xFD[\x83\x01`\x1F\x81\x01\x85\x13a\x16YW__\xFD[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x16oW__\xFD[\x85` \x82`\x05\x1B\x84\x01\x01\x11\x15a\x16\x83W__\xFD[` \x91\x90\x91\x01\x95\x90\x94P\x92PPPV[_` \x82\x01` \x83R\x80\x84Q\x80\x83R`@\x85\x01\x91P`@\x81`\x05\x1B\x86\x01\x01\x92P` \x86\x01_[\x82\x81\x10\x15a\x16\xEAW`?\x19\x87\x86\x03\x01\x84Ra\x16\xD5\x85\x83Qa\x15\x93V[\x94P` \x93\x84\x01\x93\x91\x90\x91\x01\x90`\x01\x01a\x16\xB9V[P\x92\x96\x95PPPPPPV[____`\x80\x85\x87\x03\x12\x15a\x17\tW__\xFD[\x845a\x17\x14\x81a\x15AV[\x96` \x86\x015\x96P`@\x86\x015\x95``\x015\x94P\x92PPPV[___``\x84\x86\x03\x12\x15a\x17@W__\xFD[PP\x815\x93` \x83\x015\x93P`@\x90\x92\x015\x91\x90PV[__\x83`\x1F\x84\x01\x12a\x17gW__\xFD[P\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x17~W__\xFD[` \x83\x01\x91P\x83` \x82\x85\x01\x01\x11\x15a\x17\x95W__\xFD[\x92P\x92\x90PV[______`\xA0\x87\x89\x03\x12\x15a\x17\xB1W__\xFD[\x865a\x17\xBC\x81a\x15AV[\x95P` \x87\x015\x94P`@\x87\x015\x93P``\x87\x015\x92P`\x80\x87\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x17\xECW__\xFD[a\x17\xF8\x89\x82\x8A\x01a\x17WV[\x97\x9A\x96\x99P\x94\x97P\x92\x95\x93\x94\x92PPPV[__` \x83\x85\x03\x12\x15a\x18\x1BW__\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x181W__\xFD[a\x18=\x85\x82\x86\x01a\x17WV[\x90\x96\x90\x95P\x93PPPPV[_____`\x80\x86\x88\x03\x12\x15a\x18]W__\xFD[\x855\x94P` \x86\x015\x93P`@\x86\x015\x92P``\x86\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x18\x88W__\xFD[a\x18\x94\x88\x82\x89\x01a\x17WV[\x96\x99\x95\x98P\x93\x96P\x92\x94\x93\x92PPPV[___`@\x84\x86\x03\x12\x15a\x18\xB7W__\xFD[\x835a\x18\xC2\x81a\x15AV[\x92P` \x84\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x18\xDDW__\xFD[a\x18\xE9\x86\x82\x87\x01a\x17WV[\x94\x97\x90\x96P\x93\x94PPPPV[_` \x82\x84\x03\x12\x15a\x19\x06W__\xFD[\x81Qa\x06?\x81a\x15AV[`\x01\x81\x81\x1C\x90\x82\x16\x80a\x19%W`\x7F\x82\x16\x91P[` \x82\x10\x81\x03a\x19CWcNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[P\x91\x90PV[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[\x81\x81\x03\x81\x81\x11\x15a\x06WWa\x06Wa\x19IV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[__\x835`\x1E\x19\x846\x03\x01\x81\x12a\x19\xADW__\xFD[\x83\x01\x805\x91Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a\x19\xC7W__\xFD[` \x01\x91P6\x81\x90\x03\x82\x13\x15a\x17\x95W__\xFD[_\x81Q\x80` \x84\x01\x85^_\x93\x01\x92\x83RP\x90\x91\x90PV[\x82\x84\x827_\x83\x82\x01_\x81Ra\x1A\x07\x81\x85a\x19\xDBV[\x96\x95PPPPPPV[_a\x06?\x82\x84a\x19\xDBV[`\x1F\x82\x11\x15a\t\x9EW\x80_R` _ `\x1F\x84\x01`\x05\x1C\x81\x01` \x85\x10\x15a\x1AAWP\x80[`\x1F\x84\x01`\x05\x1C\x82\x01\x91P[\x81\x81\x10\x15a\x08\xD1W_\x81U`\x01\x01a\x1AMV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11\x15a\x1AxWa\x1Axa\x19pV[a\x1A\x8C\x83a\x1A\x86\x83Ta\x19\x11V[\x83a\x1A\x1CV[_`\x1F\x84\x11`\x01\x81\x14a\x1A\xBDW_\x85\x15a\x1A\xA6WP\x83\x82\x015[_\x19`\x03\x87\x90\x1B\x1C\x19\x16`\x01\x86\x90\x1B\x17\x83Ua\x08\xD1V[_\x83\x81R` \x81 `\x1F\x19\x87\x16\x91[\x82\x81\x10\x15a\x1A\xECW\x86\x85\x015\x82U` \x94\x85\x01\x94`\x01\x90\x92\x01\x91\x01a\x1A\xCCV[P\x86\x82\x10\x15a\x1B\x08W_\x19`\xF8\x88`\x03\x1B\x16\x1C\x19\x84\x87\x015\x16\x81U[PP`\x01\x85`\x01\x1B\x01\x83UPPPPPV[\x84\x81Rk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x84``\x1B\x16` \x82\x01R\x81\x83`4\x83\x017_\x91\x01`4\x01\x90\x81R\x93\x92PPPV[`\x01`\x01`\xA0\x1B\x03\x84\x16\x81R`@` \x82\x01\x81\x90R\x81\x01\x82\x90R\x81\x83``\x83\x017_\x81\x83\x01``\x90\x81\x01\x91\x90\x91R`\x1F\x90\x92\x01`\x1F\x19\x16\x01\x01\x92\x91PPV[\x80\x82\x01\x80\x82\x11\x15a\x06WWa\x06Wa\x19IV\xFE\xA2dipfsX\"\x12 >-[\xFE\xE7\xD6Y+\x86\xE5\x061\x04 \xE9\x98\xD13\xC7sm\x8Aox=\x8B\x19\xBD\x93qF\x91dsolcC\0\x08\x1E\x003",
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct KeyId(u32);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<KeyId> for u32 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                32,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<32>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    32,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    32,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    32,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        impl KeyId {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from_underlying(value: u32) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into_underlying(self) -> u32 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl From<u32> for KeyId {
            fn from(value: u32) -> Self {
                Self::from_underlying(value)
            }
        }
        #[automatically_derived]
        impl From<KeyId> for u32 {
            fn from(value: KeyId) -> Self {
                value.into_underlying()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for KeyId {
            type RustType = u32;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                32,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                32,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                32,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    32,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    32,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for KeyId {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    32,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct KeyBindingWithSignature { bytes32 ed25519_sig_0; bytes32 ed25519_sig_1; bytes32 ed25519_pub_key; address chain_key; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct KeyBindingWithSignature {
        #[allow(missing_docs)]
        pub ed25519_sig_0: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub ed25519_sig_1: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub ed25519_pub_key: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub chain_key: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<KeyBindingWithSignature> for UnderlyingRustTuple<'_> {
            fn from(value: KeyBindingWithSignature) -> Self {
                (
                    value.ed25519_sig_0,
                    value.ed25519_sig_1,
                    value.ed25519_pub_key,
                    value.chain_key,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for KeyBindingWithSignature {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    ed25519_sig_0: tuple.0,
                    ed25519_sig_1: tuple.1,
                    ed25519_pub_key: tuple.2,
                    chain_key: tuple.3,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for KeyBindingWithSignature {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for KeyBindingWithSignature {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ed25519_sig_0),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ed25519_sig_1),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ed25519_pub_key),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.chain_key,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for KeyBindingWithSignature {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for KeyBindingWithSignature {
            const NAME: &'static str = "KeyBindingWithSignature";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "KeyBindingWithSignature(bytes32 ed25519_sig_0,bytes32 ed25519_sig_1,bytes32 ed25519_pub_key,address chain_key)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.ed25519_sig_0)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.ed25519_sig_1)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.ed25519_pub_key,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.chain_key,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for KeyBindingWithSignature {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.ed25519_sig_0,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.ed25519_sig_1,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.ed25519_pub_key,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.chain_key,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.ed25519_sig_0,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.ed25519_sig_1,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.ed25519_pub_key,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.chain_key,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AddressEmptyCode(address)` and selector `0x9996b315`.
```solidity
error AddressEmptyCode(address target);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AddressEmptyCode {
        #[allow(missing_docs)]
        pub target: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AddressEmptyCode> for UnderlyingRustTuple<'_> {
            fn from(value: AddressEmptyCode) -> Self {
                (value.target,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AddressEmptyCode {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { target: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AddressEmptyCode {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AddressEmptyCode(address)";
            const SELECTOR: [u8; 4] = [153u8, 150u8, 179u8, 21u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.target,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AlreadyInitialized()` and selector `0x0dc149f0`.
```solidity
error AlreadyInitialized();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AlreadyInitialized;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AlreadyInitialized> for UnderlyingRustTuple<'_> {
            fn from(value: AlreadyInitialized) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AlreadyInitialized {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AlreadyInitialized {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AlreadyInitialized()";
            const SELECTOR: [u8; 4] = [13u8, 193u8, 73u8, 240u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ContractNotResponsible()` and selector `0xacd5a823`.
```solidity
error ContractNotResponsible();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ContractNotResponsible;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ContractNotResponsible> for UnderlyingRustTuple<'_> {
            fn from(value: ContractNotResponsible) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ContractNotResponsible {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ContractNotResponsible {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ContractNotResponsible()";
            const SELECTOR: [u8; 4] = [172u8, 213u8, 168u8, 35u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `EmptyMultiaddr()` and selector `0x09ceac70`.
```solidity
error EmptyMultiaddr();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyMultiaddr;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyMultiaddr> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyMultiaddr) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyMultiaddr {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyMultiaddr {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyMultiaddr()";
            const SELECTOR: [u8; 4] = [9u8, 206u8, 172u8, 112u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ExistingKeyBinding()` and selector `0x0b098de0`.
```solidity
error ExistingKeyBinding();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExistingKeyBinding;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExistingKeyBinding> for UnderlyingRustTuple<'_> {
            fn from(value: ExistingKeyBinding) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ExistingKeyBinding {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ExistingKeyBinding {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ExistingKeyBinding()";
            const SELECTOR: [u8; 4] = [11u8, 9u8, 141u8, 224u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `FailedCall()` and selector `0xd6bda275`.
```solidity
error FailedCall();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct FailedCall;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<FailedCall> for UnderlyingRustTuple<'_> {
            fn from(value: FailedCall) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for FailedCall {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for FailedCall {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "FailedCall()";
            const SELECTOR: [u8; 4] = [214u8, 189u8, 162u8, 117u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidSafeAddress()` and selector `0x8e9d7c5e`.
```solidity
error InvalidSafeAddress();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidSafeAddress;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidSafeAddress> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidSafeAddress) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidSafeAddress {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidSafeAddress {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidSafeAddress()";
            const SELECTOR: [u8; 4] = [142u8, 157u8, 124u8, 94u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `KeyIdOutOfRange()` and selector `0x212a77fe`.
```solidity
error KeyIdOutOfRange();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct KeyIdOutOfRange;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<KeyIdOutOfRange> for UnderlyingRustTuple<'_> {
            fn from(value: KeyIdOutOfRange) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for KeyIdOutOfRange {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for KeyIdOutOfRange {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "KeyIdOutOfRange()";
            const SELECTOR: [u8; 4] = [33u8, 42u8, 119u8, 254u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `MultiSigUninitialized()` and selector `0x454a20c8`.
```solidity
error MultiSigUninitialized();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MultiSigUninitialized;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<MultiSigUninitialized> for UnderlyingRustTuple<'_> {
            fn from(value: MultiSigUninitialized) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for MultiSigUninitialized {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for MultiSigUninitialized {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MultiSigUninitialized()";
            const SELECTOR: [u8; 4] = [69u8, 74u8, 32u8, 200u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ZeroAddress(string)` and selector `0xeac0d389`.
```solidity
error ZeroAddress(string reason);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroAddress {
        #[allow(missing_docs)]
        pub reason: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroAddress> for UnderlyingRustTuple<'_> {
            fn from(value: ZeroAddress) -> Self {
                (value.reason,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroAddress {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { reason: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroAddress {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroAddress(string)";
            const SELECTOR: [u8; 4] = [234u8, 192u8, 211u8, 137u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.reason,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ZeroInterval()` and selector `0x346ff607`.
```solidity
error ZeroInterval();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroInterval;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroInterval> for UnderlyingRustTuple<'_> {
            fn from(value: ZeroInterval) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroInterval {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroInterval {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroInterval()";
            const SELECTOR: [u8; 4] = [52u8, 111u8, 246u8, 7u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `AddressAnnouncement(address,string)` and selector `0xc4df5ba16814838ab2618829d68f8623bb897302f24dbdba2279dbe45adb3d14`.
```solidity
event AddressAnnouncement(address node, string baseMultiaddr);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct AddressAnnouncement {
        #[allow(missing_docs)]
        pub node: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub baseMultiaddr: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for AddressAnnouncement {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::String,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "AddressAnnouncement(address,string)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                196u8, 223u8, 91u8, 161u8, 104u8, 20u8, 131u8, 138u8, 178u8, 97u8, 136u8,
                41u8, 214u8, 143u8, 134u8, 35u8, 187u8, 137u8, 115u8, 2u8, 242u8, 77u8,
                189u8, 186u8, 34u8, 121u8, 219u8, 228u8, 90u8, 219u8, 61u8, 20u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    node: data.0,
                    baseMultiaddr: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.node,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.baseMultiaddr,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for AddressAnnouncement {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&AddressAnnouncement> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &AddressAnnouncement) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `KeyBinding(bytes32,bytes32,bytes32,address)` and selector `0xbf49ccd41a4118c7e1e72143bad844e5f6ed12bf60caa642d88d19ca10244c36`.
```solidity
event KeyBinding(bytes32 ed25519_sig_0, bytes32 ed25519_sig_1, bytes32 ed25519_pub_key, address chain_key);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct KeyBinding {
        #[allow(missing_docs)]
        pub ed25519_sig_0: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub ed25519_sig_1: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub ed25519_pub_key: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub chain_key: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for KeyBinding {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "KeyBinding(bytes32,bytes32,bytes32,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                191u8, 73u8, 204u8, 212u8, 26u8, 65u8, 24u8, 199u8, 225u8, 231u8, 33u8,
                67u8, 186u8, 216u8, 68u8, 229u8, 246u8, 237u8, 18u8, 191u8, 96u8, 202u8,
                166u8, 66u8, 216u8, 141u8, 25u8, 202u8, 16u8, 36u8, 76u8, 54u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    ed25519_sig_0: data.0,
                    ed25519_sig_1: data.1,
                    ed25519_pub_key: data.2,
                    chain_key: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ed25519_sig_0),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ed25519_sig_1),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ed25519_pub_key),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.chain_key,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for KeyBinding {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&KeyBinding> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &KeyBinding) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `LedgerDomainSeparatorUpdated(bytes32)` and selector `0xa43fad83920fd09445855e854e73c9c532e17402c9ceb09993a2392843a5bdb9`.
```solidity
event LedgerDomainSeparatorUpdated(bytes32 indexed ledgerDomainSeparator);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct LedgerDomainSeparatorUpdated {
        #[allow(missing_docs)]
        pub ledgerDomainSeparator: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for LedgerDomainSeparatorUpdated {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "LedgerDomainSeparatorUpdated(bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                164u8, 63u8, 173u8, 131u8, 146u8, 15u8, 208u8, 148u8, 69u8, 133u8, 94u8,
                133u8, 78u8, 115u8, 201u8, 197u8, 50u8, 225u8, 116u8, 2u8, 201u8, 206u8,
                176u8, 153u8, 147u8, 162u8, 57u8, 40u8, 67u8, 165u8, 189u8, 185u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    ledgerDomainSeparator: topics.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.ledgerDomainSeparator.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(
                    &self.ledgerDomainSeparator,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for LedgerDomainSeparatorUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&LedgerDomainSeparatorUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &LedgerDomainSeparatorUpdated,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RevokeAnnouncement(address)` and selector `0xa4de30a528becadf82649d1395c0e30dd18ae35b5a96ce71e9295bb14bc9f3bc`.
```solidity
event RevokeAnnouncement(address node);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RevokeAnnouncement {
        #[allow(missing_docs)]
        pub node: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RevokeAnnouncement {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "RevokeAnnouncement(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                164u8, 222u8, 48u8, 165u8, 40u8, 190u8, 202u8, 223u8, 130u8, 100u8,
                157u8, 19u8, 149u8, 192u8, 227u8, 13u8, 209u8, 138u8, 227u8, 91u8, 90u8,
                150u8, 206u8, 113u8, 233u8, 41u8, 91u8, 177u8, 75u8, 201u8, 243u8, 188u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { node: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.node,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RevokeAnnouncement {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RevokeAnnouncement> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RevokeAnnouncement) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(address safeRegistry);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub safeRegistry: alloy::sol_types::private::Address,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (value.safeRegistry,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { safeRegistry: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.safeRegistry,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `LEDGER_VERSION()` and selector `0xddad1902`.
```solidity
function LEDGER_VERSION() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct LEDGER_VERSIONCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`LEDGER_VERSION()`](LEDGER_VERSIONCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct LEDGER_VERSIONReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<LEDGER_VERSIONCall> for UnderlyingRustTuple<'_> {
                fn from(value: LEDGER_VERSIONCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for LEDGER_VERSIONCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<LEDGER_VERSIONReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: LEDGER_VERSIONReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for LEDGER_VERSIONReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for LEDGER_VERSIONCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::String;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "LEDGER_VERSION()";
            const SELECTOR: [u8; 4] = [221u8, 173u8, 25u8, 2u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: LEDGER_VERSIONReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: LEDGER_VERSIONReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `SNAPSHOT_INTERVAL()` and selector `0x6d2beef1`.
```solidity
function SNAPSHOT_INTERVAL() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SNAPSHOT_INTERVALCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`SNAPSHOT_INTERVAL()`](SNAPSHOT_INTERVALCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SNAPSHOT_INTERVALReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SNAPSHOT_INTERVALCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: SNAPSHOT_INTERVALCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for SNAPSHOT_INTERVALCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SNAPSHOT_INTERVALReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: SNAPSHOT_INTERVALReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for SNAPSHOT_INTERVALReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for SNAPSHOT_INTERVALCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SNAPSHOT_INTERVAL()";
            const SELECTOR: [u8; 4] = [109u8, 43u8, 238u8, 241u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: SNAPSHOT_INTERVALReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: SNAPSHOT_INTERVALReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `announce(string)` and selector `0xea0a5237`.
```solidity
function announce(string memory baseMultiaddr) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct announceCall {
        #[allow(missing_docs)]
        pub baseMultiaddr: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`announce(string)`](announceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct announceReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<announceCall> for UnderlyingRustTuple<'_> {
                fn from(value: announceCall) -> Self {
                    (value.baseMultiaddr,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for announceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { baseMultiaddr: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<announceReturn> for UnderlyingRustTuple<'_> {
                fn from(value: announceReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for announceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl announceReturn {
            fn _tokenize(
                &self,
            ) -> <announceCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for announceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = announceReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "announce(string)";
            const SELECTOR: [u8; 4] = [234u8, 10u8, 82u8, 55u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.baseMultiaddr,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                announceReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `announceSafe(address,string)` and selector `0xfad0e5a2`.
```solidity
function announceSafe(address selfAddress, string memory baseMultiaddr) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct announceSafeCall {
        #[allow(missing_docs)]
        pub selfAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub baseMultiaddr: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`announceSafe(address,string)`](announceSafeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct announceSafeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<announceSafeCall> for UnderlyingRustTuple<'_> {
                fn from(value: announceSafeCall) -> Self {
                    (value.selfAddress, value.baseMultiaddr)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for announceSafeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        selfAddress: tuple.0,
                        baseMultiaddr: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<announceSafeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: announceSafeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for announceSafeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl announceSafeReturn {
            fn _tokenize(
                &self,
            ) -> <announceSafeCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for announceSafeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = announceSafeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "announceSafe(address,string)";
            const SELECTOR: [u8; 4] = [250u8, 208u8, 229u8, 162u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.selfAddress,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.baseMultiaddr,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                announceSafeReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `bindKeys(bytes32,bytes32,bytes32)` and selector `0xdbb98d91`.
```solidity
function bindKeys(bytes32 ed25519_sig_0, bytes32 ed25519_sig_1, bytes32 ed25519_pub_key) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bindKeysCall {
        #[allow(missing_docs)]
        pub ed25519_sig_0: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub ed25519_sig_1: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub ed25519_pub_key: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`bindKeys(bytes32,bytes32,bytes32)`](bindKeysCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bindKeysReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bindKeysCall> for UnderlyingRustTuple<'_> {
                fn from(value: bindKeysCall) -> Self {
                    (value.ed25519_sig_0, value.ed25519_sig_1, value.ed25519_pub_key)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bindKeysCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        ed25519_sig_0: tuple.0,
                        ed25519_sig_1: tuple.1,
                        ed25519_pub_key: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bindKeysReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bindKeysReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bindKeysReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl bindKeysReturn {
            fn _tokenize(
                &self,
            ) -> <bindKeysCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bindKeysCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bindKeysReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bindKeys(bytes32,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [219u8, 185u8, 141u8, 145u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ed25519_sig_0),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ed25519_sig_1),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ed25519_pub_key),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                bindKeysReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `bindKeysAnnounce(bytes32,bytes32,bytes32,string)` and selector `0xf884a9cb`.
```solidity
function bindKeysAnnounce(bytes32 ed25519_sig_0, bytes32 ed25519_sig_1, bytes32 ed25519_pub_key, string memory baseMultiaddr) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bindKeysAnnounceCall {
        #[allow(missing_docs)]
        pub ed25519_sig_0: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub ed25519_sig_1: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub ed25519_pub_key: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub baseMultiaddr: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`bindKeysAnnounce(bytes32,bytes32,bytes32,string)`](bindKeysAnnounceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bindKeysAnnounceReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bindKeysAnnounceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: bindKeysAnnounceCall) -> Self {
                    (
                        value.ed25519_sig_0,
                        value.ed25519_sig_1,
                        value.ed25519_pub_key,
                        value.baseMultiaddr,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for bindKeysAnnounceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        ed25519_sig_0: tuple.0,
                        ed25519_sig_1: tuple.1,
                        ed25519_pub_key: tuple.2,
                        baseMultiaddr: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bindKeysAnnounceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: bindKeysAnnounceReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for bindKeysAnnounceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl bindKeysAnnounceReturn {
            fn _tokenize(
                &self,
            ) -> <bindKeysAnnounceCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bindKeysAnnounceCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bindKeysAnnounceReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bindKeysAnnounce(bytes32,bytes32,bytes32,string)";
            const SELECTOR: [u8; 4] = [248u8, 132u8, 169u8, 203u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ed25519_sig_0),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ed25519_sig_1),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ed25519_pub_key),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.baseMultiaddr,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                bindKeysAnnounceReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `bindKeysAnnounceSafe(address,bytes32,bytes32,bytes32,string)` and selector `0xddb9dfc1`.
```solidity
function bindKeysAnnounceSafe(address selfAddress, bytes32 ed25519_sig_0, bytes32 ed25519_sig_1, bytes32 ed25519_pub_key, string memory baseMultiaddr) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bindKeysAnnounceSafeCall {
        #[allow(missing_docs)]
        pub selfAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub ed25519_sig_0: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub ed25519_sig_1: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub ed25519_pub_key: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub baseMultiaddr: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`bindKeysAnnounceSafe(address,bytes32,bytes32,bytes32,string)`](bindKeysAnnounceSafeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bindKeysAnnounceSafeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bindKeysAnnounceSafeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: bindKeysAnnounceSafeCall) -> Self {
                    (
                        value.selfAddress,
                        value.ed25519_sig_0,
                        value.ed25519_sig_1,
                        value.ed25519_pub_key,
                        value.baseMultiaddr,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for bindKeysAnnounceSafeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        selfAddress: tuple.0,
                        ed25519_sig_0: tuple.1,
                        ed25519_sig_1: tuple.2,
                        ed25519_pub_key: tuple.3,
                        baseMultiaddr: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bindKeysAnnounceSafeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: bindKeysAnnounceSafeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for bindKeysAnnounceSafeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl bindKeysAnnounceSafeReturn {
            fn _tokenize(
                &self,
            ) -> <bindKeysAnnounceSafeCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bindKeysAnnounceSafeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bindKeysAnnounceSafeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bindKeysAnnounceSafe(address,bytes32,bytes32,bytes32,string)";
            const SELECTOR: [u8; 4] = [221u8, 185u8, 223u8, 193u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.selfAddress,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ed25519_sig_0),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ed25519_sig_1),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ed25519_pub_key),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.baseMultiaddr,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                bindKeysAnnounceSafeReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `bindKeysSafe(address,bytes32,bytes32,bytes32)` and selector `0xcae2b434`.
```solidity
function bindKeysSafe(address selfAddress, bytes32 ed25519_sig_0, bytes32 ed25519_sig_1, bytes32 ed25519_pub_key) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bindKeysSafeCall {
        #[allow(missing_docs)]
        pub selfAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub ed25519_sig_0: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub ed25519_sig_1: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub ed25519_pub_key: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`bindKeysSafe(address,bytes32,bytes32,bytes32)`](bindKeysSafeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bindKeysSafeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bindKeysSafeCall> for UnderlyingRustTuple<'_> {
                fn from(value: bindKeysSafeCall) -> Self {
                    (
                        value.selfAddress,
                        value.ed25519_sig_0,
                        value.ed25519_sig_1,
                        value.ed25519_pub_key,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bindKeysSafeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        selfAddress: tuple.0,
                        ed25519_sig_0: tuple.1,
                        ed25519_sig_1: tuple.2,
                        ed25519_pub_key: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bindKeysSafeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bindKeysSafeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bindKeysSafeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl bindKeysSafeReturn {
            fn _tokenize(
                &self,
            ) -> <bindKeysSafeCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bindKeysSafeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bindKeysSafeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bindKeysSafe(address,bytes32,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [202u8, 226u8, 180u8, 52u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.selfAddress,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ed25519_sig_0),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ed25519_sig_1),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ed25519_pub_key),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                bindKeysSafeReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getAllKeyBindings()` and selector `0x10ab5297`.
```solidity
function getAllKeyBindings() external view returns (KeyBindingWithSignature[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAllKeyBindingsCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getAllKeyBindings()`](getAllKeyBindingsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAllKeyBindingsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Vec<
            <KeyBindingWithSignature as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAllKeyBindingsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAllKeyBindingsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAllKeyBindingsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<KeyBindingWithSignature>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    <KeyBindingWithSignature as alloy::sol_types::SolType>::RustType,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAllKeyBindingsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAllKeyBindingsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAllKeyBindingsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getAllKeyBindingsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Vec<
                <KeyBindingWithSignature as alloy::sol_types::SolType>::RustType,
            >;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<KeyBindingWithSignature>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getAllKeyBindings()";
            const SELECTOR: [u8; 4] = [16u8, 171u8, 82u8, 151u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        KeyBindingWithSignature,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getAllKeyBindingsReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getAllKeyBindingsReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getKeyBindingCount()` and selector `0xf83e4292`.
```solidity
function getKeyBindingCount() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKeyBindingCountCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getKeyBindingCount()`](getKeyBindingCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKeyBindingCountReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKeyBindingCountCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getKeyBindingCountCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getKeyBindingCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKeyBindingCountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getKeyBindingCountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getKeyBindingCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getKeyBindingCountCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getKeyBindingCount()";
            const SELECTOR: [u8; 4] = [248u8, 62u8, 66u8, 146u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getKeyBindingCountReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getKeyBindingCountReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getKeyBindingWithKeyId(uint32)` and selector `0xa8b4eec9`.
```solidity
function getKeyBindingWithKeyId(KeyId keyId) external view returns (KeyBindingWithSignature memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKeyBindingWithKeyIdCall {
        #[allow(missing_docs)]
        pub keyId: <KeyId as alloy::sol_types::SolType>::RustType,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getKeyBindingWithKeyId(uint32)`](getKeyBindingWithKeyIdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKeyBindingWithKeyIdReturn {
        #[allow(missing_docs)]
        pub _0: <KeyBindingWithSignature as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (KeyId,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <KeyId as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKeyBindingWithKeyIdCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getKeyBindingWithKeyIdCall) -> Self {
                    (value.keyId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getKeyBindingWithKeyIdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { keyId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (KeyBindingWithSignature,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <KeyBindingWithSignature as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKeyBindingWithKeyIdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getKeyBindingWithKeyIdReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getKeyBindingWithKeyIdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getKeyBindingWithKeyIdCall {
            type Parameters<'a> = (KeyId,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = <KeyBindingWithSignature as alloy::sol_types::SolType>::RustType;
            type ReturnTuple<'a> = (KeyBindingWithSignature,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getKeyBindingWithKeyId(uint32)";
            const SELECTOR: [u8; 4] = [168u8, 180u8, 238u8, 201u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<KeyId as alloy_sol_types::SolType>::tokenize(&self.keyId),)
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (<KeyBindingWithSignature as alloy_sol_types::SolType>::tokenize(ret),)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getKeyBindingWithKeyIdReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getKeyBindingWithKeyIdReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getKeyIdRange()` and selector `0x773b4a33`.
```solidity
function getKeyIdRange() external pure returns (uint32 minKeyId, uint32 maxKeyId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKeyIdRangeCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getKeyIdRange()`](getKeyIdRangeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKeyIdRangeReturn {
        #[allow(missing_docs)]
        pub minKeyId: u32,
        #[allow(missing_docs)]
        pub maxKeyId: u32,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKeyIdRangeCall> for UnderlyingRustTuple<'_> {
                fn from(value: getKeyIdRangeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getKeyIdRangeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u32, u32);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKeyIdRangeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getKeyIdRangeReturn) -> Self {
                    (value.minKeyId, value.maxKeyId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getKeyIdRangeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        minKeyId: tuple.0,
                        maxKeyId: tuple.1,
                    }
                }
            }
        }
        impl getKeyIdRangeReturn {
            fn _tokenize(
                &self,
            ) -> <getKeyIdRangeCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.minKeyId),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxKeyId),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getKeyIdRangeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getKeyIdRangeReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<32>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getKeyIdRange()";
            const SELECTOR: [u8; 4] = [119u8, 59u8, 74u8, 51u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                getKeyIdRangeReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getKeyIdWithOffchainKey(bytes32)` and selector `0x604634c9`.
```solidity
function getKeyIdWithOffchainKey(bytes32 ed25519_pub_key) external view returns (bool, KeyId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKeyIdWithOffchainKeyCall {
        #[allow(missing_docs)]
        pub ed25519_pub_key: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getKeyIdWithOffchainKey(bytes32)`](getKeyIdWithOffchainKeyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKeyIdWithOffchainKeyReturn {
        #[allow(missing_docs)]
        pub _0: bool,
        #[allow(missing_docs)]
        pub _1: <KeyId as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKeyIdWithOffchainKeyCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getKeyIdWithOffchainKeyCall) -> Self {
                    (value.ed25519_pub_key,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getKeyIdWithOffchainKeyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { ed25519_pub_key: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool, KeyId);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                bool,
                <KeyId as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKeyIdWithOffchainKeyReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getKeyIdWithOffchainKeyReturn) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getKeyIdWithOffchainKeyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0, _1: tuple.1 }
                }
            }
        }
        impl getKeyIdWithOffchainKeyReturn {
            fn _tokenize(
                &self,
            ) -> <getKeyIdWithOffchainKeyCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                    <KeyId as alloy_sol_types::SolType>::tokenize(&self._1),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getKeyIdWithOffchainKeyCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getKeyIdWithOffchainKeyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool, KeyId);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getKeyIdWithOffchainKey(bytes32)";
            const SELECTOR: [u8; 4] = [96u8, 70u8, 52u8, 201u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ed25519_pub_key),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                getKeyIdWithOffchainKeyReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getOffchainKeyWithKeyId(uint32)` and selector `0x4ac3e4f2`.
```solidity
function getOffchainKeyWithKeyId(KeyId keyId) external view returns (bytes32 ed25519_pub_key);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getOffchainKeyWithKeyIdCall {
        #[allow(missing_docs)]
        pub keyId: <KeyId as alloy::sol_types::SolType>::RustType,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getOffchainKeyWithKeyId(uint32)`](getOffchainKeyWithKeyIdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getOffchainKeyWithKeyIdReturn {
        #[allow(missing_docs)]
        pub ed25519_pub_key: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (KeyId,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <KeyId as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOffchainKeyWithKeyIdCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getOffchainKeyWithKeyIdCall) -> Self {
                    (value.keyId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getOffchainKeyWithKeyIdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { keyId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOffchainKeyWithKeyIdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getOffchainKeyWithKeyIdReturn) -> Self {
                    (value.ed25519_pub_key,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getOffchainKeyWithKeyIdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { ed25519_pub_key: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getOffchainKeyWithKeyIdCall {
            type Parameters<'a> = (KeyId,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getOffchainKeyWithKeyId(uint32)";
            const SELECTOR: [u8; 4] = [74u8, 195u8, 228u8, 242u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<KeyId as alloy_sol_types::SolType>::tokenize(&self.keyId),)
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getOffchainKeyWithKeyIdReturn = r.into();
                        r.ed25519_pub_key
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getOffchainKeyWithKeyIdReturn = r.into();
                        r.ed25519_pub_key
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `isOffchainKeyBound(bytes32)` and selector `0xa969635a`.
```solidity
function isOffchainKeyBound(bytes32 ed25519_pub_key) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isOffchainKeyBoundCall {
        #[allow(missing_docs)]
        pub ed25519_pub_key: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`isOffchainKeyBound(bytes32)`](isOffchainKeyBoundCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isOffchainKeyBoundReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isOffchainKeyBoundCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: isOffchainKeyBoundCall) -> Self {
                    (value.ed25519_pub_key,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isOffchainKeyBoundCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { ed25519_pub_key: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isOffchainKeyBoundReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: isOffchainKeyBoundReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isOffchainKeyBoundReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isOffchainKeyBoundCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isOffchainKeyBound(bytes32)";
            const SELECTOR: [u8; 4] = [169u8, 105u8, 99u8, 90u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ed25519_pub_key),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: isOffchainKeyBoundReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: isOffchainKeyBoundReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `latestRoot()` and selector `0xd7b0fef1`.
```solidity
function latestRoot() external view returns (bytes28 rootHash, uint32 timestamp);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct latestRootCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`latestRoot()`](latestRootCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct latestRootReturn {
        #[allow(missing_docs)]
        pub rootHash: alloy::sol_types::private::FixedBytes<28>,
        #[allow(missing_docs)]
        pub timestamp: u32,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<latestRootCall> for UnderlyingRustTuple<'_> {
                fn from(value: latestRootCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for latestRootCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<28>,
                alloy::sol_types::sol_data::Uint<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<28>,
                u32,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<latestRootReturn> for UnderlyingRustTuple<'_> {
                fn from(value: latestRootReturn) -> Self {
                    (value.rootHash, value.timestamp)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for latestRootReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        rootHash: tuple.0,
                        timestamp: tuple.1,
                    }
                }
            }
        }
        impl latestRootReturn {
            fn _tokenize(
                &self,
            ) -> <latestRootCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        28,
                    > as alloy_sol_types::SolType>::tokenize(&self.rootHash),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.timestamp),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for latestRootCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = latestRootReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<28>,
                alloy::sol_types::sol_data::Uint<32>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "latestRoot()";
            const SELECTOR: [u8; 4] = [215u8, 176u8, 254u8, 241u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                latestRootReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `latestSnapshotRoot()` and selector `0x0df18f94`.
```solidity
function latestSnapshotRoot() external view returns (bytes28 rootHash, uint32 timestamp);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct latestSnapshotRootCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`latestSnapshotRoot()`](latestSnapshotRootCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct latestSnapshotRootReturn {
        #[allow(missing_docs)]
        pub rootHash: alloy::sol_types::private::FixedBytes<28>,
        #[allow(missing_docs)]
        pub timestamp: u32,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<latestSnapshotRootCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: latestSnapshotRootCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for latestSnapshotRootCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<28>,
                alloy::sol_types::sol_data::Uint<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<28>,
                u32,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<latestSnapshotRootReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: latestSnapshotRootReturn) -> Self {
                    (value.rootHash, value.timestamp)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for latestSnapshotRootReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        rootHash: tuple.0,
                        timestamp: tuple.1,
                    }
                }
            }
        }
        impl latestSnapshotRootReturn {
            fn _tokenize(
                &self,
            ) -> <latestSnapshotRootCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        28,
                    > as alloy_sol_types::SolType>::tokenize(&self.rootHash),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.timestamp),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for latestSnapshotRootCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = latestSnapshotRootReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<28>,
                alloy::sol_types::sol_data::Uint<32>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "latestSnapshotRoot()";
            const SELECTOR: [u8; 4] = [13u8, 241u8, 143u8, 148u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                latestSnapshotRootReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `ledgerDomainSeparator()` and selector `0xc966c4fe`.
```solidity
function ledgerDomainSeparator() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ledgerDomainSeparatorCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`ledgerDomainSeparator()`](ledgerDomainSeparatorCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ledgerDomainSeparatorReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ledgerDomainSeparatorCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: ledgerDomainSeparatorCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for ledgerDomainSeparatorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ledgerDomainSeparatorReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: ledgerDomainSeparatorReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for ledgerDomainSeparatorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ledgerDomainSeparatorCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ledgerDomainSeparator()";
            const SELECTOR: [u8; 4] = [201u8, 102u8, 196u8, 254u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: ledgerDomainSeparatorReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: ledgerDomainSeparatorReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `multiaddrOf(address)` and selector `0x53665aaa`.
```solidity
function multiaddrOf(address) external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct multiaddrOfCall(pub alloy::sol_types::private::Address);
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`multiaddrOf(address)`](multiaddrOfCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct multiaddrOfReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<multiaddrOfCall> for UnderlyingRustTuple<'_> {
                fn from(value: multiaddrOfCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for multiaddrOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<multiaddrOfReturn> for UnderlyingRustTuple<'_> {
                fn from(value: multiaddrOfReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for multiaddrOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for multiaddrOfCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::String;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "multiaddrOf(address)";
            const SELECTOR: [u8; 4] = [83u8, 102u8, 90u8, 170u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.0,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: multiaddrOfReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: multiaddrOfReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `multicall(bytes[])` and selector `0xac9650d8`.
```solidity
function multicall(bytes[] memory data) external returns (bytes[] memory results);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct multicallCall {
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`multicall(bytes[])`](multicallCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct multicallReturn {
        #[allow(missing_docs)]
        pub results: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<multicallCall> for UnderlyingRustTuple<'_> {
                fn from(value: multicallCall) -> Self {
                    (value.data,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for multicallCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { data: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<multicallReturn> for UnderlyingRustTuple<'_> {
                fn from(value: multicallReturn) -> Self {
                    (value.results,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for multicallReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { results: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for multicallCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Vec<
                alloy::sol_types::private::Bytes,
            >;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "multicall(bytes[])";
            const SELECTOR: [u8; 4] = [172u8, 150u8, 80u8, 216u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bytes,
                    > as alloy_sol_types::SolType>::tokenize(&self.data),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bytes,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: multicallReturn = r.into();
                        r.results
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: multicallReturn = r.into();
                        r.results
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `revoke()` and selector `0xb6549f75`.
```solidity
function revoke() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeCall;
    ///Container type for the return parameters of the [`revoke()`](revokeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeCall> for UnderlyingRustTuple<'_> {
                fn from(value: revokeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: revokeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl revokeReturn {
            fn _tokenize(
                &self,
            ) -> <revokeCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for revokeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = revokeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "revoke()";
            const SELECTOR: [u8; 4] = [182u8, 84u8, 159u8, 117u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                revokeReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `revokeSafe(address)` and selector `0x308c712e`.
```solidity
function revokeSafe(address selfAddress) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeSafeCall {
        #[allow(missing_docs)]
        pub selfAddress: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`revokeSafe(address)`](revokeSafeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeSafeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeSafeCall> for UnderlyingRustTuple<'_> {
                fn from(value: revokeSafeCall) -> Self {
                    (value.selfAddress,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeSafeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { selfAddress: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeSafeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: revokeSafeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeSafeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl revokeSafeReturn {
            fn _tokenize(
                &self,
            ) -> <revokeSafeCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for revokeSafeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = revokeSafeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "revokeSafe(address)";
            const SELECTOR: [u8; 4] = [48u8, 140u8, 113u8, 46u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.selfAddress,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                revokeSafeReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `tryGetKeyBinding(bytes32)` and selector `0xa2a07756`.
```solidity
function tryGetKeyBinding(bytes32 ed25519_pub_key) external view returns (bool, KeyId, KeyBindingWithSignature memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct tryGetKeyBindingCall {
        #[allow(missing_docs)]
        pub ed25519_pub_key: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`tryGetKeyBinding(bytes32)`](tryGetKeyBindingCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct tryGetKeyBindingReturn {
        #[allow(missing_docs)]
        pub _0: bool,
        #[allow(missing_docs)]
        pub _1: <KeyId as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub _2: <KeyBindingWithSignature as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<tryGetKeyBindingCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: tryGetKeyBindingCall) -> Self {
                    (value.ed25519_pub_key,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for tryGetKeyBindingCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { ed25519_pub_key: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Bool,
                KeyId,
                KeyBindingWithSignature,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                bool,
                <KeyId as alloy::sol_types::SolType>::RustType,
                <KeyBindingWithSignature as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<tryGetKeyBindingReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: tryGetKeyBindingReturn) -> Self {
                    (value._0, value._1, value._2)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for tryGetKeyBindingReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _0: tuple.0,
                        _1: tuple.1,
                        _2: tuple.2,
                    }
                }
            }
        }
        impl tryGetKeyBindingReturn {
            fn _tokenize(
                &self,
            ) -> <tryGetKeyBindingCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                    <KeyId as alloy_sol_types::SolType>::tokenize(&self._1),
                    <KeyBindingWithSignature as alloy_sol_types::SolType>::tokenize(
                        &self._2,
                    ),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for tryGetKeyBindingCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = tryGetKeyBindingReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Bool,
                KeyId,
                KeyBindingWithSignature,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "tryGetKeyBinding(bytes32)";
            const SELECTOR: [u8; 4] = [162u8, 160u8, 119u8, 86u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ed25519_pub_key),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                tryGetKeyBindingReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `updateLedgerDomainSeparator()` and selector `0xdc96fd50`.
```solidity
function updateLedgerDomainSeparator() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateLedgerDomainSeparatorCall;
    ///Container type for the return parameters of the [`updateLedgerDomainSeparator()`](updateLedgerDomainSeparatorCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateLedgerDomainSeparatorReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateLedgerDomainSeparatorCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateLedgerDomainSeparatorCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateLedgerDomainSeparatorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateLedgerDomainSeparatorReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateLedgerDomainSeparatorReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateLedgerDomainSeparatorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl updateLedgerDomainSeparatorReturn {
            fn _tokenize(
                &self,
            ) -> <updateLedgerDomainSeparatorCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateLedgerDomainSeparatorCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateLedgerDomainSeparatorReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateLedgerDomainSeparator()";
            const SELECTOR: [u8; 4] = [220u8, 150u8, 253u8, 80u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                updateLedgerDomainSeparatorReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`HoprAnnouncements`](self) function calls.
    #[derive(Clone)]
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    pub enum HoprAnnouncementsCalls {
        #[allow(missing_docs)]
        LEDGER_VERSION(LEDGER_VERSIONCall),
        #[allow(missing_docs)]
        SNAPSHOT_INTERVAL(SNAPSHOT_INTERVALCall),
        #[allow(missing_docs)]
        announce(announceCall),
        #[allow(missing_docs)]
        announceSafe(announceSafeCall),
        #[allow(missing_docs)]
        bindKeys(bindKeysCall),
        #[allow(missing_docs)]
        bindKeysAnnounce(bindKeysAnnounceCall),
        #[allow(missing_docs)]
        bindKeysAnnounceSafe(bindKeysAnnounceSafeCall),
        #[allow(missing_docs)]
        bindKeysSafe(bindKeysSafeCall),
        #[allow(missing_docs)]
        getAllKeyBindings(getAllKeyBindingsCall),
        #[allow(missing_docs)]
        getKeyBindingCount(getKeyBindingCountCall),
        #[allow(missing_docs)]
        getKeyBindingWithKeyId(getKeyBindingWithKeyIdCall),
        #[allow(missing_docs)]
        getKeyIdRange(getKeyIdRangeCall),
        #[allow(missing_docs)]
        getKeyIdWithOffchainKey(getKeyIdWithOffchainKeyCall),
        #[allow(missing_docs)]
        getOffchainKeyWithKeyId(getOffchainKeyWithKeyIdCall),
        #[allow(missing_docs)]
        isOffchainKeyBound(isOffchainKeyBoundCall),
        #[allow(missing_docs)]
        latestRoot(latestRootCall),
        #[allow(missing_docs)]
        latestSnapshotRoot(latestSnapshotRootCall),
        #[allow(missing_docs)]
        ledgerDomainSeparator(ledgerDomainSeparatorCall),
        #[allow(missing_docs)]
        multiaddrOf(multiaddrOfCall),
        #[allow(missing_docs)]
        multicall(multicallCall),
        #[allow(missing_docs)]
        revoke(revokeCall),
        #[allow(missing_docs)]
        revokeSafe(revokeSafeCall),
        #[allow(missing_docs)]
        tryGetKeyBinding(tryGetKeyBindingCall),
        #[allow(missing_docs)]
        updateLedgerDomainSeparator(updateLedgerDomainSeparatorCall),
    }
    impl HoprAnnouncementsCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [13u8, 241u8, 143u8, 148u8],
            [16u8, 171u8, 82u8, 151u8],
            [48u8, 140u8, 113u8, 46u8],
            [74u8, 195u8, 228u8, 242u8],
            [83u8, 102u8, 90u8, 170u8],
            [96u8, 70u8, 52u8, 201u8],
            [109u8, 43u8, 238u8, 241u8],
            [119u8, 59u8, 74u8, 51u8],
            [162u8, 160u8, 119u8, 86u8],
            [168u8, 180u8, 238u8, 201u8],
            [169u8, 105u8, 99u8, 90u8],
            [172u8, 150u8, 80u8, 216u8],
            [182u8, 84u8, 159u8, 117u8],
            [201u8, 102u8, 196u8, 254u8],
            [202u8, 226u8, 180u8, 52u8],
            [215u8, 176u8, 254u8, 241u8],
            [219u8, 185u8, 141u8, 145u8],
            [220u8, 150u8, 253u8, 80u8],
            [221u8, 173u8, 25u8, 2u8],
            [221u8, 185u8, 223u8, 193u8],
            [234u8, 10u8, 82u8, 55u8],
            [248u8, 62u8, 66u8, 146u8],
            [248u8, 132u8, 169u8, 203u8],
            [250u8, 208u8, 229u8, 162u8],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(latestSnapshotRoot),
            ::core::stringify!(getAllKeyBindings),
            ::core::stringify!(revokeSafe),
            ::core::stringify!(getOffchainKeyWithKeyId),
            ::core::stringify!(multiaddrOf),
            ::core::stringify!(getKeyIdWithOffchainKey),
            ::core::stringify!(SNAPSHOT_INTERVAL),
            ::core::stringify!(getKeyIdRange),
            ::core::stringify!(tryGetKeyBinding),
            ::core::stringify!(getKeyBindingWithKeyId),
            ::core::stringify!(isOffchainKeyBound),
            ::core::stringify!(multicall),
            ::core::stringify!(revoke),
            ::core::stringify!(ledgerDomainSeparator),
            ::core::stringify!(bindKeysSafe),
            ::core::stringify!(latestRoot),
            ::core::stringify!(bindKeys),
            ::core::stringify!(updateLedgerDomainSeparator),
            ::core::stringify!(LEDGER_VERSION),
            ::core::stringify!(bindKeysAnnounceSafe),
            ::core::stringify!(announce),
            ::core::stringify!(getKeyBindingCount),
            ::core::stringify!(bindKeysAnnounce),
            ::core::stringify!(announceSafe),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <latestSnapshotRootCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getAllKeyBindingsCall as alloy_sol_types::SolCall>::SIGNATURE,
            <revokeSafeCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getOffchainKeyWithKeyIdCall as alloy_sol_types::SolCall>::SIGNATURE,
            <multiaddrOfCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getKeyIdWithOffchainKeyCall as alloy_sol_types::SolCall>::SIGNATURE,
            <SNAPSHOT_INTERVALCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getKeyIdRangeCall as alloy_sol_types::SolCall>::SIGNATURE,
            <tryGetKeyBindingCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getKeyBindingWithKeyIdCall as alloy_sol_types::SolCall>::SIGNATURE,
            <isOffchainKeyBoundCall as alloy_sol_types::SolCall>::SIGNATURE,
            <multicallCall as alloy_sol_types::SolCall>::SIGNATURE,
            <revokeCall as alloy_sol_types::SolCall>::SIGNATURE,
            <ledgerDomainSeparatorCall as alloy_sol_types::SolCall>::SIGNATURE,
            <bindKeysSafeCall as alloy_sol_types::SolCall>::SIGNATURE,
            <latestRootCall as alloy_sol_types::SolCall>::SIGNATURE,
            <bindKeysCall as alloy_sol_types::SolCall>::SIGNATURE,
            <updateLedgerDomainSeparatorCall as alloy_sol_types::SolCall>::SIGNATURE,
            <LEDGER_VERSIONCall as alloy_sol_types::SolCall>::SIGNATURE,
            <bindKeysAnnounceSafeCall as alloy_sol_types::SolCall>::SIGNATURE,
            <announceCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getKeyBindingCountCall as alloy_sol_types::SolCall>::SIGNATURE,
            <bindKeysAnnounceCall as alloy_sol_types::SolCall>::SIGNATURE,
            <announceSafeCall as alloy_sol_types::SolCall>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for HoprAnnouncementsCalls {
        const NAME: &'static str = "HoprAnnouncementsCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 24usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::LEDGER_VERSION(_) => {
                    <LEDGER_VERSIONCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::SNAPSHOT_INTERVAL(_) => {
                    <SNAPSHOT_INTERVALCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::announce(_) => <announceCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::announceSafe(_) => {
                    <announceSafeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bindKeys(_) => <bindKeysCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::bindKeysAnnounce(_) => {
                    <bindKeysAnnounceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bindKeysAnnounceSafe(_) => {
                    <bindKeysAnnounceSafeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bindKeysSafe(_) => {
                    <bindKeysSafeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getAllKeyBindings(_) => {
                    <getAllKeyBindingsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getKeyBindingCount(_) => {
                    <getKeyBindingCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getKeyBindingWithKeyId(_) => {
                    <getKeyBindingWithKeyIdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getKeyIdRange(_) => {
                    <getKeyIdRangeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getKeyIdWithOffchainKey(_) => {
                    <getKeyIdWithOffchainKeyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getOffchainKeyWithKeyId(_) => {
                    <getOffchainKeyWithKeyIdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isOffchainKeyBound(_) => {
                    <isOffchainKeyBoundCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::latestRoot(_) => {
                    <latestRootCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::latestSnapshotRoot(_) => {
                    <latestSnapshotRootCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::ledgerDomainSeparator(_) => {
                    <ledgerDomainSeparatorCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::multiaddrOf(_) => {
                    <multiaddrOfCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::multicall(_) => {
                    <multicallCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::revoke(_) => <revokeCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::revokeSafe(_) => {
                    <revokeSafeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::tryGetKeyBinding(_) => {
                    <tryGetKeyBindingCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::updateLedgerDomainSeparator(_) => {
                    <updateLedgerDomainSeparatorCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<HoprAnnouncementsCalls>] = &[
                {
                    fn latestSnapshotRoot(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <latestSnapshotRootCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::latestSnapshotRoot)
                    }
                    latestSnapshotRoot
                },
                {
                    fn getAllKeyBindings(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <getAllKeyBindingsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::getAllKeyBindings)
                    }
                    getAllKeyBindings
                },
                {
                    fn revokeSafe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <revokeSafeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::revokeSafe)
                    }
                    revokeSafe
                },
                {
                    fn getOffchainKeyWithKeyId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <getOffchainKeyWithKeyIdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::getOffchainKeyWithKeyId)
                    }
                    getOffchainKeyWithKeyId
                },
                {
                    fn multiaddrOf(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <multiaddrOfCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::multiaddrOf)
                    }
                    multiaddrOf
                },
                {
                    fn getKeyIdWithOffchainKey(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <getKeyIdWithOffchainKeyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::getKeyIdWithOffchainKey)
                    }
                    getKeyIdWithOffchainKey
                },
                {
                    fn SNAPSHOT_INTERVAL(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <SNAPSHOT_INTERVALCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::SNAPSHOT_INTERVAL)
                    }
                    SNAPSHOT_INTERVAL
                },
                {
                    fn getKeyIdRange(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <getKeyIdRangeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::getKeyIdRange)
                    }
                    getKeyIdRange
                },
                {
                    fn tryGetKeyBinding(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <tryGetKeyBindingCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::tryGetKeyBinding)
                    }
                    tryGetKeyBinding
                },
                {
                    fn getKeyBindingWithKeyId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <getKeyBindingWithKeyIdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::getKeyBindingWithKeyId)
                    }
                    getKeyBindingWithKeyId
                },
                {
                    fn isOffchainKeyBound(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <isOffchainKeyBoundCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::isOffchainKeyBound)
                    }
                    isOffchainKeyBound
                },
                {
                    fn multicall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <multicallCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprAnnouncementsCalls::multicall)
                    }
                    multicall
                },
                {
                    fn revoke(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <revokeCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprAnnouncementsCalls::revoke)
                    }
                    revoke
                },
                {
                    fn ledgerDomainSeparator(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <ledgerDomainSeparatorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::ledgerDomainSeparator)
                    }
                    ledgerDomainSeparator
                },
                {
                    fn bindKeysSafe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <bindKeysSafeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::bindKeysSafe)
                    }
                    bindKeysSafe
                },
                {
                    fn latestRoot(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <latestRootCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::latestRoot)
                    }
                    latestRoot
                },
                {
                    fn bindKeys(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <bindKeysCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprAnnouncementsCalls::bindKeys)
                    }
                    bindKeys
                },
                {
                    fn updateLedgerDomainSeparator(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <updateLedgerDomainSeparatorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::updateLedgerDomainSeparator)
                    }
                    updateLedgerDomainSeparator
                },
                {
                    fn LEDGER_VERSION(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <LEDGER_VERSIONCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::LEDGER_VERSION)
                    }
                    LEDGER_VERSION
                },
                {
                    fn bindKeysAnnounceSafe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <bindKeysAnnounceSafeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::bindKeysAnnounceSafe)
                    }
                    bindKeysAnnounceSafe
                },
                {
                    fn announce(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <announceCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprAnnouncementsCalls::announce)
                    }
                    announce
                },
                {
                    fn getKeyBindingCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <getKeyBindingCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::getKeyBindingCount)
                    }
                    getKeyBindingCount
                },
                {
                    fn bindKeysAnnounce(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <bindKeysAnnounceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::bindKeysAnnounce)
                    }
                    bindKeysAnnounce
                },
                {
                    fn announceSafe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <announceSafeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::announceSafe)
                    }
                    announceSafe
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<HoprAnnouncementsCalls>] = &[
                {
                    fn latestSnapshotRoot(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <latestSnapshotRootCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::latestSnapshotRoot)
                    }
                    latestSnapshotRoot
                },
                {
                    fn getAllKeyBindings(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <getAllKeyBindingsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::getAllKeyBindings)
                    }
                    getAllKeyBindings
                },
                {
                    fn revokeSafe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <revokeSafeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::revokeSafe)
                    }
                    revokeSafe
                },
                {
                    fn getOffchainKeyWithKeyId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <getOffchainKeyWithKeyIdCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::getOffchainKeyWithKeyId)
                    }
                    getOffchainKeyWithKeyId
                },
                {
                    fn multiaddrOf(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <multiaddrOfCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::multiaddrOf)
                    }
                    multiaddrOf
                },
                {
                    fn getKeyIdWithOffchainKey(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <getKeyIdWithOffchainKeyCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::getKeyIdWithOffchainKey)
                    }
                    getKeyIdWithOffchainKey
                },
                {
                    fn SNAPSHOT_INTERVAL(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <SNAPSHOT_INTERVALCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::SNAPSHOT_INTERVAL)
                    }
                    SNAPSHOT_INTERVAL
                },
                {
                    fn getKeyIdRange(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <getKeyIdRangeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::getKeyIdRange)
                    }
                    getKeyIdRange
                },
                {
                    fn tryGetKeyBinding(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <tryGetKeyBindingCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::tryGetKeyBinding)
                    }
                    tryGetKeyBinding
                },
                {
                    fn getKeyBindingWithKeyId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <getKeyBindingWithKeyIdCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::getKeyBindingWithKeyId)
                    }
                    getKeyBindingWithKeyId
                },
                {
                    fn isOffchainKeyBound(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <isOffchainKeyBoundCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::isOffchainKeyBound)
                    }
                    isOffchainKeyBound
                },
                {
                    fn multicall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <multicallCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::multicall)
                    }
                    multicall
                },
                {
                    fn revoke(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <revokeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::revoke)
                    }
                    revoke
                },
                {
                    fn ledgerDomainSeparator(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <ledgerDomainSeparatorCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::ledgerDomainSeparator)
                    }
                    ledgerDomainSeparator
                },
                {
                    fn bindKeysSafe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <bindKeysSafeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::bindKeysSafe)
                    }
                    bindKeysSafe
                },
                {
                    fn latestRoot(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <latestRootCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::latestRoot)
                    }
                    latestRoot
                },
                {
                    fn bindKeys(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <bindKeysCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::bindKeys)
                    }
                    bindKeys
                },
                {
                    fn updateLedgerDomainSeparator(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <updateLedgerDomainSeparatorCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::updateLedgerDomainSeparator)
                    }
                    updateLedgerDomainSeparator
                },
                {
                    fn LEDGER_VERSION(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <LEDGER_VERSIONCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::LEDGER_VERSION)
                    }
                    LEDGER_VERSION
                },
                {
                    fn bindKeysAnnounceSafe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <bindKeysAnnounceSafeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::bindKeysAnnounceSafe)
                    }
                    bindKeysAnnounceSafe
                },
                {
                    fn announce(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <announceCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::announce)
                    }
                    announce
                },
                {
                    fn getKeyBindingCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <getKeyBindingCountCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::getKeyBindingCount)
                    }
                    getKeyBindingCount
                },
                {
                    fn bindKeysAnnounce(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <bindKeysAnnounceCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::bindKeysAnnounce)
                    }
                    bindKeysAnnounce
                },
                {
                    fn announceSafe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <announceSafeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::announceSafe)
                    }
                    announceSafe
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::LEDGER_VERSION(inner) => {
                    <LEDGER_VERSIONCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SNAPSHOT_INTERVAL(inner) => {
                    <SNAPSHOT_INTERVALCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::announce(inner) => {
                    <announceCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::announceSafe(inner) => {
                    <announceSafeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::bindKeys(inner) => {
                    <bindKeysCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::bindKeysAnnounce(inner) => {
                    <bindKeysAnnounceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::bindKeysAnnounceSafe(inner) => {
                    <bindKeysAnnounceSafeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::bindKeysSafe(inner) => {
                    <bindKeysSafeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getAllKeyBindings(inner) => {
                    <getAllKeyBindingsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getKeyBindingCount(inner) => {
                    <getKeyBindingCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getKeyBindingWithKeyId(inner) => {
                    <getKeyBindingWithKeyIdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getKeyIdRange(inner) => {
                    <getKeyIdRangeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getKeyIdWithOffchainKey(inner) => {
                    <getKeyIdWithOffchainKeyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getOffchainKeyWithKeyId(inner) => {
                    <getOffchainKeyWithKeyIdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::isOffchainKeyBound(inner) => {
                    <isOffchainKeyBoundCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::latestRoot(inner) => {
                    <latestRootCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::latestSnapshotRoot(inner) => {
                    <latestSnapshotRootCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ledgerDomainSeparator(inner) => {
                    <ledgerDomainSeparatorCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::multiaddrOf(inner) => {
                    <multiaddrOfCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::multicall(inner) => {
                    <multicallCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::revoke(inner) => {
                    <revokeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::revokeSafe(inner) => {
                    <revokeSafeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::tryGetKeyBinding(inner) => {
                    <tryGetKeyBindingCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::updateLedgerDomainSeparator(inner) => {
                    <updateLedgerDomainSeparatorCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::LEDGER_VERSION(inner) => {
                    <LEDGER_VERSIONCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SNAPSHOT_INTERVAL(inner) => {
                    <SNAPSHOT_INTERVALCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::announce(inner) => {
                    <announceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::announceSafe(inner) => {
                    <announceSafeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bindKeys(inner) => {
                    <bindKeysCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bindKeysAnnounce(inner) => {
                    <bindKeysAnnounceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bindKeysAnnounceSafe(inner) => {
                    <bindKeysAnnounceSafeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bindKeysSafe(inner) => {
                    <bindKeysSafeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getAllKeyBindings(inner) => {
                    <getAllKeyBindingsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getKeyBindingCount(inner) => {
                    <getKeyBindingCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getKeyBindingWithKeyId(inner) => {
                    <getKeyBindingWithKeyIdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getKeyIdRange(inner) => {
                    <getKeyIdRangeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getKeyIdWithOffchainKey(inner) => {
                    <getKeyIdWithOffchainKeyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getOffchainKeyWithKeyId(inner) => {
                    <getOffchainKeyWithKeyIdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isOffchainKeyBound(inner) => {
                    <isOffchainKeyBoundCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::latestRoot(inner) => {
                    <latestRootCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::latestSnapshotRoot(inner) => {
                    <latestSnapshotRootCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ledgerDomainSeparator(inner) => {
                    <ledgerDomainSeparatorCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::multiaddrOf(inner) => {
                    <multiaddrOfCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::multicall(inner) => {
                    <multicallCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::revoke(inner) => {
                    <revokeCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::revokeSafe(inner) => {
                    <revokeSafeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::tryGetKeyBinding(inner) => {
                    <tryGetKeyBindingCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::updateLedgerDomainSeparator(inner) => {
                    <updateLedgerDomainSeparatorCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`HoprAnnouncements`](self) custom errors.
    #[derive(Clone)]
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum HoprAnnouncementsErrors {
        #[allow(missing_docs)]
        AddressEmptyCode(AddressEmptyCode),
        #[allow(missing_docs)]
        AlreadyInitialized(AlreadyInitialized),
        #[allow(missing_docs)]
        ContractNotResponsible(ContractNotResponsible),
        #[allow(missing_docs)]
        EmptyMultiaddr(EmptyMultiaddr),
        #[allow(missing_docs)]
        ExistingKeyBinding(ExistingKeyBinding),
        #[allow(missing_docs)]
        FailedCall(FailedCall),
        #[allow(missing_docs)]
        InvalidSafeAddress(InvalidSafeAddress),
        #[allow(missing_docs)]
        KeyIdOutOfRange(KeyIdOutOfRange),
        #[allow(missing_docs)]
        MultiSigUninitialized(MultiSigUninitialized),
        #[allow(missing_docs)]
        ZeroAddress(ZeroAddress),
        #[allow(missing_docs)]
        ZeroInterval(ZeroInterval),
    }
    impl HoprAnnouncementsErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [9u8, 206u8, 172u8, 112u8],
            [11u8, 9u8, 141u8, 224u8],
            [13u8, 193u8, 73u8, 240u8],
            [33u8, 42u8, 119u8, 254u8],
            [52u8, 111u8, 246u8, 7u8],
            [69u8, 74u8, 32u8, 200u8],
            [142u8, 157u8, 124u8, 94u8],
            [153u8, 150u8, 179u8, 21u8],
            [172u8, 213u8, 168u8, 35u8],
            [214u8, 189u8, 162u8, 117u8],
            [234u8, 192u8, 211u8, 137u8],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(EmptyMultiaddr),
            ::core::stringify!(ExistingKeyBinding),
            ::core::stringify!(AlreadyInitialized),
            ::core::stringify!(KeyIdOutOfRange),
            ::core::stringify!(ZeroInterval),
            ::core::stringify!(MultiSigUninitialized),
            ::core::stringify!(InvalidSafeAddress),
            ::core::stringify!(AddressEmptyCode),
            ::core::stringify!(ContractNotResponsible),
            ::core::stringify!(FailedCall),
            ::core::stringify!(ZeroAddress),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <EmptyMultiaddr as alloy_sol_types::SolError>::SIGNATURE,
            <ExistingKeyBinding as alloy_sol_types::SolError>::SIGNATURE,
            <AlreadyInitialized as alloy_sol_types::SolError>::SIGNATURE,
            <KeyIdOutOfRange as alloy_sol_types::SolError>::SIGNATURE,
            <ZeroInterval as alloy_sol_types::SolError>::SIGNATURE,
            <MultiSigUninitialized as alloy_sol_types::SolError>::SIGNATURE,
            <InvalidSafeAddress as alloy_sol_types::SolError>::SIGNATURE,
            <AddressEmptyCode as alloy_sol_types::SolError>::SIGNATURE,
            <ContractNotResponsible as alloy_sol_types::SolError>::SIGNATURE,
            <FailedCall as alloy_sol_types::SolError>::SIGNATURE,
            <ZeroAddress as alloy_sol_types::SolError>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for HoprAnnouncementsErrors {
        const NAME: &'static str = "HoprAnnouncementsErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 11usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AddressEmptyCode(_) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AlreadyInitialized(_) => {
                    <AlreadyInitialized as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ContractNotResponsible(_) => {
                    <ContractNotResponsible as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyMultiaddr(_) => {
                    <EmptyMultiaddr as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ExistingKeyBinding(_) => {
                    <ExistingKeyBinding as alloy_sol_types::SolError>::SELECTOR
                }
                Self::FailedCall(_) => {
                    <FailedCall as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidSafeAddress(_) => {
                    <InvalidSafeAddress as alloy_sol_types::SolError>::SELECTOR
                }
                Self::KeyIdOutOfRange(_) => {
                    <KeyIdOutOfRange as alloy_sol_types::SolError>::SELECTOR
                }
                Self::MultiSigUninitialized(_) => {
                    <MultiSigUninitialized as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroAddress(_) => {
                    <ZeroAddress as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroInterval(_) => {
                    <ZeroInterval as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<HoprAnnouncementsErrors>] = &[
                {
                    fn EmptyMultiaddr(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsErrors> {
                        <EmptyMultiaddr as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HoprAnnouncementsErrors::EmptyMultiaddr)
                    }
                    EmptyMultiaddr
                },
                {
                    fn ExistingKeyBinding(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsErrors> {
                        <ExistingKeyBinding as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HoprAnnouncementsErrors::ExistingKeyBinding)
                    }
                    ExistingKeyBinding
                },
                {
                    fn AlreadyInitialized(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsErrors> {
                        <AlreadyInitialized as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HoprAnnouncementsErrors::AlreadyInitialized)
                    }
                    AlreadyInitialized
                },
                {
                    fn KeyIdOutOfRange(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsErrors> {
                        <KeyIdOutOfRange as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HoprAnnouncementsErrors::KeyIdOutOfRange)
                    }
                    KeyIdOutOfRange
                },
                {
                    fn ZeroInterval(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsErrors> {
                        <ZeroInterval as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(HoprAnnouncementsErrors::ZeroInterval)
                    }
                    ZeroInterval
                },
                {
                    fn MultiSigUninitialized(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsErrors> {
                        <MultiSigUninitialized as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HoprAnnouncementsErrors::MultiSigUninitialized)
                    }
                    MultiSigUninitialized
                },
                {
                    fn InvalidSafeAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsErrors> {
                        <InvalidSafeAddress as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HoprAnnouncementsErrors::InvalidSafeAddress)
                    }
                    InvalidSafeAddress
                },
                {
                    fn AddressEmptyCode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsErrors> {
                        <AddressEmptyCode as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HoprAnnouncementsErrors::AddressEmptyCode)
                    }
                    AddressEmptyCode
                },
                {
                    fn ContractNotResponsible(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsErrors> {
                        <ContractNotResponsible as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HoprAnnouncementsErrors::ContractNotResponsible)
                    }
                    ContractNotResponsible
                },
                {
                    fn FailedCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsErrors> {
                        <FailedCall as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(HoprAnnouncementsErrors::FailedCall)
                    }
                    FailedCall
                },
                {
                    fn ZeroAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsErrors> {
                        <ZeroAddress as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(HoprAnnouncementsErrors::ZeroAddress)
                    }
                    ZeroAddress
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<HoprAnnouncementsErrors>] = &[
                {
                    fn EmptyMultiaddr(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsErrors> {
                        <EmptyMultiaddr as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsErrors::EmptyMultiaddr)
                    }
                    EmptyMultiaddr
                },
                {
                    fn ExistingKeyBinding(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsErrors> {
                        <ExistingKeyBinding as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsErrors::ExistingKeyBinding)
                    }
                    ExistingKeyBinding
                },
                {
                    fn AlreadyInitialized(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsErrors> {
                        <AlreadyInitialized as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsErrors::AlreadyInitialized)
                    }
                    AlreadyInitialized
                },
                {
                    fn KeyIdOutOfRange(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsErrors> {
                        <KeyIdOutOfRange as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsErrors::KeyIdOutOfRange)
                    }
                    KeyIdOutOfRange
                },
                {
                    fn ZeroInterval(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsErrors> {
                        <ZeroInterval as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsErrors::ZeroInterval)
                    }
                    ZeroInterval
                },
                {
                    fn MultiSigUninitialized(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsErrors> {
                        <MultiSigUninitialized as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsErrors::MultiSigUninitialized)
                    }
                    MultiSigUninitialized
                },
                {
                    fn InvalidSafeAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsErrors> {
                        <InvalidSafeAddress as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsErrors::InvalidSafeAddress)
                    }
                    InvalidSafeAddress
                },
                {
                    fn AddressEmptyCode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsErrors> {
                        <AddressEmptyCode as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsErrors::AddressEmptyCode)
                    }
                    AddressEmptyCode
                },
                {
                    fn ContractNotResponsible(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsErrors> {
                        <ContractNotResponsible as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsErrors::ContractNotResponsible)
                    }
                    ContractNotResponsible
                },
                {
                    fn FailedCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsErrors> {
                        <FailedCall as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsErrors::FailedCall)
                    }
                    FailedCall
                },
                {
                    fn ZeroAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsErrors> {
                        <ZeroAddress as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsErrors::ZeroAddress)
                    }
                    ZeroAddress
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AddressEmptyCode(inner) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AlreadyInitialized(inner) => {
                    <AlreadyInitialized as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ContractNotResponsible(inner) => {
                    <ContractNotResponsible as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptyMultiaddr(inner) => {
                    <EmptyMultiaddr as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ExistingKeyBinding(inner) => {
                    <ExistingKeyBinding as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::FailedCall(inner) => {
                    <FailedCall as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InvalidSafeAddress(inner) => {
                    <InvalidSafeAddress as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::KeyIdOutOfRange(inner) => {
                    <KeyIdOutOfRange as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::MultiSigUninitialized(inner) => {
                    <MultiSigUninitialized as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ZeroAddress(inner) => {
                    <ZeroAddress as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ZeroInterval(inner) => {
                    <ZeroInterval as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AddressEmptyCode(inner) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AlreadyInitialized(inner) => {
                    <AlreadyInitialized as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ContractNotResponsible(inner) => {
                    <ContractNotResponsible as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyMultiaddr(inner) => {
                    <EmptyMultiaddr as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ExistingKeyBinding(inner) => {
                    <ExistingKeyBinding as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::FailedCall(inner) => {
                    <FailedCall as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::InvalidSafeAddress(inner) => {
                    <InvalidSafeAddress as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::KeyIdOutOfRange(inner) => {
                    <KeyIdOutOfRange as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::MultiSigUninitialized(inner) => {
                    <MultiSigUninitialized as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZeroAddress(inner) => {
                    <ZeroAddress as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZeroInterval(inner) => {
                    <ZeroInterval as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`HoprAnnouncements`](self) events.
    #[derive(Clone)]
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum HoprAnnouncementsEvents {
        #[allow(missing_docs)]
        AddressAnnouncement(AddressAnnouncement),
        #[allow(missing_docs)]
        KeyBinding(KeyBinding),
        #[allow(missing_docs)]
        LedgerDomainSeparatorUpdated(LedgerDomainSeparatorUpdated),
        #[allow(missing_docs)]
        RevokeAnnouncement(RevokeAnnouncement),
    }
    impl HoprAnnouncementsEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                164u8, 63u8, 173u8, 131u8, 146u8, 15u8, 208u8, 148u8, 69u8, 133u8, 94u8,
                133u8, 78u8, 115u8, 201u8, 197u8, 50u8, 225u8, 116u8, 2u8, 201u8, 206u8,
                176u8, 153u8, 147u8, 162u8, 57u8, 40u8, 67u8, 165u8, 189u8, 185u8,
            ],
            [
                164u8, 222u8, 48u8, 165u8, 40u8, 190u8, 202u8, 223u8, 130u8, 100u8,
                157u8, 19u8, 149u8, 192u8, 227u8, 13u8, 209u8, 138u8, 227u8, 91u8, 90u8,
                150u8, 206u8, 113u8, 233u8, 41u8, 91u8, 177u8, 75u8, 201u8, 243u8, 188u8,
            ],
            [
                191u8, 73u8, 204u8, 212u8, 26u8, 65u8, 24u8, 199u8, 225u8, 231u8, 33u8,
                67u8, 186u8, 216u8, 68u8, 229u8, 246u8, 237u8, 18u8, 191u8, 96u8, 202u8,
                166u8, 66u8, 216u8, 141u8, 25u8, 202u8, 16u8, 36u8, 76u8, 54u8,
            ],
            [
                196u8, 223u8, 91u8, 161u8, 104u8, 20u8, 131u8, 138u8, 178u8, 97u8, 136u8,
                41u8, 214u8, 143u8, 134u8, 35u8, 187u8, 137u8, 115u8, 2u8, 242u8, 77u8,
                189u8, 186u8, 34u8, 121u8, 219u8, 228u8, 90u8, 219u8, 61u8, 20u8,
            ],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(LedgerDomainSeparatorUpdated),
            ::core::stringify!(RevokeAnnouncement),
            ::core::stringify!(KeyBinding),
            ::core::stringify!(AddressAnnouncement),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <LedgerDomainSeparatorUpdated as alloy_sol_types::SolEvent>::SIGNATURE,
            <RevokeAnnouncement as alloy_sol_types::SolEvent>::SIGNATURE,
            <KeyBinding as alloy_sol_types::SolEvent>::SIGNATURE,
            <AddressAnnouncement as alloy_sol_types::SolEvent>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 32usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 32usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for HoprAnnouncementsEvents {
        const NAME: &'static str = "HoprAnnouncementsEvents";
        const COUNT: usize = 4usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(
                    <AddressAnnouncement as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <AddressAnnouncement as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::AddressAnnouncement)
                }
                Some(<KeyBinding as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <KeyBinding as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::KeyBinding)
                }
                Some(
                    <LedgerDomainSeparatorUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <LedgerDomainSeparatorUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::LedgerDomainSeparatorUpdated)
                }
                Some(
                    <RevokeAnnouncement as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <RevokeAnnouncement as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RevokeAnnouncement)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for HoprAnnouncementsEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::AddressAnnouncement(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::KeyBinding(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::LedgerDomainSeparatorUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RevokeAnnouncement(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::AddressAnnouncement(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::KeyBinding(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::LedgerDomainSeparatorUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RevokeAnnouncement(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`HoprAnnouncements`](self) contract instance.

See the [wrapper's documentation](`HoprAnnouncementsInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        __provider: P,
    ) -> HoprAnnouncementsInstance<P, N> {
        HoprAnnouncementsInstance::<P, N>::new(address, __provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        __provider: P,
        safeRegistry: alloy::sol_types::private::Address,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<HoprAnnouncementsInstance<P, N>>,
    > {
        HoprAnnouncementsInstance::<P, N>::deploy(__provider, safeRegistry)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        __provider: P,
        safeRegistry: alloy::sol_types::private::Address,
    ) -> alloy_contract::RawCallBuilder<P, N> {
        HoprAnnouncementsInstance::<P, N>::deploy_builder(__provider, safeRegistry)
    }
    /**A [`HoprAnnouncements`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`HoprAnnouncements`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct HoprAnnouncementsInstance<P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for HoprAnnouncementsInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("HoprAnnouncementsInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > HoprAnnouncementsInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`HoprAnnouncements`](self) contract instance.

See the [wrapper's documentation](`HoprAnnouncementsInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            __provider: P,
        ) -> Self {
            Self {
                address,
                provider: __provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            __provider: P,
            safeRegistry: alloy::sol_types::private::Address,
        ) -> alloy_contract::Result<HoprAnnouncementsInstance<P, N>> {
            let call_builder = Self::deploy_builder(__provider, safeRegistry);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            __provider: P,
            safeRegistry: alloy::sol_types::private::Address,
        ) -> alloy_contract::RawCallBuilder<P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                __provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall { safeRegistry },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> HoprAnnouncementsInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> HoprAnnouncementsInstance<P, N> {
            HoprAnnouncementsInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > HoprAnnouncementsInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`LEDGER_VERSION`] function.
        pub fn LEDGER_VERSION(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, LEDGER_VERSIONCall, N> {
            self.call_builder(&LEDGER_VERSIONCall)
        }
        ///Creates a new call builder for the [`SNAPSHOT_INTERVAL`] function.
        pub fn SNAPSHOT_INTERVAL(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, SNAPSHOT_INTERVALCall, N> {
            self.call_builder(&SNAPSHOT_INTERVALCall)
        }
        ///Creates a new call builder for the [`announce`] function.
        pub fn announce(
            &self,
            baseMultiaddr: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<&P, announceCall, N> {
            self.call_builder(&announceCall { baseMultiaddr })
        }
        ///Creates a new call builder for the [`announceSafe`] function.
        pub fn announceSafe(
            &self,
            selfAddress: alloy::sol_types::private::Address,
            baseMultiaddr: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<&P, announceSafeCall, N> {
            self.call_builder(
                &announceSafeCall {
                    selfAddress,
                    baseMultiaddr,
                },
            )
        }
        ///Creates a new call builder for the [`bindKeys`] function.
        pub fn bindKeys(
            &self,
            ed25519_sig_0: alloy::sol_types::private::FixedBytes<32>,
            ed25519_sig_1: alloy::sol_types::private::FixedBytes<32>,
            ed25519_pub_key: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, bindKeysCall, N> {
            self.call_builder(
                &bindKeysCall {
                    ed25519_sig_0,
                    ed25519_sig_1,
                    ed25519_pub_key,
                },
            )
        }
        ///Creates a new call builder for the [`bindKeysAnnounce`] function.
        pub fn bindKeysAnnounce(
            &self,
            ed25519_sig_0: alloy::sol_types::private::FixedBytes<32>,
            ed25519_sig_1: alloy::sol_types::private::FixedBytes<32>,
            ed25519_pub_key: alloy::sol_types::private::FixedBytes<32>,
            baseMultiaddr: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<&P, bindKeysAnnounceCall, N> {
            self.call_builder(
                &bindKeysAnnounceCall {
                    ed25519_sig_0,
                    ed25519_sig_1,
                    ed25519_pub_key,
                    baseMultiaddr,
                },
            )
        }
        ///Creates a new call builder for the [`bindKeysAnnounceSafe`] function.
        pub fn bindKeysAnnounceSafe(
            &self,
            selfAddress: alloy::sol_types::private::Address,
            ed25519_sig_0: alloy::sol_types::private::FixedBytes<32>,
            ed25519_sig_1: alloy::sol_types::private::FixedBytes<32>,
            ed25519_pub_key: alloy::sol_types::private::FixedBytes<32>,
            baseMultiaddr: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<&P, bindKeysAnnounceSafeCall, N> {
            self.call_builder(
                &bindKeysAnnounceSafeCall {
                    selfAddress,
                    ed25519_sig_0,
                    ed25519_sig_1,
                    ed25519_pub_key,
                    baseMultiaddr,
                },
            )
        }
        ///Creates a new call builder for the [`bindKeysSafe`] function.
        pub fn bindKeysSafe(
            &self,
            selfAddress: alloy::sol_types::private::Address,
            ed25519_sig_0: alloy::sol_types::private::FixedBytes<32>,
            ed25519_sig_1: alloy::sol_types::private::FixedBytes<32>,
            ed25519_pub_key: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, bindKeysSafeCall, N> {
            self.call_builder(
                &bindKeysSafeCall {
                    selfAddress,
                    ed25519_sig_0,
                    ed25519_sig_1,
                    ed25519_pub_key,
                },
            )
        }
        ///Creates a new call builder for the [`getAllKeyBindings`] function.
        pub fn getAllKeyBindings(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getAllKeyBindingsCall, N> {
            self.call_builder(&getAllKeyBindingsCall)
        }
        ///Creates a new call builder for the [`getKeyBindingCount`] function.
        pub fn getKeyBindingCount(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getKeyBindingCountCall, N> {
            self.call_builder(&getKeyBindingCountCall)
        }
        ///Creates a new call builder for the [`getKeyBindingWithKeyId`] function.
        pub fn getKeyBindingWithKeyId(
            &self,
            keyId: <KeyId as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<&P, getKeyBindingWithKeyIdCall, N> {
            self.call_builder(
                &getKeyBindingWithKeyIdCall {
                    keyId,
                },
            )
        }
        ///Creates a new call builder for the [`getKeyIdRange`] function.
        pub fn getKeyIdRange(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getKeyIdRangeCall, N> {
            self.call_builder(&getKeyIdRangeCall)
        }
        ///Creates a new call builder for the [`getKeyIdWithOffchainKey`] function.
        pub fn getKeyIdWithOffchainKey(
            &self,
            ed25519_pub_key: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, getKeyIdWithOffchainKeyCall, N> {
            self.call_builder(
                &getKeyIdWithOffchainKeyCall {
                    ed25519_pub_key,
                },
            )
        }
        ///Creates a new call builder for the [`getOffchainKeyWithKeyId`] function.
        pub fn getOffchainKeyWithKeyId(
            &self,
            keyId: <KeyId as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<&P, getOffchainKeyWithKeyIdCall, N> {
            self.call_builder(
                &getOffchainKeyWithKeyIdCall {
                    keyId,
                },
            )
        }
        ///Creates a new call builder for the [`isOffchainKeyBound`] function.
        pub fn isOffchainKeyBound(
            &self,
            ed25519_pub_key: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, isOffchainKeyBoundCall, N> {
            self.call_builder(
                &isOffchainKeyBoundCall {
                    ed25519_pub_key,
                },
            )
        }
        ///Creates a new call builder for the [`latestRoot`] function.
        pub fn latestRoot(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, latestRootCall, N> {
            self.call_builder(&latestRootCall)
        }
        ///Creates a new call builder for the [`latestSnapshotRoot`] function.
        pub fn latestSnapshotRoot(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, latestSnapshotRootCall, N> {
            self.call_builder(&latestSnapshotRootCall)
        }
        ///Creates a new call builder for the [`ledgerDomainSeparator`] function.
        pub fn ledgerDomainSeparator(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, ledgerDomainSeparatorCall, N> {
            self.call_builder(&ledgerDomainSeparatorCall)
        }
        ///Creates a new call builder for the [`multiaddrOf`] function.
        pub fn multiaddrOf(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, multiaddrOfCall, N> {
            self.call_builder(&multiaddrOfCall(_0))
        }
        ///Creates a new call builder for the [`multicall`] function.
        pub fn multicall(
            &self,
            data: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
        ) -> alloy_contract::SolCallBuilder<&P, multicallCall, N> {
            self.call_builder(&multicallCall { data })
        }
        ///Creates a new call builder for the [`revoke`] function.
        pub fn revoke(&self) -> alloy_contract::SolCallBuilder<&P, revokeCall, N> {
            self.call_builder(&revokeCall)
        }
        ///Creates a new call builder for the [`revokeSafe`] function.
        pub fn revokeSafe(
            &self,
            selfAddress: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, revokeSafeCall, N> {
            self.call_builder(&revokeSafeCall { selfAddress })
        }
        ///Creates a new call builder for the [`tryGetKeyBinding`] function.
        pub fn tryGetKeyBinding(
            &self,
            ed25519_pub_key: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, tryGetKeyBindingCall, N> {
            self.call_builder(
                &tryGetKeyBindingCall {
                    ed25519_pub_key,
                },
            )
        }
        ///Creates a new call builder for the [`updateLedgerDomainSeparator`] function.
        pub fn updateLedgerDomainSeparator(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, updateLedgerDomainSeparatorCall, N> {
            self.call_builder(&updateLedgerDomainSeparatorCall)
        }
    }
    /// Event filters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > HoprAnnouncementsInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`AddressAnnouncement`] event.
        pub fn AddressAnnouncement_filter(
            &self,
        ) -> alloy_contract::Event<&P, AddressAnnouncement, N> {
            self.event_filter::<AddressAnnouncement>()
        }
        ///Creates a new event filter for the [`KeyBinding`] event.
        pub fn KeyBinding_filter(&self) -> alloy_contract::Event<&P, KeyBinding, N> {
            self.event_filter::<KeyBinding>()
        }
        ///Creates a new event filter for the [`LedgerDomainSeparatorUpdated`] event.
        pub fn LedgerDomainSeparatorUpdated_filter(
            &self,
        ) -> alloy_contract::Event<&P, LedgerDomainSeparatorUpdated, N> {
            self.event_filter::<LedgerDomainSeparatorUpdated>()
        }
        ///Creates a new event filter for the [`RevokeAnnouncement`] event.
        pub fn RevokeAnnouncement_filter(
            &self,
        ) -> alloy_contract::Event<&P, RevokeAnnouncement, N> {
            self.event_filter::<RevokeAnnouncement>()
        }
    }
}
